<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8"/>
        <title>/home/hisa/Desktop/mysql-5.6.46/mysys/mf_iocache.c</title>
        <link rel="stylesheet" type="text/css" href="../css/prettyprint.css"/>
        <script type="text/javascript" src="../js/prettyprint.js"></script>
    </head>
    <body onload="prettyPrint()">
		<pre class="prettyprint lang-cpp linenums">
/* Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   Without limiting anything contained in the foregoing, this file,
   which is part of C Driver for MySQL (Connector/C), is also subject to the
   Universal FOSS Exception, version 1.0, a copy of which can be found at
   http://oss.oracle.com/licenses/universal-foss-exception.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */

/*
  Cashing of files with only does (sequential) read or writes of fixed-
  length records. A read isn't allowed to go over file-length. A read is ok
  if it ends at file-length and next read can try to read after file-length
  (and get a EOF-error).
  Possibly use of asyncronic io.
  macros for read and writes for faster io.
  Used instead of FILE when reading or writing whole files.
  This code makes mf_rec_cache obsolete (currently only used by ISAM)
  One can change info-&gt;pos_in_file to a higher value to skip bytes in file if
  also info-&gt;read_pos is set to info-&gt;read_end.
  If called through open_cached_file(), then the temporary file will
  only be created if a write exeeds the file buffer or if one calls
  my_b_flush_io_cache().

  If one uses SEQ_READ_APPEND, then two buffers are allocated, one for
  reading and another for writing.  Reads are first done from disk and
  then done from the write buffer.  This is an efficient way to read
  from a log file when one is writing to it at the same time.
  For this to work, the file has to be opened in append mode!
  Note that when one uses SEQ_READ_APPEND, one MUST write using
  my_b_append !  This is needed because we need to lock the mutex
  every time we access the write buffer.

TODO:
  When one SEQ_READ_APPEND and we are reading and writing at the same time,
  each time the write buffer gets full and it's written to disk, we will
  always do a disk read to read a part of the buffer from disk to the
  read buffer.
  This should be fixed so that when we do a my_b_flush_io_cache() and
  we have been reading the write buffer, we should transfer the rest of the
  write buffer to the read buffer before we start to reuse it.
*/

#include "mysys_priv.h"
#include &lt;m_string.h&gt;
#ifdef HAVE_AIOWAIT
#include "mysys_err.h"
static void my_aiowait(my_aio_result *result);
#endif
#include &lt;errno.h&gt;

#define lock_append_buffer(info) \
  mysql_mutex_lock(&amp;(info)-&gt;append_buffer_lock)
#define unlock_append_buffer(info) \
  mysql_mutex_unlock(&amp;(info)-&gt;append_buffer_lock)

#define IO_ROUND_UP(X) (((X)+IO_SIZE-1) &amp; ~(IO_SIZE-1))
#define IO_ROUND_DN(X) ( (X)            &amp; ~(IO_SIZE-1))

/*
  Setup internal pointers inside IO_CACHE

  SYNOPSIS
    setup_io_cache()
    info		IO_CACHE handler

  NOTES
    This is called on automaticly on init or reinit of IO_CACHE
    It must be called externally if one moves or copies an IO_CACHE
    object.
*/

void setup_io_cache(IO_CACHE* info)
{
  /* Ensure that my_b_tell() and my_b_bytes_in_cache works */
  if (info-&gt;type == WRITE_CACHE)
  {
    info-&gt;current_pos= &amp;info-&gt;write_pos;
    info-&gt;current_end= &amp;info-&gt;write_end;
  }
  else
  {
    info-&gt;current_pos= &amp;info-&gt;read_pos;
    info-&gt;current_end= &amp;info-&gt;read_end;
  }
}


static void
init_functions(IO_CACHE* info)
{
  enum cache_type type= info-&gt;type;
  switch (type) {
  case READ_NET:
    /*
      Must be initialized by the caller. The problem is that
      _my_b_net_read has to be defined in sql directory because of
      the dependency on THD, and therefore cannot be visible to
      programs that link against mysys but know nothing about THD, such
      as myisamchk
    */
    break;
  case SEQ_READ_APPEND:
    info-&gt;read_function = _my_b_seq_read;
    info-&gt;write_function = 0;			/* Force a core if used */
    break;
  default:
    info-&gt;read_function = info-&gt;share ? _my_b_read_r : _my_b_read;
    info-&gt;write_function = _my_b_write;
  }

  setup_io_cache(info);
}


/*
  Initialize an IO_CACHE object

  SYNOPSOS
    init_io_cache()
    info		cache handler to initialize
    file		File that should be associated to to the handler
			If == -1 then real_open_cached_file()
			will be called when it's time to open file.
    cachesize		Size of buffer to allocate for read/write
			If == 0 then use my_default_record_cache_size
    type		Type of cache
    seek_offset		Where cache should start reading/writing
    use_async_io	Set to 1 of we should use async_io (if avaiable)
    cache_myflags	Bitmap of differnt flags
			MY_WME | MY_FAE | MY_NABP | MY_FNABP |
			MY_DONT_CHECK_FILESIZE

  RETURN
    0  ok
    #  error
*/

int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
		  enum cache_type type, my_off_t seek_offset,
		  pbool use_async_io, myf cache_myflags)
{
  size_t min_cache;
  my_off_t pos;
  my_off_t end_of_file= ~(my_off_t) 0;
  DBUG_ENTER("init_io_cache");
  DBUG_PRINT("enter",("cache: 0x%lx  type: %d  pos: %ld",
		      (ulong) info, (int) type, (ulong) seek_offset));

  info-&gt;file= file;
  info-&gt;type= TYPE_NOT_SET;	    /* Don't set it until mutex are created */
  info-&gt;pos_in_file= seek_offset;
  info-&gt;pre_close = info-&gt;pre_read = info-&gt;post_read = 0;
  info-&gt;arg = 0;
  info-&gt;alloced_buffer = 0;
  info-&gt;buffer=0;
  info-&gt;seek_not_done= 0;

  if (file &gt;= 0)
  {
    pos= mysql_file_tell(file, MYF(0));
    if ((pos == (my_off_t) -1) &amp;&amp; (my_errno == ESPIPE))
    {
      /*
         This kind of object doesn't support seek() or tell(). Don't set a
         flag that will make us again try to seek() later and fail.
      */
      info-&gt;seek_not_done= 0;
      /*
        Additionally, if we're supposed to start somewhere other than the
        the beginning of whatever this file is, then somebody made a bad
        assumption.
      */
      DBUG_ASSERT(seek_offset == 0);
    }
    else
      info-&gt;seek_not_done= MY_TEST(seek_offset != pos);
  }

  info-&gt;disk_writes= 0;
  info-&gt;share=0;

  if (!cachesize &amp;&amp; !(cachesize= my_default_record_cache_size))
    DBUG_RETURN(1);				/* No cache requested */
  min_cache=use_async_io ? IO_SIZE*4 : IO_SIZE*2;
  if (type == READ_CACHE || type == SEQ_READ_APPEND)
  {						/* Assume file isn't growing */
    if (!(cache_myflags &amp; MY_DONT_CHECK_FILESIZE))
    {
      /* Calculate end of file to avoid allocating oversized buffers */
      end_of_file= mysql_file_seek(file, 0L, MY_SEEK_END, MYF(0));
      /* Need to reset seek_not_done now that we just did a seek. */
      info-&gt;seek_not_done= end_of_file == seek_offset ? 0 : 1;
      if (end_of_file &lt; seek_offset)
	end_of_file=seek_offset;
      /* Trim cache size if the file is very small */
      if ((my_off_t) cachesize &gt; end_of_file-seek_offset+IO_SIZE*2-1)
      {
	cachesize= (size_t) (end_of_file-seek_offset)+IO_SIZE*2-1;
<span style = "background-color:#fdd">	use_async_io=0;				/* No need to use async */        Dead assignment:Value stored to 'use_async_io' is never read</span>
      }
    }
  }
  cache_myflags &amp;= ~MY_DONT_CHECK_FILESIZE;
  if (type != READ_NET &amp;&amp; type != WRITE_NET)
  {
    /* Retry allocating memory in smaller blocks until we get one */
    cachesize= ((cachesize + min_cache-1) &amp; ~(min_cache-1));
    for (;;)
    {
      size_t buffer_block;
      /*
        Unset MY_WAIT_IF_FULL bit if it is set, to prevent conflict with
        MY_ZEROFILL.
      */
      myf flags= (myf) (cache_myflags &amp; ~(MY_WME | MY_WAIT_IF_FULL));

      if (cachesize &lt; min_cache)
	cachesize = min_cache;
      buffer_block= cachesize;
      if (type == SEQ_READ_APPEND)
	buffer_block *= 2;
      if (cachesize == min_cache)
        flags|= (myf) MY_WME;

      if ((info-&gt;buffer= (uchar*) my_malloc(buffer_block, flags)) != 0)
      {
	info-&gt;write_buffer=info-&gt;buffer;
	if (type == SEQ_READ_APPEND)
	  info-&gt;write_buffer = info-&gt;buffer + cachesize;
	info-&gt;alloced_buffer=1;
	break;					/* Enough memory found */
      }
      if (cachesize == min_cache)
	DBUG_RETURN(2);				/* Can't alloc cache */
      /* Try with less memory */
      cachesize= (cachesize*3/4 &amp; ~(min_cache-1));
    }
  }

  DBUG_PRINT("info",("init_io_cache: cachesize = %lu", (ulong) cachesize));
  info-&gt;read_length=info-&gt;buffer_length=cachesize;
  info-&gt;myflags=cache_myflags &amp; ~(MY_NABP | MY_FNABP);
  info-&gt;request_pos= info-&gt;read_pos= info-&gt;write_pos = info-&gt;buffer;
  if (type == SEQ_READ_APPEND)
  {
    info-&gt;append_read_pos = info-&gt;write_pos = info-&gt;write_buffer;
    info-&gt;write_end = info-&gt;write_buffer + info-&gt;buffer_length;
    mysql_mutex_init(key_IO_CACHE_append_buffer_lock,
                     &amp;info-&gt;append_buffer_lock, MY_MUTEX_INIT_FAST);
  }
#if defined(SAFE_MUTEX)
  else
  {
    /* Clear mutex so that safe_mutex will notice that it's not initialized */
    memset(&amp;info-&gt;append_buffer_lock, 0, sizeof(info-&gt;append_buffer_lock));
  }
#endif

  if (type == WRITE_CACHE)
    info-&gt;write_end=
      info-&gt;buffer+info-&gt;buffer_length- (seek_offset &amp; (IO_SIZE-1));
  else
    info-&gt;read_end=info-&gt;buffer;		/* Nothing in cache */

  /* End_of_file may be changed by user later */
  info-&gt;end_of_file= end_of_file;
  info-&gt;error=0;
  info-&gt;type= type;
  init_functions(info);
#ifdef HAVE_AIOWAIT
  if (use_async_io &amp;&amp; ! my_disable_async_io)
  {
    DBUG_PRINT("info",("Using async io"));
    info-&gt;read_length/=2;
    info-&gt;read_function=_my_b_async_read;
  }
  info-&gt;inited=info-&gt;aio_result.pending=0;
#endif
  DBUG_RETURN(0);
}						/* init_io_cache */

	/* Wait until current request is ready */

#ifdef HAVE_AIOWAIT
static void my_aiowait(my_aio_result *result)
{
  if (result-&gt;pending)
  {
    struct aio_result_t *tmp;
    for (;;)
    {
      if ((int) (tmp=aiowait((struct timeval *) 0)) == -1)
      {
	if (errno == EINTR)
	  continue;
	DBUG_PRINT("error",("No aio request, error: %d",errno));
	result-&gt;pending=0;			/* Assume everythings is ok */
	break;
      }
      ((my_aio_result*) tmp)-&gt;pending=0;
      if ((my_aio_result*) tmp == result)
	break;
    }
  }
  return;
}
#endif


/*
  Use this to reset cache to re-start reading or to change the type
  between READ_CACHE &lt;-&gt; WRITE_CACHE
  If we are doing a reinit of a cache where we have the start of the file
  in the cache, we are reusing this memory without flushing it to disk.
*/

my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
			my_off_t seek_offset,
			pbool use_async_io MY_ATTRIBUTE((unused)),
			pbool clear_cache)
{
  DBUG_ENTER("reinit_io_cache");
  DBUG_PRINT("enter",("cache: 0x%lx type: %d  seek_offset: %lu  clear_cache: %d",
		      (ulong) info, type, (ulong) seek_offset,
		      (int) clear_cache));

  /* One can't do reinit with the following types */
  DBUG_ASSERT(type != READ_NET &amp;&amp; info-&gt;type != READ_NET &amp;&amp;
	      type != WRITE_NET &amp;&amp; info-&gt;type != WRITE_NET &amp;&amp;
	      type != SEQ_READ_APPEND &amp;&amp; info-&gt;type != SEQ_READ_APPEND);

  /* If the whole file is in memory, avoid flushing to disk */
  if (! clear_cache &amp;&amp;
      seek_offset &gt;= info-&gt;pos_in_file &amp;&amp;
      seek_offset &lt;= my_b_tell(info))
  {
    /* Reuse current buffer without flushing it to disk */
    uchar *pos;
    if (info-&gt;type == WRITE_CACHE &amp;&amp; type == READ_CACHE)
    {
      info-&gt;read_end=info-&gt;write_pos;
      info-&gt;end_of_file=my_b_tell(info);
      /*
        Trigger a new seek only if we have a valid
        file handle.
      */
      info-&gt;seek_not_done= (info-&gt;file != -1);
    }
    else if (type == WRITE_CACHE)
    {
      if (info-&gt;type == READ_CACHE)
      {
	info-&gt;write_end=info-&gt;write_buffer+info-&gt;buffer_length;
	info-&gt;seek_not_done=1;
      }
      info-&gt;end_of_file = ~(my_off_t) 0;
    }
    pos=info-&gt;request_pos+(seek_offset-info-&gt;pos_in_file);
    if (type == WRITE_CACHE)
      info-&gt;write_pos=pos;
    else
      info-&gt;read_pos= pos;
#ifdef HAVE_AIOWAIT
    my_aiowait(&amp;info-&gt;aio_result);		/* Wait for outstanding req */
#endif
  }
  else
  {
    /*
      If we change from WRITE_CACHE to READ_CACHE, assume that everything
      after the current positions should be ignored
    */
    if (info-&gt;type == WRITE_CACHE &amp;&amp; type == READ_CACHE)
      info-&gt;end_of_file=my_b_tell(info);
    /* flush cache if we want to reuse it */
    if (!clear_cache &amp;&amp; my_b_flush_io_cache(info,1))
      DBUG_RETURN(1);
    info-&gt;pos_in_file=seek_offset;
    /* Better to do always do a seek */
    info-&gt;seek_not_done=1;
    info-&gt;request_pos=info-&gt;read_pos=info-&gt;write_pos=info-&gt;buffer;
    if (type == READ_CACHE)
    {
      info-&gt;read_end=info-&gt;buffer;		/* Nothing in cache */
    }
    else
    {
      info-&gt;write_end=(info-&gt;buffer + info-&gt;buffer_length -
		       (seek_offset &amp; (IO_SIZE-1)));
      info-&gt;end_of_file= ~(my_off_t) 0;
    }
  }
  info-&gt;type=type;
  info-&gt;error=0;
  init_functions(info);

#ifdef HAVE_AIOWAIT
  if (use_async_io &amp;&amp; ! my_disable_async_io &amp;&amp;
      ((ulong) info-&gt;buffer_length &lt;
       (ulong) (info-&gt;end_of_file - seek_offset)))
  {
    info-&gt;read_length=info-&gt;buffer_length/2;
    info-&gt;read_function=_my_b_async_read;
  }
  info-&gt;inited=0;
#endif
  DBUG_RETURN(0);
} /* reinit_io_cache */



/*
  Read buffered.

  SYNOPSIS
    _my_b_read()
      info                      IO_CACHE pointer
      Buffer                    Buffer to retrieve count bytes from file
      Count                     Number of bytes to read into Buffer

  NOTE
    This function is only called from the my_b_read() macro when there
    isn't enough characters in the buffer to satisfy the request.

  WARNING

    When changing this function, be careful with handling file offsets
    (end-of_file, pos_in_file). Do not cast them to possibly smaller
    types than my_off_t unless you can be sure that their value fits.
    Same applies to differences of file offsets.

    When changing this function, check _my_b_read_r(). It might need the
    same change.

  RETURN
    0      we succeeded in reading all data
    1      Error: couldn't read requested characters. In this case:
             If info-&gt;error == -1, we got a read error.
             Otherwise info-&gt;error contains the number of bytes in Buffer.
*/

int _my_b_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
{
  size_t length,diff_length,left_length, max_length;
  my_off_t pos_in_file;
  DBUG_ENTER("_my_b_read");

  /* If the buffer is not empty yet, copy what is available. */
  if ((left_length= (size_t) (info-&gt;read_end-info-&gt;read_pos)))
  {
    DBUG_ASSERT(Count &gt;= left_length);	/* User is not using my_b_read() */
    memcpy(Buffer,info-&gt;read_pos, left_length);
    Buffer+=left_length;
    Count-=left_length;
  }

  /* pos_in_file always point on where info-&gt;buffer was read */
  pos_in_file=info-&gt;pos_in_file+ (size_t) (info-&gt;read_end - info-&gt;buffer);

  /*
    Whenever a function which operates on IO_CACHE flushes/writes
    some part of the IO_CACHE to disk it will set the property
    "seek_not_done" to indicate this to other functions operating
    on the IO_CACHE.
  */
  if (info-&gt;seek_not_done)
  {
    if ((mysql_file_seek(info-&gt;file, pos_in_file, MY_SEEK_SET, MYF(0)) 
        != MY_FILEPOS_ERROR))
    {
      /* No error, reset seek_not_done flag. */
      info-&gt;seek_not_done= 0;
    }
    else
    {
      /*
        If the seek failed and the error number is ESPIPE, it is because
        info-&gt;file is a pipe or socket or FIFO.  We never should have tried
        to seek on that.  See Bugs#25807 and #22828 for more info.
      */
      DBUG_ASSERT(my_errno != ESPIPE);
      info-&gt;error= -1;
      DBUG_RETURN(1);
    }
  }

  /*
    Calculate, how much we are within a IO_SIZE block. Ideally this
    should be zero.
  */
  diff_length= (size_t) (pos_in_file &amp; (IO_SIZE-1));

  /*
    If more than a block plus the rest of the current block is wanted,
    we do read directly, without filling the buffer.
  */
  if (Count &gt;= (size_t) (IO_SIZE+(IO_SIZE-diff_length)))
  {					/* Fill first intern buffer */
    size_t read_length;
    if (info-&gt;end_of_file &lt;= pos_in_file)
    {
      /* End of file. Return, what we did copy from the buffer. */
      info-&gt;error= (int) left_length;
      DBUG_RETURN(1);
    }
    /*
      Crop the wanted count to a multiple of IO_SIZE and subtract,
      what we did already read from a block. That way, the read will
      end aligned with a block.
    */
    length=(Count &amp; (size_t) ~(IO_SIZE-1))-diff_length;
    if ((read_length= mysql_file_read(info-&gt;file,Buffer, length, info-&gt;myflags))
	!= length)
    {
      /*
        If we didn't get, what we wanted, we either return -1 for a read
        error, or (it's end of file), how much we got in total.
      */
      info-&gt;error= (read_length == (size_t) -1 ? -1 :
		    (int) (read_length+left_length));
      DBUG_RETURN(1);
    }
    Count-=length;
    Buffer+=length;
    pos_in_file+=length;
    left_length+=length;
    diff_length=0;
  }

  /*
    At this point, we want less than one and a partial block.
    We will read a full cache, minus the number of bytes, we are
    within a block already. So we will reach new alignment.
  */
  max_length= info-&gt;read_length-diff_length;
  /* We will not read past end of file. */
  if (info-&gt;type != READ_FIFO &amp;&amp;
      max_length &gt; (info-&gt;end_of_file - pos_in_file))
    max_length= (size_t) (info-&gt;end_of_file - pos_in_file);
  /*
    If there is nothing left to read,
      we either are done, or we failed to fulfill the request.
    Otherwise, we read max_length into the cache.
  */
  if (!max_length)
  {
    if (Count)
    {
      /* We couldn't fulfil the request. Return, how much we got. */
      info-&gt;error= left_length;
      DBUG_RETURN(1);
    }
    length=0;				/* Didn't read any chars */
  }
  else if ((length= mysql_file_read(info-&gt;file,info-&gt;buffer, max_length,
                            info-&gt;myflags)) &lt; Count ||
	   length == (size_t) -1)
  {
    /*
      We got an read error, or less than requested (end of file).
      If not a read error, copy, what we got.
    */
    if (length != (size_t) -1)
      memcpy(Buffer, info-&gt;buffer, length);
    info-&gt;pos_in_file= pos_in_file;
    /* For a read error, return -1, otherwise, what we got in total. */
    info-&gt;error= length == (size_t) -1 ? -1 : (int) (length+left_length);
    info-&gt;read_pos=info-&gt;read_end=info-&gt;buffer;
    DBUG_RETURN(1);
  }
  /*
    Count is the remaining number of bytes requested.
    length is the amount of data in the cache.
    Read Count bytes from the cache.
  */
  info-&gt;read_pos=info-&gt;buffer+Count;
  info-&gt;read_end=info-&gt;buffer+length;
  info-&gt;pos_in_file=pos_in_file;
  memcpy(Buffer, info-&gt;buffer, Count);
  DBUG_RETURN(0);
}


/*
  Prepare IO_CACHE for shared use.

  SYNOPSIS
    init_io_cache_share()
      read_cache                A read cache. This will be copied for
                                every thread after setup.
      cshare                    The share.
      write_cache               If non-NULL a write cache that is to be
                                synchronized with the read caches.
      num_threads               Number of threads sharing the cache
                                including the write thread if any.

  DESCRIPTION

    The shared cache is used so: One IO_CACHE is initialized with
    init_io_cache(). This includes the allocation of a buffer. Then a
    share is allocated and init_io_cache_share() is called with the io
    cache and the share. Then the io cache is copied for each thread. So
    every thread has its own copy of IO_CACHE. But the allocated buffer
    is shared because cache-&gt;buffer is the same for all caches.

    One thread reads data from the file into the buffer. All threads
    read from the buffer, but every thread maintains its own set of
    pointers into the buffer. When all threads have used up the buffer
    contents, one of the threads reads the next block of data into the
    buffer. To accomplish this, each thread enters the cache lock before
    accessing the buffer. They wait in lock_io_cache() until all threads
    joined the lock. The last thread entering the lock is in charge of
    reading from file to buffer. It wakes all threads when done.

    Synchronizing a write cache to the read caches works so: Whenever
    the write buffer needs a flush, the write thread enters the lock and
    waits for all other threads to enter the lock too. They do this when
    they have used up the read buffer. When all threads are in the lock,
    the write thread copies the write buffer to the read buffer and
    wakes all threads.

    share-&gt;running_threads is the number of threads not being in the
    cache lock. When entering lock_io_cache() the number is decreased.
    When the thread that fills the buffer enters unlock_io_cache() the
    number is reset to the number of threads. The condition
    running_threads == 0 means that all threads are in the lock. Bumping
    up the number to the full count is non-intuitive. But increasing the
    number by one for each thread that leaves the lock could lead to a
    solo run of one thread. The last thread to join a lock reads from
    file to buffer, wakes the other threads, processes the data in the
    cache and enters the lock again. If no other thread left the lock
    meanwhile, it would think it's the last one again and read the next
    block...

    The share has copies of 'error', 'buffer', 'read_end', and
    'pos_in_file' from the thread that filled the buffer. We may not be
    able to access this information directly from its cache because the
    thread may be removed from the share before the variables could be
    copied by all other threads. Or, if a write buffer is synchronized,
    it would change its 'pos_in_file' after waking the other threads,
    possibly before they could copy its value.

    However, the 'buffer' variable in the share is for a synchronized
    write cache. It needs to know where to put the data. Otherwise it
    would need access to the read cache of one of the threads that is
    not yet removed from the share.

  RETURN
    void
*/

void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,
                         IO_CACHE *write_cache, uint num_threads)
{
  DBUG_ENTER("init_io_cache_share");
  DBUG_PRINT("io_cache_share", ("read_cache: 0x%lx  share: 0x%lx  "
                                "write_cache: 0x%lx  threads: %u",
                                (long) read_cache, (long) cshare,
                                (long) write_cache, num_threads));

  DBUG_ASSERT(num_threads &gt; 1);
  DBUG_ASSERT(read_cache-&gt;type == READ_CACHE);
  DBUG_ASSERT(!write_cache || (write_cache-&gt;type == WRITE_CACHE));

  mysql_mutex_init(key_IO_CACHE_SHARE_mutex,
                   &amp;cshare-&gt;mutex, MY_MUTEX_INIT_FAST);
  mysql_cond_init(key_IO_CACHE_SHARE_cond, &amp;cshare-&gt;cond, 0);
  mysql_cond_init(key_IO_CACHE_SHARE_cond_writer, &amp;cshare-&gt;cond_writer, 0);

  cshare-&gt;running_threads= num_threads;
  cshare-&gt;total_threads=   num_threads;
  cshare-&gt;error=           0;    /* Initialize. */
  cshare-&gt;buffer=          read_cache-&gt;buffer;
  cshare-&gt;read_end=        NULL; /* See function comment of lock_io_cache(). */
  cshare-&gt;pos_in_file=     0;    /* See function comment of lock_io_cache(). */
  cshare-&gt;source_cache=    write_cache; /* Can be NULL. */

  read_cache-&gt;share=         cshare;
  read_cache-&gt;read_function= _my_b_read_r;
  read_cache-&gt;current_pos=   NULL;
  read_cache-&gt;current_end=   NULL;

  if (write_cache)
    write_cache-&gt;share= cshare;

  DBUG_VOID_RETURN;
}


/*
  Remove a thread from shared access to IO_CACHE.

  SYNOPSIS
    remove_io_thread()
      cache                     The IO_CACHE to be removed from the share.

  NOTE

    Every thread must do that on exit for not to deadlock other threads.

    The last thread destroys the pthread resources.

    A writer flushes its cache first.

  RETURN
    void
*/

void remove_io_thread(IO_CACHE *cache)
{
  IO_CACHE_SHARE *cshare= cache-&gt;share;
  uint total;
  DBUG_ENTER("remove_io_thread");

  /* If the writer goes, it needs to flush the write cache. */
  if (cache == cshare-&gt;source_cache)
    flush_io_cache(cache);

  mysql_mutex_lock(&amp;cshare-&gt;mutex);
  DBUG_PRINT("io_cache_share", ("%s: 0x%lx",
                                (cache == cshare-&gt;source_cache) ?
                                "writer" : "reader", (long) cache));

  /* Remove from share. */
  total= --cshare-&gt;total_threads;
  DBUG_PRINT("io_cache_share", ("remaining threads: %u", total));

  /* Detach from share. */
  cache-&gt;share= NULL;

  /* If the writer goes, let the readers know. */
  if (cache == cshare-&gt;source_cache)
  {
    DBUG_PRINT("io_cache_share", ("writer leaves"));
    cshare-&gt;source_cache= NULL;
  }

  /* If all threads are waiting for me to join the lock, wake them. */
  if (!--cshare-&gt;running_threads)
  {
    DBUG_PRINT("io_cache_share", ("the last running thread leaves, wake all"));
    mysql_cond_signal(&amp;cshare-&gt;cond_writer);
    mysql_cond_broadcast(&amp;cshare-&gt;cond);
  }

  mysql_mutex_unlock(&amp;cshare-&gt;mutex);

  if (!total)
  {
    DBUG_PRINT("io_cache_share", ("last thread removed, destroy share"));
    mysql_cond_destroy (&amp;cshare-&gt;cond_writer);
    mysql_cond_destroy (&amp;cshare-&gt;cond);
    mysql_mutex_destroy(&amp;cshare-&gt;mutex);
  }

  DBUG_VOID_RETURN;
}


/*
  Lock IO cache and wait for all other threads to join.

  SYNOPSIS
    lock_io_cache()
      cache                     The cache of the thread entering the lock.
      pos                       File position of the block to read.
                                Unused for the write thread.

  DESCRIPTION

    Wait for all threads to finish with the current buffer. We want
    all threads to proceed in concert. The last thread to join
    lock_io_cache() will read the block from file and all threads start
    to use it. Then they will join again for reading the next block.

    The waiting threads detect a fresh buffer by comparing
    cshare-&gt;pos_in_file with the position they want to process next.
    Since the first block may start at position 0, we take
    cshare-&gt;read_end as an additional condition. This variable is
    initialized to NULL and will be set after a block of data is written
    to the buffer.

  RETURN
    1           OK, lock in place, go ahead and read.
    0           OK, unlocked, another thread did the read.
*/

static int lock_io_cache(IO_CACHE *cache, my_off_t pos)
{
  IO_CACHE_SHARE *cshare= cache-&gt;share;
  DBUG_ENTER("lock_io_cache");

  /* Enter the lock. */
  mysql_mutex_lock(&amp;cshare-&gt;mutex);
  cshare-&gt;running_threads--;
  DBUG_PRINT("io_cache_share", ("%s: 0x%lx  pos: %lu  running: %u",
                                (cache == cshare-&gt;source_cache) ?
                                "writer" : "reader", (long) cache, (ulong) pos,
                                cshare-&gt;running_threads));

  if (cshare-&gt;source_cache)
  {
    /* A write cache is synchronized to the read caches. */

    if (cache == cshare-&gt;source_cache)
    {
      /* The writer waits until all readers are here. */
      while (cshare-&gt;running_threads)
      {
        DBUG_PRINT("io_cache_share", ("writer waits in lock"));
        mysql_cond_wait(&amp;cshare-&gt;cond_writer, &amp;cshare-&gt;mutex);
      }
      DBUG_PRINT("io_cache_share", ("writer awoke, going to copy"));

      /* Stay locked. Leave the lock later by unlock_io_cache(). */
      DBUG_RETURN(1);
    }

    /* The last thread wakes the writer. */
    if (!cshare-&gt;running_threads)
    {
      DBUG_PRINT("io_cache_share", ("waking writer"));
      mysql_cond_signal(&amp;cshare-&gt;cond_writer);
    }

    /*
      Readers wait until the data is copied from the writer. Another
      reason to stop waiting is the removal of the write thread. If this
      happens, we leave the lock with old data in the buffer.
    */
    while ((!cshare-&gt;read_end || (cshare-&gt;pos_in_file &lt; pos)) &amp;&amp;
           cshare-&gt;source_cache)
    {
      DBUG_PRINT("io_cache_share", ("reader waits in lock"));
      mysql_cond_wait(&amp;cshare-&gt;cond, &amp;cshare-&gt;mutex);
    }

    /*
      If the writer was removed from the share while this thread was
      asleep, we need to simulate an EOF condition. The writer cannot
      reset the share variables as they might still be in use by readers
      of the last block. When we awake here then because the last
      joining thread signalled us. If the writer is not the last, it
      will not signal. So it is safe to clear the buffer here.
    */
    if (!cshare-&gt;read_end || (cshare-&gt;pos_in_file &lt; pos))
    {
      DBUG_PRINT("io_cache_share", ("reader found writer removed. EOF"));
      cshare-&gt;read_end= cshare-&gt;buffer; /* Empty buffer. */
      cshare-&gt;error= 0; /* EOF is not an error. */
    }
  }
  else
  {
    /*
      There are read caches only. The last thread arriving in
      lock_io_cache() continues with a locked cache and reads the block.
    */
    if (!cshare-&gt;running_threads)
    {
      DBUG_PRINT("io_cache_share", ("last thread joined, going to read"));
      /* Stay locked. Leave the lock later by unlock_io_cache(). */
      DBUG_RETURN(1);
    }

    /*
      All other threads wait until the requested block is read by the
      last thread arriving. Another reason to stop waiting is the
      removal of a thread. If this leads to all threads being in the
      lock, we have to continue also. The first of the awaken threads
      will then do the read.
    */
    while ((!cshare-&gt;read_end || (cshare-&gt;pos_in_file &lt; pos)) &amp;&amp;
           cshare-&gt;running_threads)
    {
      DBUG_PRINT("io_cache_share", ("reader waits in lock"));
      mysql_cond_wait(&amp;cshare-&gt;cond, &amp;cshare-&gt;mutex);
    }

    /* If the block is not yet read, continue with a locked cache and read. */
    if (!cshare-&gt;read_end || (cshare-&gt;pos_in_file &lt; pos))
    {
      DBUG_PRINT("io_cache_share", ("reader awoke, going to read"));
      /* Stay locked. Leave the lock later by unlock_io_cache(). */
      DBUG_RETURN(1);
    }

    /* Another thread did read the block already. */
  }
  DBUG_PRINT("io_cache_share", ("reader awoke, going to process %u bytes",
                                (uint) (cshare-&gt;read_end ? (size_t)
                                        (cshare-&gt;read_end - cshare-&gt;buffer) :
                                        0)));

  /*
    Leave the lock. Do not call unlock_io_cache() later. The thread that
    filled the buffer did this and marked all threads as running.
  */
  mysql_mutex_unlock(&amp;cshare-&gt;mutex);
  DBUG_RETURN(0);
}


/*
  Unlock IO cache.

  SYNOPSIS
    unlock_io_cache()
      cache                     The cache of the thread leaving the lock.

  NOTE
    This is called by the thread that filled the buffer. It marks all
    threads as running and awakes them. This must not be done by any
    other thread.

    Do not signal cond_writer. Either there is no writer or the writer
    is the only one who can call this function.

    The reason for resetting running_threads to total_threads before
    waking all other threads is that it could be possible that this
    thread is so fast with processing the buffer that it enters the lock
    before even one other thread has left it. If every awoken thread
    would increase running_threads by one, this thread could think that
    he is again the last to join and would not wait for the other
    threads to process the data.

  RETURN
    void
*/

static void unlock_io_cache(IO_CACHE *cache)
{
  IO_CACHE_SHARE *cshare= cache-&gt;share;
  DBUG_ENTER("unlock_io_cache");
  DBUG_PRINT("io_cache_share", ("%s: 0x%lx  pos: %lu  running: %u",
                                (cache == cshare-&gt;source_cache) ?
                                "writer" : "reader",
                                (long) cache, (ulong) cshare-&gt;pos_in_file,
                                cshare-&gt;total_threads));

  cshare-&gt;running_threads= cshare-&gt;total_threads;
  mysql_cond_broadcast(&amp;cshare-&gt;cond);
  mysql_mutex_unlock(&amp;cshare-&gt;mutex);
  DBUG_VOID_RETURN;
}


/*
  Read from IO_CACHE when it is shared between several threads.

  SYNOPSIS
    _my_b_read_r()
      cache                     IO_CACHE pointer
      Buffer                    Buffer to retrieve count bytes from file
      Count                     Number of bytes to read into Buffer

  NOTE
    This function is only called from the my_b_read() macro when there
    isn't enough characters in the buffer to satisfy the request.

  IMPLEMENTATION

    It works as follows: when a thread tries to read from a file (that
    is, after using all the data from the (shared) buffer), it just
    hangs on lock_io_cache(), waiting for other threads. When the very
    last thread attempts a read, lock_io_cache() returns 1, the thread
    does actual IO and unlock_io_cache(), which signals all the waiting
    threads that data is in the buffer.

  WARNING

    When changing this function, be careful with handling file offsets
    (end-of_file, pos_in_file). Do not cast them to possibly smaller
    types than my_off_t unless you can be sure that their value fits.
    Same applies to differences of file offsets. (Bug #11527)

    When changing this function, check _my_b_read(). It might need the
    same change.

  RETURN
    0      we succeeded in reading all data
    1      Error: can't read requested characters
*/

int _my_b_read_r(register IO_CACHE *cache, uchar *Buffer, size_t Count)
{
  my_off_t pos_in_file;
  size_t length, diff_length, left_length;
  IO_CACHE_SHARE *cshare= cache-&gt;share;
  DBUG_ENTER("_my_b_read_r");

  if ((left_length= (size_t) (cache-&gt;read_end - cache-&gt;read_pos)))
  {
    DBUG_ASSERT(Count &gt;= left_length);	/* User is not using my_b_read() */
    memcpy(Buffer, cache-&gt;read_pos, left_length);
    Buffer+= left_length;
    Count-= left_length;
  }
  while (Count)
  {
    size_t cnt, len;

    pos_in_file= cache-&gt;pos_in_file + (cache-&gt;read_end - cache-&gt;buffer);
    diff_length= (size_t) (pos_in_file &amp; (IO_SIZE-1));
    length=IO_ROUND_UP(Count+diff_length)-diff_length;
    length= ((length &lt;= cache-&gt;read_length) ?
             length + IO_ROUND_DN(cache-&gt;read_length - length) :
             length - IO_ROUND_UP(length - cache-&gt;read_length));
    if (cache-&gt;type != READ_FIFO &amp;&amp;
	(length &gt; (cache-&gt;end_of_file - pos_in_file)))
      length= (size_t) (cache-&gt;end_of_file - pos_in_file);
    if (length == 0)
    {
      cache-&gt;error= (int) left_length;
      DBUG_RETURN(1);
    }
    if (lock_io_cache(cache, pos_in_file))
    {
      /* With a synchronized write/read cache we won't come here... */
      DBUG_ASSERT(!cshare-&gt;source_cache);
      /*
        ... unless the writer has gone before this thread entered the
        lock. Simulate EOF in this case. It can be distinguished by
        cache-&gt;file.
      */
      if (cache-&gt;file &lt; 0)
        len= 0;
      else
      {
        /*
          Whenever a function which operates on IO_CACHE flushes/writes
          some part of the IO_CACHE to disk it will set the property
          "seek_not_done" to indicate this to other functions operating
          on the IO_CACHE.
        */
        if (cache-&gt;seek_not_done)
        {
          if (mysql_file_seek(cache-&gt;file, pos_in_file, MY_SEEK_SET, MYF(0))
              == MY_FILEPOS_ERROR)
          {
            cache-&gt;error= -1;
            unlock_io_cache(cache);
            DBUG_RETURN(1);
          }
        }
        len= mysql_file_read(cache-&gt;file, cache-&gt;buffer, length, cache-&gt;myflags);
      }
      DBUG_PRINT("io_cache_share", ("read %lu bytes", (ulong) len));

      cache-&gt;read_end=    cache-&gt;buffer + (len == (size_t) -1 ? 0 : len);
      cache-&gt;error=       (len == length ? 0 : (int) len);
      cache-&gt;pos_in_file= pos_in_file;

      /* Copy important values to the share. */
      cshare-&gt;error=       cache-&gt;error;
      cshare-&gt;read_end=    cache-&gt;read_end;
      cshare-&gt;pos_in_file= pos_in_file;

      /* Mark all threads as running and wake them. */
      unlock_io_cache(cache);
    }
    else
    {
      /*
        With a synchronized write/read cache readers always come here.
        Copy important values from the share.
      */
      cache-&gt;error=       cshare-&gt;error;
      cache-&gt;read_end=    cshare-&gt;read_end;
      cache-&gt;pos_in_file= cshare-&gt;pos_in_file;

      len= ((cache-&gt;error == -1) ? (size_t) -1 :
            (size_t) (cache-&gt;read_end - cache-&gt;buffer));
    }
    cache-&gt;read_pos=      cache-&gt;buffer;
    cache-&gt;seek_not_done= 0;
    if (len == 0 || len == (size_t) -1)
    {
      DBUG_PRINT("io_cache_share", ("reader error. len %lu  left %lu",
                                    (ulong) len, (ulong) left_length));
      cache-&gt;error= (int) left_length;
      DBUG_RETURN(1);
    }
    cnt= (len &gt; Count) ? Count : len;
    memcpy(Buffer, cache-&gt;read_pos, cnt);
    Count -= cnt;
    Buffer+= cnt;
    left_length+= cnt;
    cache-&gt;read_pos+= cnt;
  }
  DBUG_RETURN(0);
}


/*
  Copy data from write cache to read cache.

  SYNOPSIS
    copy_to_read_buffer()
      write_cache               The write cache.
      write_buffer              The source of data, mostly the cache buffer.
      write_length              The number of bytes to copy.

  NOTE
    The write thread will wait for all read threads to join the cache
    lock. Then it copies the data over and wakes the read threads.

  RETURN
    void
*/

static void copy_to_read_buffer(IO_CACHE *write_cache,
                                const uchar *write_buffer, size_t write_length)
{
  IO_CACHE_SHARE *cshare= write_cache-&gt;share;

  DBUG_ASSERT(cshare-&gt;source_cache == write_cache);
  /*
    write_length is usually less or equal to buffer_length.
    It can be bigger if _my_b_write() is called with a big length.
  */
  while (write_length)
  {
    size_t copy_length= MY_MIN(write_length, write_cache-&gt;buffer_length);
    int  MY_ATTRIBUTE((unused)) rc;

    rc= lock_io_cache(write_cache, write_cache-&gt;pos_in_file);
    /* The writing thread does always have the lock when it awakes. */
    DBUG_ASSERT(rc);

    memcpy(cshare-&gt;buffer, write_buffer, copy_length);

    cshare-&gt;error=       0;
    cshare-&gt;read_end=    cshare-&gt;buffer + copy_length;
    cshare-&gt;pos_in_file= write_cache-&gt;pos_in_file;

    /* Mark all threads as running and wake them. */
    unlock_io_cache(write_cache);

    write_buffer+= copy_length;
    write_length-= copy_length;
  }
}


/*
  Do sequential read from the SEQ_READ_APPEND cache.
  
  We do this in three stages:
   - first read from info-&gt;buffer
   - then if there are still data to read, try the file descriptor
   - afterwards, if there are still data to read, try append buffer

  RETURNS
    0  Success
    1  Failed to read
*/

int _my_b_seq_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
{
  size_t length, diff_length, left_length, save_count, max_length;
  my_off_t pos_in_file;
  save_count=Count;

  /* first, read the regular buffer */
  if ((left_length=(size_t) (info-&gt;read_end-info-&gt;read_pos)))
  {
    DBUG_ASSERT(Count &gt; left_length);	/* User is not using my_b_read() */
    memcpy(Buffer,info-&gt;read_pos, left_length);
    Buffer+=left_length;
    Count-=left_length;
  }
  lock_append_buffer(info);

  /* pos_in_file always point on where info-&gt;buffer was read */
  if ((pos_in_file=info-&gt;pos_in_file +
       (size_t) (info-&gt;read_end - info-&gt;buffer)) &gt;= info-&gt;end_of_file)
    goto read_append_buffer;

  /*
    With read-append cache we must always do a seek before we read,
    because the write could have moved the file pointer astray
  */
  if (mysql_file_seek(info-&gt;file, pos_in_file, MY_SEEK_SET, MYF(0)) == MY_FILEPOS_ERROR)
  {
   info-&gt;error= -1;
   unlock_append_buffer(info);
   return (1);
  }
  info-&gt;seek_not_done=0;

  diff_length= (size_t) (pos_in_file &amp; (IO_SIZE-1));

  /* now the second stage begins - read from file descriptor */
  if (Count &gt;= (size_t) (IO_SIZE+(IO_SIZE-diff_length)))
  {
    /* Fill first intern buffer */
    size_t read_length;

    length=(Count &amp; (size_t) ~(IO_SIZE-1))-diff_length;
    if ((read_length= mysql_file_read(info-&gt;file,Buffer, length,
                                      info-&gt;myflags)) == (size_t) -1)
    {
      info-&gt;error= -1;
      unlock_append_buffer(info);
      return 1;
    }
    Count-=read_length;
    Buffer+=read_length;
    pos_in_file+=read_length;

    if (read_length != length)
    {
      /*
	We only got part of data;  Read the rest of the data from the
	write buffer
      */
      goto read_append_buffer;
    }
<span style = "background-color:#fdd">    left_length+=length;        Dead increment:Value stored to 'left_length' is never read</span>
    diff_length=0;
  }

  max_length= info-&gt;read_length-diff_length;
  if (max_length &gt; (info-&gt;end_of_file - pos_in_file))
    max_length= (size_t) (info-&gt;end_of_file - pos_in_file);
  if (!max_length)
  {
    if (Count)
      goto read_append_buffer;
    length=0;				/* Didn't read any more chars */
  }
  else
  {
    length= mysql_file_read(info-&gt;file,info-&gt;buffer, max_length, info-&gt;myflags);
    if (length == (size_t) -1)
    {
      info-&gt;error= -1;
      unlock_append_buffer(info);
      return 1;
    }
    if (length &lt; Count)
    {
      memcpy(Buffer, info-&gt;buffer, length);
      Count -= length;
      Buffer += length;

      /*
	 added the line below to make
	 DBUG_ASSERT(pos_in_file==info-&gt;end_of_file) pass.
	 otherwise this does not appear to be needed
      */
      pos_in_file += length;
      goto read_append_buffer;
    }
  }
  unlock_append_buffer(info);
  info-&gt;read_pos=info-&gt;buffer+Count;
  info-&gt;read_end=info-&gt;buffer+length;
  info-&gt;pos_in_file=pos_in_file;
  memcpy(Buffer,info-&gt;buffer,(size_t) Count);
  return 0;

read_append_buffer:

  /*
     Read data from the current write buffer.
     Count should never be == 0 here (The code will work even if count is 0)
  */

  {
    /* First copy the data to Count */
    size_t len_in_buff = (size_t) (info-&gt;write_pos - info-&gt;append_read_pos);
    size_t copy_len;
    size_t transfer_len;

    DBUG_ASSERT(info-&gt;append_read_pos &lt;= info-&gt;write_pos);
    /*
      TODO: figure out if the assert below is needed or correct.
    */
    DBUG_ASSERT(pos_in_file == info-&gt;end_of_file);
    copy_len= MY_MIN(Count, len_in_buff);
    memcpy(Buffer, info-&gt;append_read_pos, copy_len);
    info-&gt;append_read_pos += copy_len;
    Count -= copy_len;
    if (Count)
      info-&gt;error = save_count - Count;

    /* Fill read buffer with data from write buffer */
    memcpy(info-&gt;buffer, info-&gt;append_read_pos,
	   (size_t) (transfer_len=len_in_buff - copy_len));
    info-&gt;read_pos= info-&gt;buffer;
    info-&gt;read_end= info-&gt;buffer+transfer_len;
    info-&gt;append_read_pos=info-&gt;write_pos;
    info-&gt;pos_in_file=pos_in_file+copy_len;
    info-&gt;end_of_file+=len_in_buff;
  }
  unlock_append_buffer(info);
  return Count ? 1 : 0;
}


#ifdef HAVE_AIOWAIT

/*
  Read from the IO_CACHE into a buffer and feed asynchronously
  from disk when needed.

  SYNOPSIS
    _my_b_async_read()
      info                      IO_CACHE pointer
      Buffer                    Buffer to retrieve count bytes from file
      Count                     Number of bytes to read into Buffer

  RETURN VALUE
    -1          An error has occurred; my_errno is set.
     0          Success
     1          An error has occurred; IO_CACHE to error state.
*/

int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
{
  size_t length,read_length,diff_length,left_length,use_length,org_Count;
  size_t max_length;
  my_off_t next_pos_in_file;
  uchar *read_buffer;

  memcpy(Buffer,info-&gt;read_pos,
	 (left_length= (size_t) (info-&gt;read_end-info-&gt;read_pos)));
  Buffer+=left_length;
  org_Count=Count;
  Count-=left_length;

  if (info-&gt;inited)
  {						/* wait for read block */
    info-&gt;inited=0;				/* No more block to read */
    my_aiowait(&amp;info-&gt;aio_result);		/* Wait for outstanding req */
    if (info-&gt;aio_result.result.aio_errno)
    {
      if (info-&gt;myflags &amp; MY_WME)
      {
        char errbuf[MYSYS_STRERROR_SIZE];
        my_error(EE_READ, MYF(ME_BELL+ME_WAITTANG),
                 my_filename(info-&gt;file),
                 info-&gt;aio_result.result.aio_errno,
                 my_strerror(errbuf, sizeof(errbuf),
                             info-&gt;aio_result.result.aio_errno));
      my_errno=info-&gt;aio_result.result.aio_errno;
      info-&gt;error= -1;
      return(1);
    }
    if (! (read_length= (size_t) info-&gt;aio_result.result.aio_return) ||
	read_length == (size_t) -1)
    {
      my_errno=0;				/* For testing */
      info-&gt;error= (read_length == (size_t) -1 ? -1 :
		    (int) (read_length+left_length));
      return(1);
    }
    info-&gt;pos_in_file+= (size_t) (info-&gt;read_end - info-&gt;request_pos);

    if (info-&gt;request_pos != info-&gt;buffer)
      info-&gt;request_pos=info-&gt;buffer;
    else
      info-&gt;request_pos=info-&gt;buffer+info-&gt;read_length;
    info-&gt;read_pos=info-&gt;request_pos;
    next_pos_in_file=info-&gt;aio_read_pos+read_length;

	/* Check if pos_in_file is changed
	   (_ni_read_cache may have skipped some bytes) */

    if (info-&gt;aio_read_pos &lt; info-&gt;pos_in_file)
    {						/* Fix if skipped bytes */
      if (info-&gt;aio_read_pos + read_length &lt; info-&gt;pos_in_file)
      {
	read_length=0;				/* Skip block */
	next_pos_in_file=info-&gt;pos_in_file;
      }
      else
      {
	my_off_t offset= (info-&gt;pos_in_file - info-&gt;aio_read_pos);
	info-&gt;pos_in_file=info-&gt;aio_read_pos; /* Whe are here */
	info-&gt;read_pos=info-&gt;request_pos+offset;
	read_length-=offset;			/* Bytes left from read_pos */
      }
    }
#ifndef DBUG_OFF
    if (info-&gt;aio_read_pos &gt; info-&gt;pos_in_file)
    {
      my_errno=EINVAL;
      return(info-&gt;read_length= (size_t) -1);
    }
#endif
	/* Copy found bytes to buffer */
    length= MY_MIN(Count, read_length);
    memcpy(Buffer,info-&gt;read_pos,(size_t) length);
    Buffer+=length;
    Count-=length;
    left_length+=length;
    info-&gt;read_end=info-&gt;rc_pos+read_length;
    info-&gt;read_pos+=length;
  }
  else
    next_pos_in_file=(info-&gt;pos_in_file+ (size_t)
		      (info-&gt;read_end - info-&gt;request_pos));

	/* If reading large blocks, or first read or read with skip */
  if (Count)
  {
    if (next_pos_in_file == info-&gt;end_of_file)
    {
      info-&gt;error=(int) (read_length+left_length);
      return 1;
    }
    
    if (mysql_file_seek(info-&gt;file, next_pos_in_file, MY_SEEK_SET, MYF(0))
        == MY_FILEPOS_ERROR)
    {
      info-&gt;error= -1;
      return (1);
    }

    read_length=IO_SIZE*2- (size_t) (next_pos_in_file &amp; (IO_SIZE-1));
    if (Count &lt; read_length)
    {					/* Small block, read to cache */
      if ((read_length=mysql_file_read(info-&gt;file,info-&gt;request_pos,
			               read_length, info-&gt;myflags)) == (size_t) -1)
        return info-&gt;error= -1;
      use_length= MY_MIN(Count, read_length);
      memcpy(Buffer,info-&gt;request_pos,(size_t) use_length);
      info-&gt;read_pos=info-&gt;request_pos+Count;
      info-&gt;read_end=info-&gt;request_pos+read_length;
      info-&gt;pos_in_file=next_pos_in_file;	/* Start of block in cache */
      next_pos_in_file+=read_length;

      if (Count != use_length)
      {					/* Didn't find hole block */
        if (info-&gt;myflags &amp; (MY_WME | MY_FAE | MY_FNABP) &amp;&amp; Count != org_Count)
        {
          char errbuf[MYSYS_STRERROR_SIZE];
          my_error(EE_EOFERR, MYF(ME_BELL+ME_WAITTANG), my_filename(info-&gt;file),
                   my_errno, my_strerror(errbuf, sizeof(errbuf), my_errno));
        }
        info-&gt;error=(int) (read_length+left_length);
        return 1;
      }
    }
    else
    {						/* Big block, don't cache it */
      if ((read_length= mysql_file_read(info-&gt;file, Buffer, Count,info-&gt;myflags))
	  != Count)
      {
	info-&gt;error= read_length == (size_t) -1 ? -1 : read_length+left_length;
	return 1;
      }
      info-&gt;read_pos=info-&gt;read_end=info-&gt;request_pos;
      info-&gt;pos_in_file=(next_pos_in_file+=Count);
    }
  }

  /* Read next block with asyncronic io */
  diff_length=(next_pos_in_file &amp; (IO_SIZE-1));
  max_length= info-&gt;read_length - diff_length;
  if (max_length &gt; info-&gt;end_of_file - next_pos_in_file)
    max_length= (size_t) (info-&gt;end_of_file - next_pos_in_file);

  if (info-&gt;request_pos != info-&gt;buffer)
    read_buffer=info-&gt;buffer;
  else
    read_buffer=info-&gt;buffer+info-&gt;read_length;
  info-&gt;aio_read_pos=next_pos_in_file;
  if (max_length)
  {
    info-&gt;aio_result.result.aio_errno=AIO_INPROGRESS;	/* Marker for test */
    DBUG_PRINT("aioread",("filepos: %ld  length: %lu",
			  (ulong) next_pos_in_file, (ulong) max_length));
    if (aioread(info-&gt;file,read_buffer, max_length,
		(my_off_t) next_pos_in_file,MY_SEEK_SET,
		&amp;info-&gt;aio_result.result))
    {						/* Skip async io */
      my_errno=errno;
      DBUG_PRINT("error",("got error: %d, aio_result: %d from aioread, async skipped",
			  errno, info-&gt;aio_result.result.aio_errno));
      if (info-&gt;request_pos != info-&gt;buffer)
      {
	bmove(info-&gt;buffer,info-&gt;request_pos,
	      (size_t) (info-&gt;read_end - info-&gt;read_pos));
	info-&gt;request_pos=info-&gt;buffer;
	info-&gt;read_pos-=info-&gt;read_length;
	info-&gt;read_end-=info-&gt;read_length;
      }
      info-&gt;read_length=info-&gt;buffer_length;	/* Use hole buffer */
      info-&gt;read_function=_my_b_read;		/* Use normal IO_READ next */
    }
    else
      info-&gt;inited=info-&gt;aio_result.pending=1;
  }
  return 0;					/* Block read, async in use */
} /* _my_b_async_read */
#endif


/* Read one byte when buffer is empty */

int _my_b_get(IO_CACHE *info)
{
  uchar buff;
  IO_CACHE_CALLBACK pre_read,post_read;
  if ((pre_read = info-&gt;pre_read))
    (*pre_read)(info);
  if ((*(info)-&gt;read_function)(info,&amp;buff,1))
    return my_b_EOF;
  if ((post_read = info-&gt;post_read))
    (*post_read)(info);
  return (int) (uchar) buff;
}

/* 
   Write a byte buffer to IO_CACHE and flush to disk
   if IO_CACHE is full.

   RETURN VALUE
    1 On error on write
    0 On success
   -1 On error; my_errno contains error code.
*/

int _my_b_write(register IO_CACHE *info, const uchar *Buffer, size_t Count)
{
  size_t rest_length,length;
  my_off_t pos_in_file= info-&gt;pos_in_file;

  DBUG_EXECUTE_IF("simulate_huge_load_data_file",
                  {
                    pos_in_file=(my_off_t)(5000000000ULL);
                  });
  if (pos_in_file+info-&gt;buffer_length &gt; info-&gt;end_of_file)
  {
    my_errno=errno=EFBIG;
    return info-&gt;error = -1;
  }

  rest_length= (size_t) (info-&gt;write_end - info-&gt;write_pos);
  memcpy(info-&gt;write_pos,Buffer,(size_t) rest_length);
  Buffer+=rest_length;
  Count-=rest_length;
  info-&gt;write_pos+=rest_length;

  if (my_b_flush_io_cache(info,1))
    return 1;
  if (Count &gt;= IO_SIZE)
  {					/* Fill first intern buffer */
    length=Count &amp; (size_t) ~(IO_SIZE-1);
    if (info-&gt;seek_not_done)
    {
      /*
        Whenever a function which operates on IO_CACHE flushes/writes
        some part of the IO_CACHE to disk it will set the property
        "seek_not_done" to indicate this to other functions operating
        on the IO_CACHE.
      */
      if (mysql_file_seek(info-&gt;file, info-&gt;pos_in_file, MY_SEEK_SET, MYF(0)))
      {
        info-&gt;error= -1;
        return (1);
      }
      info-&gt;seek_not_done=0;
    }
    if (mysql_file_write(info-&gt;file, Buffer, length, info-&gt;myflags | MY_NABP))
      return info-&gt;error= -1;

    /*
      In case of a shared I/O cache with a writer we normally do direct
      write cache to read cache copy. Simulate this here by direct
      caller buffer to read cache copy. Do it after the write so that
      the cache readers actions on the flushed part can go in parallel
      with the write of the extra stuff. copy_to_read_buffer()
      synchronizes writer and readers so that after this call the
      readers can act on the extra stuff while the writer can go ahead
      and prepare the next output. copy_to_read_buffer() relies on
      info-&gt;pos_in_file.
    */
    if (info-&gt;share)
      copy_to_read_buffer(info, Buffer, length);

    Count-=length;
    Buffer+=length;
    info-&gt;pos_in_file+=length;
  }
  memcpy(info-&gt;write_pos,Buffer,(size_t) Count);
  info-&gt;write_pos+=Count;
  return 0;
}


/*
  Append a block to the write buffer.
  This is done with the buffer locked to ensure that we don't read from
  the write buffer before we are ready with it.
*/

int my_b_append(register IO_CACHE *info, const uchar *Buffer, size_t Count)
{
  size_t rest_length,length;

  /*
    Assert that we cannot come here with a shared cache. If we do one
    day, we might need to add a call to copy_to_read_buffer().
  */
  DBUG_ASSERT(!info-&gt;share);

  lock_append_buffer(info);
  rest_length= (size_t) (info-&gt;write_end - info-&gt;write_pos);
  if (Count &lt;= rest_length)
    goto end;
  memcpy(info-&gt;write_pos, Buffer, rest_length);
  Buffer+=rest_length;
  Count-=rest_length;
  info-&gt;write_pos+=rest_length;
  if (my_b_flush_io_cache(info,0))
  {
    unlock_append_buffer(info);
    return 1;
  }
  if (Count &gt;= IO_SIZE)
  {					/* Fill first intern buffer */
    length=Count &amp; (size_t) ~(IO_SIZE-1);
    if (mysql_file_write(info-&gt;file,Buffer, length, info-&gt;myflags | MY_NABP))
    {
      unlock_append_buffer(info);
      return info-&gt;error= -1;
    }
    Count-=length;
    Buffer+=length;
    info-&gt;end_of_file+=length;
  }

end:
  memcpy(info-&gt;write_pos,Buffer,(size_t) Count);
  info-&gt;write_pos+=Count;
  unlock_append_buffer(info);
  return 0;
}


int my_b_safe_write(IO_CACHE *info, const uchar *Buffer, size_t Count)
{
  /*
    Sasha: We are not writing this with the ? operator to avoid hitting
    a possible compiler bug. At least gcc 2.95 cannot deal with 
    several layers of ternary operators that evaluated comma(,) operator
    expressions inside - I do have a test case if somebody wants it
  */
  if (info-&gt;type == SEQ_READ_APPEND)
    return my_b_append(info, Buffer, Count);
  return my_b_write(info, Buffer, Count);
}


/*
  Write a block to disk where part of the data may be inside the record
  buffer.  As all write calls to the data goes through the cache,
  we will never get a seek over the end of the buffer
*/

int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,
		   my_off_t pos)
{
  size_t length;
  int error=0;

  /*
    Assert that we cannot come here with a shared cache. If we do one
    day, we might need to add a call to copy_to_read_buffer().
  */
  DBUG_ASSERT(!info-&gt;share);

  if (pos &lt; info-&gt;pos_in_file)
  {
    /* Of no overlap, write everything without buffering */
    if (pos + Count &lt;= info-&gt;pos_in_file)
      return mysql_file_pwrite(info-&gt;file, Buffer, Count, pos,
		               info-&gt;myflags | MY_NABP);
    /* Write the part of the block that is before buffer */
    length= (uint) (info-&gt;pos_in_file - pos);
    if (mysql_file_pwrite(info-&gt;file, Buffer, length, pos, info-&gt;myflags | MY_NABP))
      info-&gt;error= error= -1;
    Buffer+=length;
    pos+=  length;
    Count-= length;
#ifndef HAVE_PREAD
    info-&gt;seek_not_done=1;
#endif
  }

  /* Check if we want to write inside the used part of the buffer.*/
  length= (size_t) (info-&gt;write_end - info-&gt;buffer);
  if (pos &lt; info-&gt;pos_in_file + length)
  {
    size_t offset= (size_t) (pos - info-&gt;pos_in_file);
    length-=offset;
    if (length &gt; Count)
      length=Count;
    memcpy(info-&gt;buffer+offset, Buffer, length);
    Buffer+=length;
    Count-= length;
    /* Fix length of buffer if the new data was larger */
    if (info-&gt;buffer+length &gt; info-&gt;write_pos)
      info-&gt;write_pos=info-&gt;buffer+length;
    if (!Count)
      return (error);
  }
  /* Write at the end of the current buffer; This is the normal case */
  if (_my_b_write(info, Buffer, Count))
    error= -1;
  return error;
}


	/* Flush write cache */

#define LOCK_APPEND_BUFFER if (need_append_buffer_lock) \
  lock_append_buffer(info);
#define UNLOCK_APPEND_BUFFER if (need_append_buffer_lock) \
  unlock_append_buffer(info);

int my_b_flush_io_cache(IO_CACHE *info,
                        int need_append_buffer_lock MY_ATTRIBUTE((unused)))
{
  size_t length;
  my_off_t pos_in_file;
  my_bool append_cache= (info-&gt;type == SEQ_READ_APPEND);
  DBUG_ENTER("my_b_flush_io_cache");
  DBUG_PRINT("enter", ("cache: 0x%lx", (long) info));

  DBUG_EXECUTE_IF("simulate_error_during_flush_cache_to_file",
                  {
                    DBUG_RETURN(TRUE);
                  });
  if (!append_cache)
    need_append_buffer_lock= 0;

  if (info-&gt;type == WRITE_CACHE || append_cache)
  {
    if (info-&gt;file == -1)
    {
      if (real_open_cached_file(info))
	DBUG_RETURN((info-&gt;error= -1));
    }
    LOCK_APPEND_BUFFER;

    if ((length=(size_t) (info-&gt;write_pos - info-&gt;write_buffer)))
    {
      /*
        In case of a shared I/O cache with a writer we do direct write
        cache to read cache copy. Do it before the write here so that
        the readers can work in parallel with the write.
        copy_to_read_buffer() relies on info-&gt;pos_in_file.
      */
      if (info-&gt;share)
        copy_to_read_buffer(info, info-&gt;write_buffer, length);

      pos_in_file=info-&gt;pos_in_file;
      /*
	If we have append cache, we always open the file with
	O_APPEND which moves the pos to EOF automatically on every write
      */
      if (!append_cache &amp;&amp; info-&gt;seek_not_done)
      {					/* File touched, do seek */
	if (mysql_file_seek(info-&gt;file, pos_in_file, MY_SEEK_SET, MYF(0)) ==
	    MY_FILEPOS_ERROR)
	{
	  UNLOCK_APPEND_BUFFER;
	  DBUG_RETURN((info-&gt;error= -1));
	}
	if (!append_cache)
	  info-&gt;seek_not_done=0;
      }
      if (!append_cache)
	info-&gt;pos_in_file+=length;
      info-&gt;write_end= (info-&gt;write_buffer+info-&gt;buffer_length-
			((pos_in_file+length) &amp; (IO_SIZE-1)));

      if (mysql_file_write(info-&gt;file,info-&gt;write_buffer,length,
		   info-&gt;myflags | MY_NABP))
	info-&gt;error= -1;
      else
	info-&gt;error= 0;
      if (!append_cache)
      {
        set_if_bigger(info-&gt;end_of_file,(pos_in_file+length));
      }
      else
      {
	info-&gt;end_of_file+=(info-&gt;write_pos-info-&gt;append_read_pos);
	DBUG_ASSERT(info-&gt;end_of_file == mysql_file_tell(info-&gt;file, MYF(0)));
      }

      info-&gt;append_read_pos=info-&gt;write_pos=info-&gt;write_buffer;
      ++info-&gt;disk_writes;
      UNLOCK_APPEND_BUFFER;
      DBUG_RETURN(info-&gt;error);
    }
  }
#ifdef HAVE_AIOWAIT
  else if (info-&gt;type != READ_NET)
  {
    my_aiowait(&amp;info-&gt;aio_result);		/* Wait for outstanding req */
    info-&gt;inited=0;
  }
#endif
  UNLOCK_APPEND_BUFFER;
  DBUG_RETURN(0);
}

/*
  Free an IO_CACHE object

  SYNOPSOS
    end_io_cache()
    info		IO_CACHE Handle to free

  NOTES
    It's currently safe to call this if one has called init_io_cache()
    on the 'info' object, even if init_io_cache() failed.
    This function is also safe to call twice with the same handle.

  RETURN
   0  ok
   #  Error
*/

int end_io_cache(IO_CACHE *info)
{
  int error=0;
  IO_CACHE_CALLBACK pre_close;
  DBUG_ENTER("end_io_cache");
  DBUG_PRINT("enter",("cache: 0x%lx", (ulong) info));

  /*
    Every thread must call remove_io_thread(). The last one destroys
    the share elements.
  */
  DBUG_ASSERT(!info-&gt;share || !info-&gt;share-&gt;total_threads);

  if ((pre_close=info-&gt;pre_close))
  {
    (*pre_close)(info);
    info-&gt;pre_close= 0;
  }
  if (info-&gt;alloced_buffer)
  {
    info-&gt;alloced_buffer=0;
    if (info-&gt;file != -1)			/* File doesn't exist */
      error= my_b_flush_io_cache(info,1);
    my_free(info-&gt;buffer);
    info-&gt;buffer=info-&gt;read_pos=(uchar*) 0;
  }
  if (info-&gt;type == SEQ_READ_APPEND)
  {
    /* Destroy allocated mutex */
    info-&gt;type= TYPE_NOT_SET;
    mysql_mutex_destroy(&amp;info-&gt;append_buffer_lock);
  }
  DBUG_RETURN(error);
} /* end_io_cache */


/**********************************************************************
 Testing of MF_IOCACHE
**********************************************************************/

#ifdef MAIN

#include &lt;my_dir.h&gt;

void die(const char* fmt, ...)
{
  va_list va_args;
  va_start(va_args,fmt);
  fprintf(stderr,"Error:");
  vfprintf(stderr, fmt,va_args);
  fprintf(stderr,", errno=%d\n", errno);
  exit(1);
}

int open_file(const char* fname, IO_CACHE* info, int cache_size)
{
  int fd;
  if ((fd=my_open(fname,O_CREAT | O_RDWR,MYF(MY_WME))) &lt; 0)
    die("Could not open %s", fname);
  if (init_io_cache(info, fd, cache_size, SEQ_READ_APPEND, 0,0,MYF(MY_WME)))
    die("failed in init_io_cache()");
  return fd;
}

void close_file(IO_CACHE* info)
{
  end_io_cache(info);
  my_close(info-&gt;file, MYF(MY_WME));
}

int main(int argc, char** argv)
{
  IO_CACHE sra_cache; /* SEQ_READ_APPEND */
  MY_STAT status;
  const char* fname="/tmp/iocache.test";
  int cache_size=16384;
  char llstr_buf[22];
  int max_block,total_bytes=0;
  int i,num_loops=100,error=0;
  char *p;
  char* block, *block_end;
  MY_INIT(argv[0]);
  max_block = cache_size*3;
  if (!(block=(char*)my_malloc(max_block,MYF(MY_WME))))
    die("Not enough memory to allocate test block");
  block_end = block + max_block;
  for (p = block,i=0; p &lt; block_end;i++)
  {
    *p++ = (char)i;
  }
  if (my_stat(fname,&amp;status, MYF(0)) &amp;&amp;
      my_delete(fname,MYF(MY_WME)))
    {
      die("Delete of %s failed, aborting", fname);
    }
  open_file(fname,&amp;sra_cache, cache_size);
  for (i = 0; i &lt; num_loops; i++)
  {
    char buf[4];
    int block_size = abs(rand() % max_block);
    int4store(buf, block_size);
    if (my_b_append(&amp;sra_cache,buf,4) ||
	my_b_append(&amp;sra_cache, block, block_size))
      die("write failed");
    total_bytes += 4+block_size;
  }
  close_file(&amp;sra_cache);
  my_free(block);
  if (!my_stat(fname,&amp;status,MYF(MY_WME)))
    die("%s failed to stat, but I had just closed it,\
 wonder how that happened");
  printf("Final size of %s is %s, wrote %d bytes\n",fname,
	 llstr(status.st_size,llstr_buf),
	 total_bytes);
  my_delete(fname, MYF(MY_WME));
  /* check correctness of tests */
  if (total_bytes != status.st_size)
  {
    fprintf(stderr,"Not the same number of bytes acutally  in file as bytes \
supposedly written\n");
    error=1;
  }
  exit(error);
  return 0;
}
#endif
      </pre>
    </body>
</html>
