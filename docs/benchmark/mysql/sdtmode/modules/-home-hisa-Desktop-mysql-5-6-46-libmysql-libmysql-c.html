<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8"/>
        <title>/home/hisa/Desktop/mysql-5.6.46/libmysql/libmysql.c</title>
        <link rel="stylesheet" type="text/css" href="../css/prettyprint.css"/>
        <script type="text/javascript" src="../js/prettyprint.js"></script>
    </head>
    <body onload="prettyPrint()">
		<pre class="prettyprint lang-cpp linenums">
/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   Without limiting anything contained in the foregoing, this file,
   which is part of C Driver for MySQL (Connector/C), is also subject to the
   Universal FOSS Exception, version 1.0, a copy of which can be found at
   http://oss.oracle.com/licenses/universal-foss-exception.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */

#include &lt;my_global.h&gt;
#include &lt;my_sys.h&gt;
#include &lt;my_time.h&gt;
#include &lt;mysys_err.h&gt;
#include &lt;m_string.h&gt;
#include &lt;m_ctype.h&gt;
#include "mysql.h"
#include "mysql_version.h"
#include "mysqld_error.h"
#include "errmsg.h"
#include &lt;violite.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#ifdef	 HAVE_PWD_H
#include &lt;pwd.h&gt;
#endif
#if !defined(__WIN__)
#ifdef HAVE_SELECT_H
#include &lt;select.h&gt;
#endif
#ifdef HAVE_SYS_SELECT_H
#include &lt;sys/select.h&gt;
#endif
#endif /* !defined(__WIN__) */
#ifdef HAVE_POLL
#include &lt;sys/poll.h&gt;
#endif
#ifdef HAVE_SYS_UN_H
#include &lt;sys/un.h&gt;
#endif
#if !defined(__WIN__)
#include &lt;my_pthread.h&gt;				/* because of signal()	*/
#endif
#ifndef INADDR_NONE
#define INADDR_NONE	-1
#endif

#include &lt;sql_common.h&gt;
#include "client_settings.h"

#undef net_buffer_length
#undef max_allowed_packet

ulong 		net_buffer_length=8192;
ulong		max_allowed_packet= 1024L*1024L*1024L;


#ifdef EMBEDDED_LIBRARY
#undef net_flush
my_bool	net_flush(NET *net);
#endif

#if defined(__WIN__)
/* socket_errno is defined in my_global.h for all platforms */
#define perror(A)
#else
#include &lt;errno.h&gt;
#define SOCKET_ERROR -1
#endif /* __WIN__ */

/*
  If allowed through some configuration, then this needs to
  be changed
*/
#define MAX_LONG_DATA_LENGTH 8192
#define unsigned_field(A) ((A)-&gt;flags &amp; UNSIGNED_FLAG)

static void append_wild(char *to,char *end,const char *wild);
sig_handler my_pipe_sig_handler(int sig);

static my_bool mysql_client_init= 0;
static my_bool org_my_init_done= 0;

typedef struct st_mysql_stmt_extension
{
  MEM_ROOT fields_mem_root;
} MYSQL_STMT_EXT;


/*
  Initialize the MySQL client library

  SYNOPSIS
    mysql_server_init()

  NOTES
    Should be called before doing any other calls to the MySQL
    client library to initialize thread specific variables etc.
    It's called by mysql_init() to ensure that things will work for
    old not threaded applications that doesn't call mysql_server_init()
    directly.

  RETURN
    0  ok
    1  could not initialize environment (out of memory or thread keys)
*/

int STDCALL mysql_server_init(int argc MY_ATTRIBUTE((unused)),
			      char **argv MY_ATTRIBUTE((unused)),
			      char **groups MY_ATTRIBUTE((unused)))
{
  int result= 0;
  if (!mysql_client_init)
  {
    mysql_client_init=1;
    org_my_init_done=my_init_done;
    if (my_init())				/* Will init threads */
      return 1;
    init_client_errs();
    if (mysql_client_plugin_init())
      return 1;
    if (!mysql_port)
    {
      char *env;
      struct servent *serv_ptr MY_ATTRIBUTE((unused));

      mysql_port = MYSQL_PORT;

      /*
        if builder specifically requested a default port, use that
        (even if it coincides with our factory default).
        only if they didn't do we check /etc/services (and, failing
        on that, fall back to the factory default of 3306).
        either default can be overridden by the environment variable
        MYSQL_TCP_PORT, which in turn can be overridden with command
        line options.
      */

#if MYSQL_PORT_DEFAULT == 0
      if ((serv_ptr= getservbyname("mysql", "tcp")))
        mysql_port= (uint) ntohs((ushort) serv_ptr-&gt;s_port);
#endif
      if ((env= getenv("MYSQL_TCP_PORT")))
        mysql_port=(uint) atoi(env);
    }

    if (!mysql_unix_port)
    {
      char *env;
#ifdef __WIN__
      mysql_unix_port = (char*) MYSQL_NAMEDPIPE;
#else
      mysql_unix_port = (char*) MYSQL_UNIX_ADDR;
#endif
      if ((env = getenv("MYSQL_UNIX_PORT")))
	mysql_unix_port = env;
    }
    mysql_debug(NullS);
#if defined(SIGPIPE) &amp;&amp; !defined(__WIN__)
    (void) signal(SIGPIPE, SIG_IGN);
#endif
#ifdef EMBEDDED_LIBRARY
    if (argc &gt; -1)
       result= init_embedded_server(argc, argv, groups);
#endif
  }
  else
    result= (int)my_thread_init();         /* Init if new thread */
  return result;
}


/*
  Free all memory and resources used by the client library

  NOTES
    When calling this there should not be any other threads using
    the library.

    To make things simpler when used with windows dll's (which calls this
    function automaticly), it's safe to call this function multiple times.
*/


void STDCALL mysql_server_end()
{
  if (!mysql_client_init)
    return;

  mysql_client_plugin_deinit();

#ifdef EMBEDDED_LIBRARY
  end_embedded_server();
#endif
  finish_client_errs();
  vio_end();

  /* If library called my_init(), free memory allocated by it */
  if (!org_my_init_done)
  {
    my_end(0);
  }
  else
  {
    free_charsets();
    mysql_thread_end();
  }

  mysql_client_init= org_my_init_done= 0;
}

static MYSQL_PARAMETERS mysql_internal_parameters=
{&amp;max_allowed_packet, &amp;net_buffer_length, 0};

MYSQL_PARAMETERS *STDCALL mysql_get_parameters(void)
{
  return &amp;mysql_internal_parameters;
}

my_bool STDCALL mysql_thread_init()
{
  return my_thread_init();
}

void STDCALL mysql_thread_end()
{
  my_thread_end();
}


/*
  Expand wildcard to a sql string
*/

static void
append_wild(char *to, char *end, const char *wild)
{
  end-=5;					/* Some extra */
  if (wild &amp;&amp; wild[0])
  {
    to=strmov(to," like '");
    while (*wild &amp;&amp; to &lt; end)
    {
      if (*wild == '\\' || *wild == '\'')
	*to++='\\';
      *to++= *wild++;
    }
    if (*wild)					/* Too small buffer */
      *to++='%';				/* Nicer this way */
    to[0]='\'';
    to[1]=0;
  }
}


/**************************************************************************
  Init debugging if MYSQL_DEBUG environment variable is found
**************************************************************************/

void STDCALL
mysql_debug(const char *debug MY_ATTRIBUTE((unused)))
{
#ifndef DBUG_OFF
  char	*env;
  if (debug)
  {
    DBUG_PUSH(debug);
  }
  else if ((env = getenv("MYSQL_DEBUG")))
  {
    DBUG_PUSH(env);
#if !defined(_WINVER) &amp;&amp; !defined(WINVER)
    puts("\n-------------------------------------------------------");
    puts("MYSQL_DEBUG found. libmysql started with the following:");
    puts(env);
    puts("-------------------------------------------------------\n");
#else
    {
      char buff[80];
      buff[sizeof(buff)-1]= 0;
      strxnmov(buff,sizeof(buff)-1,"libmysql: ", env, NullS);
      MessageBox((HWND) 0,"Debugging variable MYSQL_DEBUG used",buff,MB_OK);
    }
#endif
  }
#endif
}


/**************************************************************************
  Ignore SIGPIPE handler
   ARGSUSED
**************************************************************************/

sig_handler
my_pipe_sig_handler(int sig MY_ATTRIBUTE((unused)))
{
  DBUG_PRINT("info",("Hit by signal %d",sig));
#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY
  (void) signal(SIGPIPE, my_pipe_sig_handler);
#endif
}


/**************************************************************************
  Connect to sql server
  If host == 0 then use localhost
**************************************************************************/

#ifdef USE_OLD_FUNCTIONS
MYSQL * STDCALL
mysql_connect(MYSQL *mysql,const char *host,
	      const char *user, const char *passwd)
{
  MYSQL *res;
  mysql=mysql_init(mysql);			/* Make it thread safe */
  {
    DBUG_ENTER("mysql_connect");
    if (!(res=mysql_real_connect(mysql,host,user,passwd,NullS,0,NullS,0)))
    {
      if (mysql-&gt;free_me)
	my_free(mysql);
    }
    mysql-&gt;reconnect= 1;
    DBUG_RETURN(res);
  }
}
#endif


/**************************************************************************
  Change user and database
**************************************************************************/

my_bool	STDCALL mysql_change_user(MYSQL *mysql, const char *user,
				  const char *passwd, const char *db)
{
  int rc;
  CHARSET_INFO *saved_cs= mysql-&gt;charset;
  char *saved_user= mysql-&gt;user;
  char *saved_passwd= mysql-&gt;passwd;
  char *saved_db= mysql-&gt;db;

  DBUG_ENTER("mysql_change_user");

  /* Get the connection-default character set. */

  if (mysql_init_character_set(mysql))
  {
    mysql-&gt;charset= saved_cs;
    DBUG_RETURN(TRUE);
  }

  /*
    Use an empty string instead of NULL.
    Alloc user and password on heap because mysql_reconnect()
    calls mysql_close() on success.
  */
  mysql-&gt;user= my_strdup(user ? user : "", MYF(MY_WME));
  mysql-&gt;passwd= my_strdup(passwd ? passwd : "", MYF(MY_WME));
  mysql-&gt;db= 0;

  rc= run_plugin_auth(mysql, 0, 0, 0, db);

  /*
    The server will close all statements no matter was the attempt
    to change user successful or not.
  */
  mysql_detach_stmt_list(&amp;mysql-&gt;stmts, "mysql_change_user");
  if (rc == 0)
  {
    /* Free old connect information */
    my_free(saved_user);
    my_free(saved_passwd);
    my_free(saved_db);

    /* alloc new connect information */
    mysql-&gt;db= db ? my_strdup(db, MYF(MY_WME)) : 0;
  }
  else
  {
    /* Free temporary connect information */
    my_free(mysql-&gt;user);
    my_free(mysql-&gt;passwd);
    my_free(mysql-&gt;db);

    /* Restore saved state */
    mysql-&gt;charset= saved_cs;
    mysql-&gt;user= saved_user;
    mysql-&gt;passwd= saved_passwd;
    mysql-&gt;db= saved_db;
  }

  DBUG_RETURN(rc);
}

#if defined(HAVE_GETPWUID) &amp;&amp; defined(NO_GETPWUID_DECL)
struct passwd *getpwuid(uid_t);
char* getlogin(void);
#endif

#if !defined(__WIN__)

void read_user_name(char *name)
{
  DBUG_ENTER("read_user_name");
  if (geteuid() == 0)
    (void) strmov(name,"root");		/* allow use of surun */
  else
  {
#ifdef HAVE_GETPWUID
    struct passwd *skr;
    const char *str;
    if ((str=getlogin()) == NULL)
    {
      if ((skr=getpwuid(geteuid())) != NULL)
	str=skr-&gt;pw_name;
      else if (!(str=getenv("USER")) &amp;&amp; !(str=getenv("LOGNAME")) &amp;&amp;
	       !(str=getenv("LOGIN")))
	str="UNKNOWN_USER";
    }
    (void) strmake(name,str,USERNAME_LENGTH);
#elif HAVE_CUSERID
    (void) cuserid(name);
#else
    strmov(name,"UNKNOWN_USER");
#endif
  }
  DBUG_VOID_RETURN;
}

#else /* If Windows */

void read_user_name(char *name)
{
  char *str=getenv("USER");		/* ODBC will send user variable */
  strmake(name,str ? str : "ODBC", USERNAME_LENGTH);
}

#endif

my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
{
  my_bool result= 1;
  uint packet_length=MY_ALIGN(mysql-&gt;net.max_packet-16,IO_SIZE);
  NET *net= &amp;mysql-&gt;net;
  int readcount;
  void *li_ptr;          /* pass state to local_infile functions */
  char *buf;		/* buffer to be filled by local_infile_read */
  struct st_mysql_options *options= &amp;mysql-&gt;options;
  DBUG_ENTER("handle_local_infile");

  /* check that we've got valid callback functions */
  if (!(options-&gt;local_infile_init &amp;&amp;
	options-&gt;local_infile_read &amp;&amp;
	options-&gt;local_infile_end &amp;&amp;
	options-&gt;local_infile_error))
  {
    /* if any of the functions is invalid, set the default */
    mysql_set_local_infile_default(mysql);
  }

  /* copy filename into local memory and allocate read buffer */
  if (!(buf=my_malloc(packet_length, MYF(0))))
  {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    DBUG_RETURN(1);
  }

  /* initialize local infile (open file, usually) */
  if ((*options-&gt;local_infile_init)(&amp;li_ptr, net_filename,
    options-&gt;local_infile_userdata))
  {
    (void) my_net_write(net,(const uchar*) "",0); /* Server needs one packet */
    net_flush(net);
    strmov(net-&gt;sqlstate, unknown_sqlstate);
    net-&gt;last_errno=
      (*options-&gt;local_infile_error)(li_ptr,
                                     net-&gt;last_error,
                                     sizeof(net-&gt;last_error)-1);
    goto err;
  }

  /* read blocks of data from local infile callback */
  while ((readcount =
	  (*options-&gt;local_infile_read)(li_ptr, buf,
					packet_length)) &gt; 0)
  {
    if (my_net_write(net, (uchar*) buf, readcount))
    {
      DBUG_PRINT("error",
		 ("Lost connection to MySQL server during LOAD DATA of local file"));
      set_mysql_error(mysql, CR_SERVER_LOST, unknown_sqlstate);
      goto err;
    }
  }

  /* Send empty packet to mark end of file */
  if (my_net_write(net, (const uchar*) "", 0) || net_flush(net))
  {
    set_mysql_error(mysql, CR_SERVER_LOST, unknown_sqlstate);
    goto err;
  }

  if (readcount &lt; 0)
  {
    net-&gt;last_errno=
      (*options-&gt;local_infile_error)(li_ptr,
                                     net-&gt;last_error,
                                     sizeof(net-&gt;last_error)-1);
    goto err;
  }

  result=0;					/* Ok */

err:
  /* free up memory allocated with _init, usually */
  (*options-&gt;local_infile_end)(li_ptr);
  my_free(buf);
  DBUG_RETURN(result);
}


/****************************************************************************
  Default handlers for LOAD LOCAL INFILE
****************************************************************************/

typedef struct st_default_local_infile
{
  int fd;
  int error_num;
  const char *filename;
  char error_msg[LOCAL_INFILE_ERROR_LEN];
} default_local_infile_data;


/*
  Open file for LOAD LOCAL INFILE

  SYNOPSIS
    default_local_infile_init()
    ptr			Store pointer to internal data here
    filename		File name to open. This may be in unix format !


  NOTES
    Even if this function returns an error, the load data interface
    guarantees that default_local_infile_end() is called.

  RETURN
    0	ok
    1	error
*/

static int default_local_infile_init(void **ptr, const char *filename,
             void *userdata MY_ATTRIBUTE ((unused)))
{
  default_local_infile_data *data;
  char tmp_name[FN_REFLEN];

  if (!(*ptr= data= ((default_local_infile_data *)
		     my_malloc(sizeof(default_local_infile_data),  MYF(0)))))
    return 1; /* out of memory */

  data-&gt;error_msg[0]= 0;
  data-&gt;error_num=    0;
  data-&gt;filename= filename;

  fn_format(tmp_name, filename, "", "", MY_UNPACK_FILENAME);
  if ((data-&gt;fd = my_open(tmp_name, O_RDONLY, MYF(0))) &lt; 0)
  {
    char errbuf[MYSYS_STRERROR_SIZE];
    data-&gt;error_num= my_errno;
    my_snprintf(data-&gt;error_msg, sizeof(data-&gt;error_msg)-1,
                EE(EE_FILENOTFOUND), tmp_name, data-&gt;error_num,
                my_strerror(errbuf, sizeof(errbuf), data-&gt;error_num));
    return 1;
  }
  return 0; /* ok */
}


/*
  Read data for LOAD LOCAL INFILE

  SYNOPSIS
    default_local_infile_read()
    ptr			Points to handle allocated by _init
    buf			Read data here
    buf_len		Ammount of data to read

  RETURN
    &gt; 0		number of bytes read
    == 0	End of data
    &lt; 0		Error
*/

static int default_local_infile_read(void *ptr, char *buf, uint buf_len)
{
  int count;
  default_local_infile_data*data = (default_local_infile_data *) ptr;

  if ((count= (int) my_read(data-&gt;fd, (uchar *) buf, buf_len, MYF(0))) &lt; 0)
  {
    char errbuf[MYSYS_STRERROR_SIZE];
    data-&gt;error_num= EE_READ; /* the errmsg for not entire file read */
    my_snprintf(data-&gt;error_msg, sizeof(data-&gt;error_msg)-1,
                EE(EE_READ), data-&gt;filename,
                my_errno, my_strerror(errbuf, sizeof(errbuf), my_errno));
  }
  return count;
}


/*
  Read data for LOAD LOCAL INFILE

  SYNOPSIS
    default_local_infile_end()
    ptr			Points to handle allocated by _init
			May be NULL if _init failed!

  RETURN
*/

static void default_local_infile_end(void *ptr)
{
  default_local_infile_data *data= (default_local_infile_data *) ptr;
  if (data)					/* If not error on open */
  {
    if (data-&gt;fd &gt;= 0)
      my_close(data-&gt;fd, MYF(MY_WME));
    my_free(ptr);
  }
}


/*
  Return error from LOAD LOCAL INFILE

  SYNOPSIS
    default_local_infile_end()
    ptr			Points to handle allocated by _init
			May be NULL if _init failed!
    error_msg		Store error text here
    error_msg_len	Max lenght of error_msg

  RETURN
    error message number
*/

static int
default_local_infile_error(void *ptr, char *error_msg, uint error_msg_len)
{
  default_local_infile_data *data = (default_local_infile_data *) ptr;
  if (data)					/* If not error on open */
  {
    strmake(error_msg, data-&gt;error_msg, error_msg_len);
    return data-&gt;error_num;
  }
  /* This can only happen if we got error on malloc of handle */
  strmov(error_msg, ER(CR_OUT_OF_MEMORY));
  return CR_OUT_OF_MEMORY;
}


void
mysql_set_local_infile_handler(MYSQL *mysql,
                               int (*local_infile_init)(void **, const char *,
                               void *),
                               int (*local_infile_read)(void *, char *, uint),
                               void (*local_infile_end)(void *),
                               int (*local_infile_error)(void *, char *, uint),
                               void *userdata)
{
  mysql-&gt;options.local_infile_init=  local_infile_init;
  mysql-&gt;options.local_infile_read=  local_infile_read;
  mysql-&gt;options.local_infile_end=   local_infile_end;
  mysql-&gt;options.local_infile_error= local_infile_error;
  mysql-&gt;options.local_infile_userdata = userdata;
}


void mysql_set_local_infile_default(MYSQL *mysql)
{
  mysql-&gt;options.local_infile_init=  default_local_infile_init;
  mysql-&gt;options.local_infile_read=  default_local_infile_read;
  mysql-&gt;options.local_infile_end=   default_local_infile_end;
  mysql-&gt;options.local_infile_error= default_local_infile_error;
}


/**************************************************************************
  Do a query. If query returned rows, free old rows.
  Read data by mysql_store_result or by repeat call of mysql_fetch_row
**************************************************************************/

int STDCALL
mysql_query(MYSQL *mysql, const char *query)
{
  return mysql_real_query(mysql,query, (uint) strlen(query));
}


/**************************************************************************
  Return next field of the query results
**************************************************************************/

MYSQL_FIELD * STDCALL
mysql_fetch_field(MYSQL_RES *result)
{
  if (result-&gt;current_field &gt;= result-&gt;field_count)
    return(NULL);
  return &amp;result-&gt;fields[result-&gt;current_field++];
}


/**************************************************************************
  Move to a specific row and column
**************************************************************************/

void STDCALL
mysql_data_seek(MYSQL_RES *result, my_ulonglong row)
{
  MYSQL_ROWS	*tmp=0;
  DBUG_PRINT("info",("mysql_data_seek(%ld)",(long) row));
  if (result-&gt;data)
    for (tmp=result-&gt;data-&gt;data; row-- &amp;&amp; tmp ; tmp = tmp-&gt;next) ;
  result-&gt;current_row=0;
  result-&gt;data_cursor = tmp;
}


/*************************************************************************
  put the row or field cursor one a position one got from mysql_row_tell()
  This doesn't restore any data. The next mysql_fetch_row or
  mysql_fetch_field will return the next row or field after the last used
*************************************************************************/

MYSQL_ROW_OFFSET STDCALL
mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET row)
{
  MYSQL_ROW_OFFSET return_value=result-&gt;data_cursor;
  result-&gt;current_row= 0;
  result-&gt;data_cursor= row;
  return return_value;
}


MYSQL_FIELD_OFFSET STDCALL
mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)
{
  MYSQL_FIELD_OFFSET return_value=result-&gt;current_field;
  result-&gt;current_field=field_offset;
  return return_value;
}


/*****************************************************************************
  List all databases
*****************************************************************************/

MYSQL_RES * STDCALL
mysql_list_dbs(MYSQL *mysql, const char *wild)
{
  char buff[255];
  DBUG_ENTER("mysql_list_dbs");

  append_wild(strmov(buff,"show databases"),buff+sizeof(buff),wild);
  if (mysql_query(mysql,buff))
    DBUG_RETURN(0);
  DBUG_RETURN (mysql_store_result(mysql));
}


/*****************************************************************************
  List all tables in a database
  If wild is given then only the tables matching wild is returned
*****************************************************************************/

MYSQL_RES * STDCALL
mysql_list_tables(MYSQL *mysql, const char *wild)
{
  char buff[255];
  DBUG_ENTER("mysql_list_tables");

  append_wild(strmov(buff,"show tables"),buff+sizeof(buff),wild);
  if (mysql_query(mysql,buff))
    DBUG_RETURN(0);
  DBUG_RETURN (mysql_store_result(mysql));
}


MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
{
  MYSQL_DATA *query;
  if (!(query= cli_read_rows(mysql,(MYSQL_FIELD*) 0, 
			     protocol_41(mysql) ? 8 : 6)))
    return NULL;

  mysql-&gt;field_count= (uint) query-&gt;rows;
  return unpack_fields(mysql, query,&amp;mysql-&gt;field_alloc,
		       mysql-&gt;field_count, 1, mysql-&gt;server_capabilities);
}


/**************************************************************************
  List all fields in a table
  If wild is given then only the fields matching wild is returned
  Instead of this use query:
  show fields in 'table' like "wild"
**************************************************************************/

MYSQL_RES * STDCALL
mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)
{
  MYSQL_RES   *result;
  MYSQL_FIELD *fields;
  char	     buff[258],*end;
  DBUG_ENTER("mysql_list_fields");
  DBUG_PRINT("enter",("table: '%s'  wild: '%s'",table,wild ? wild : ""));

  end=strmake(strmake(buff, table,128)+1,wild ? wild : "",128);
  free_old_query(mysql);
  if (simple_command(mysql, COM_FIELD_LIST, (uchar*) buff,
                     (ulong) (end-buff), 1) ||
      !(fields= (*mysql-&gt;methods-&gt;list_fields)(mysql)))
    DBUG_RETURN(NULL);

  if (!(result = (MYSQL_RES *) my_malloc(sizeof(MYSQL_RES),
					 MYF(MY_WME | MY_ZEROFILL))))
    DBUG_RETURN(NULL);

  result-&gt;methods= mysql-&gt;methods;
  result-&gt;field_alloc=mysql-&gt;field_alloc;
  mysql-&gt;fields=0;
  result-&gt;field_count = mysql-&gt;field_count;
  result-&gt;fields= fields;
  result-&gt;eof=1;
  DBUG_RETURN(result);
}

/* List all running processes (threads) in server */

MYSQL_RES * STDCALL
mysql_list_processes(MYSQL *mysql)
{
  MYSQL_DATA *fields;
  uint field_count;
  uchar *pos;
  DBUG_ENTER("mysql_list_processes");

  LINT_INIT(fields);
  if (simple_command(mysql,COM_PROCESS_INFO,0,0,0))
    DBUG_RETURN(0);
  free_old_query(mysql);
  pos=(uchar*) mysql-&gt;net.read_pos;
  field_count=(uint) net_field_length(&amp;pos);
  if (!(fields = (*mysql-&gt;methods-&gt;read_rows)(mysql,(MYSQL_FIELD*) 0,
					      protocol_41(mysql) ? 7 : 5)))
    DBUG_RETURN(NULL);
  if (!(mysql-&gt;fields=unpack_fields(mysql, fields,&amp;mysql-&gt;field_alloc,field_count,0,
				    mysql-&gt;server_capabilities)))
    DBUG_RETURN(0);
  mysql-&gt;status=MYSQL_STATUS_GET_RESULT;
  mysql-&gt;field_count=field_count;
  DBUG_RETURN(mysql_store_result(mysql));
}


#ifdef USE_OLD_FUNCTIONS
int  STDCALL
mysql_create_db(MYSQL *mysql, const char *db)
{
  DBUG_ENTER("mysql_createdb");
  DBUG_PRINT("enter",("db: %s",db));
  DBUG_RETURN(simple_command(mysql,COM_CREATE_DB,db, (ulong) strlen(db),0));
}


int  STDCALL
mysql_drop_db(MYSQL *mysql, const char *db)
{
  DBUG_ENTER("mysql_drop_db");
  DBUG_PRINT("enter",("db: %s",db));
  DBUG_RETURN(simple_command(mysql,COM_DROP_DB,db,(ulong) strlen(db),0));
}
#endif


int STDCALL
mysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)
{
  uchar level[1];
  DBUG_ENTER("mysql_shutdown");
  level[0]= (uchar) shutdown_level;
  DBUG_RETURN(simple_command(mysql, COM_SHUTDOWN, level, 1, 0));
}


int STDCALL
mysql_refresh(MYSQL *mysql,uint options)
{
  uchar bits[1];
  DBUG_ENTER("mysql_refresh");
  bits[0]= (uchar) options;
  DBUG_RETURN(simple_command(mysql, COM_REFRESH, bits, 1, 0));
}


int STDCALL
mysql_kill(MYSQL *mysql,ulong pid)
{
  uchar buff[4];
  DBUG_ENTER("mysql_kill");
  /*
    Sanity check: if ulong is 64-bits, user can submit a PID here that
    overflows our 32-bit parameter to the somewhat obsolete COM_PROCESS_KILL.
    If this is the case, we'll flag an error here.
    The SQL statement KILL CONNECTION is the safer option here.
    There is an analog of this failsafe in the server as we might see old
    libmysql connection to a new server as well as the other way around.
  */
  if (pid &amp; (~0xfffffffful))
    DBUG_RETURN(CR_INVALID_CONN_HANDLE);
  int4store(buff,pid);
  DBUG_RETURN(simple_command(mysql,COM_PROCESS_KILL,buff,sizeof(buff),0));
}


int STDCALL
mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)
{
  uchar buff[2];
  DBUG_ENTER("mysql_set_server_option");
  int2store(buff, (uint) option);
  DBUG_RETURN(simple_command(mysql, COM_SET_OPTION, buff, sizeof(buff), 0));
}


int STDCALL
mysql_dump_debug_info(MYSQL *mysql)
{
  DBUG_ENTER("mysql_dump_debug_info");
  DBUG_RETURN(simple_command(mysql,COM_DEBUG,0,0,0));
}


const char *cli_read_statistics(MYSQL *mysql)
{
  mysql-&gt;net.read_pos[mysql-&gt;packet_length]=0;	/* End of stat string */
  if (!mysql-&gt;net.read_pos[0])
  {
    set_mysql_error(mysql, CR_WRONG_HOST_INFO, unknown_sqlstate);
    return mysql-&gt;net.last_error;
  }
  return (char*) mysql-&gt;net.read_pos;
}


const char * STDCALL
mysql_stat(MYSQL *mysql)
{
  DBUG_ENTER("mysql_stat");
  if (simple_command(mysql,COM_STATISTICS,0,0,0))
    DBUG_RETURN(mysql-&gt;net.last_error);
  DBUG_RETURN((*mysql-&gt;methods-&gt;read_statistics)(mysql));
}


int STDCALL
mysql_ping(MYSQL *mysql)
{
  int res;
  DBUG_ENTER("mysql_ping");
  res= simple_command(mysql,COM_PING,0,0,0);
  if (res == CR_SERVER_LOST &amp;&amp; mysql-&gt;reconnect)
    res= simple_command(mysql,COM_PING,0,0,0);
  DBUG_RETURN(res);
}


const char * STDCALL
mysql_get_server_info(MYSQL *mysql)
{
  return((char*) mysql-&gt;server_version);
}


const char * STDCALL
mysql_get_host_info(MYSQL *mysql)
{
  return(mysql-&gt;host_info);
}


uint STDCALL
mysql_get_proto_info(MYSQL *mysql)
{
  return (mysql-&gt;protocol_version);
}

const char * STDCALL
mysql_get_client_info(void)
{
  return (char*) MYSQL_SERVER_VERSION;
}

ulong STDCALL mysql_get_client_version(void)
{
  return MYSQL_VERSION_ID;
}

my_bool STDCALL mysql_eof(MYSQL_RES *res)
{
  return res-&gt;eof;
}

MYSQL_FIELD * STDCALL mysql_fetch_field_direct(MYSQL_RES *res,uint fieldnr)
{
  return &amp;(res)-&gt;fields[fieldnr];
}

MYSQL_FIELD * STDCALL mysql_fetch_fields(MYSQL_RES *res)
{
  return (res)-&gt;fields;
}

MYSQL_ROW_OFFSET STDCALL mysql_row_tell(MYSQL_RES *res)
{
  return res-&gt;data_cursor;
}

MYSQL_FIELD_OFFSET STDCALL mysql_field_tell(MYSQL_RES *res)
{
  return (res)-&gt;current_field;
}

/* MYSQL */

unsigned int STDCALL mysql_field_count(MYSQL *mysql)
{
  return mysql-&gt;field_count;
}

my_ulonglong STDCALL mysql_affected_rows(MYSQL *mysql)
{
  return mysql-&gt;affected_rows;
}

my_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)
{
  return mysql-&gt;insert_id;
}

const char *STDCALL mysql_sqlstate(MYSQL *mysql)
{
  return mysql ? mysql-&gt;net.sqlstate : cant_connect_sqlstate;
}

uint STDCALL mysql_warning_count(MYSQL *mysql)
{
  return mysql-&gt;warning_count;
}

const char *STDCALL mysql_info(MYSQL *mysql)
{
  return mysql-&gt;info;
}

ulong STDCALL mysql_thread_id(MYSQL *mysql)
{
  /*
    ulong may be 64-bit, but we currently only transmit 32-bit.
    mysql_thread_id() is usually used in conjunction with mysql_kill()
    which is similarly limited (and obsolete).
    SELECTION CONNECTION_ID() / KILL CONNECTION avoid this issue.
  */
  return (mysql)-&gt;thread_id;
}

const char * STDCALL mysql_character_set_name(MYSQL *mysql)
{
  return mysql-&gt;charset-&gt;csname;
}

void STDCALL mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *csinfo)
{
  csinfo-&gt;number   = mysql-&gt;charset-&gt;number;
  csinfo-&gt;state    = mysql-&gt;charset-&gt;state;
  csinfo-&gt;csname   = mysql-&gt;charset-&gt;csname;
  csinfo-&gt;name     = mysql-&gt;charset-&gt;name;
  csinfo-&gt;comment  = mysql-&gt;charset-&gt;comment;
  csinfo-&gt;mbminlen = mysql-&gt;charset-&gt;mbminlen;
  csinfo-&gt;mbmaxlen = mysql-&gt;charset-&gt;mbmaxlen;

  if (mysql-&gt;options.charset_dir)
    csinfo-&gt;dir = mysql-&gt;options.charset_dir;
  else
    csinfo-&gt;dir = charsets_dir;
}

uint STDCALL mysql_thread_safe(void)
{
  return 1;
}


my_bool STDCALL mysql_embedded(void)
{
#ifdef EMBEDDED_LIBRARY
  return 1;
#else
  return 0;
#endif
}

/****************************************************************************
  Some support functions
****************************************************************************/

/*
  Functions called my my_net_init() to set some application specific variables
*/

void my_net_local_init(NET *net)
{
  net-&gt;max_packet=   (uint) net_buffer_length;
  my_net_set_read_timeout(net, CLIENT_NET_READ_TIMEOUT);
  my_net_set_write_timeout(net, CLIENT_NET_WRITE_TIMEOUT);
  net-&gt;retry_count=  1;
  net-&gt;max_packet_size= MY_MAX(net_buffer_length, max_allowed_packet);
}

/*
  This function is used to create HEX string that you
  can use in a SQL statement in of the either ways:
    INSERT INTO blob_column VALUES (0xAABBCC);  (any MySQL version)
    INSERT INTO blob_column VALUES (X'AABBCC'); (4.1 and higher)
  
  The string in "from" is encoded to a HEX string.
  The result is placed in "to" and a terminating null byte is appended.
  
  The string pointed to by "from" must be "length" bytes long.
  You must allocate the "to" buffer to be at least length*2+1 bytes long.
  Each character needs two bytes, and you need room for the terminating
  null byte. When mysql_hex_string() returns, the contents of "to" will
  be a null-terminated string. The return value is the length of the
  encoded string, not including the terminating null character.

  The return value does not contain any leading 0x or a leading X' and
  trailing '. The caller must supply whichever of those is desired.
*/

ulong STDCALL
mysql_hex_string(char *to, const char *from, ulong length)
{
  char *to0= to;
  const char *end;
            
  for (end= from + length; from &lt; end; from++)
  {
    *to++= _dig_vec_upper[((unsigned char) *from) &gt;&gt; 4];
    *to++= _dig_vec_upper[((unsigned char) *from) &amp; 0x0F];
  }
  *to= '\0';
  return (ulong) (to-to0);
}

/*
  Add escape characters to a string (blob?) to make it suitable for a insert
  to should at least have place for length*2+1 chars
  Returns the length of the to string
*/

ulong STDCALL
mysql_escape_string(char *to,const char *from,ulong length)
{
  return (uint) escape_string_for_mysql(default_charset_info, to, 0, from, length);
}

ulong STDCALL
mysql_real_escape_string(MYSQL *mysql, char *to,const char *from,
			 ulong length)
{
  if (mysql-&gt;server_status &amp; SERVER_STATUS_NO_BACKSLASH_ESCAPES)
    return (uint) escape_quotes_for_mysql(mysql-&gt;charset, to, 0, from, length);
  return (uint) escape_string_for_mysql(mysql-&gt;charset, to, 0, from, length);
}

void STDCALL
myodbc_remove_escape(MYSQL *mysql,char *name)
{
  char *to;
#ifdef USE_MB
  my_bool use_mb_flag=use_mb(mysql-&gt;charset);
  char *UNINIT_VAR(end);
  if (use_mb_flag)
    for (end=name; *end ; end++) ;
#endif

  for (to=name ; *name ; name++)
  {
#ifdef USE_MB
    int l;
    if (use_mb_flag &amp;&amp; (l = my_ismbchar( mysql-&gt;charset, name , end ) ) )
    {
      while (l--)
	*to++ = *name++;
      name--;
      continue;
    }
#endif
    if (*name == '\\' &amp;&amp; name[1])
      name++;
    *to++= *name;
  }
  *to=0;
}

/********************************************************************
 Implementation of new client API for 4.1 version.

 mysql_stmt_* are real prototypes used by applications.

 To make API work in embedded library all functions performing
 real I/O are prefixed with 'cli_' (abbreviated from 'Call Level
 Interface'). This functions are invoked via pointers set in
 MYSQL::methods structure. Embedded counterparts, prefixed with
 'emb_' reside in libmysqld/lib_sql.cc.
*********************************************************************/

/******************* Declarations ***********************************/

/* Default number of rows fetched per one COM_STMT_FETCH command. */

#define DEFAULT_PREFETCH_ROWS (ulong) 1

/*
  These functions are called by function pointer MYSQL_STMT::read_row_func.
  Each function corresponds to one of the read methods:
  - mysql_stmt_fetch without prior mysql_stmt_store_result,
  - mysql_stmt_fetch when result is stored,
  - mysql_stmt_fetch when there are no rows (always returns MYSQL_NO_DATA)
*/

static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row);
static int stmt_read_row_buffered(MYSQL_STMT *stmt, unsigned char **row);
static int stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row);
static int stmt_read_row_no_data(MYSQL_STMT *stmt, unsigned char **row);
static int stmt_read_row_no_result_set(MYSQL_STMT *stmt, unsigned char **row);

/*
  This function is used in mysql_stmt_store_result if
  STMT_ATTR_UPDATE_MAX_LENGTH attribute is set.
*/
static void stmt_update_metadata(MYSQL_STMT *stmt, MYSQL_ROWS *data);
static my_bool setup_one_fetch_function(MYSQL_BIND *, MYSQL_FIELD *field);

/* Auxilary function used to reset statement handle. */

#define RESET_SERVER_SIDE 1
#define RESET_LONG_DATA 2
#define RESET_STORE_RESULT 4
#define RESET_CLEAR_ERROR 8

static my_bool reset_stmt_handle(MYSQL_STMT *stmt, uint flags);

/*
  Maximum sizes of MYSQL_TYPE_DATE, MYSQL_TYPE_TIME, MYSQL_TYPE_DATETIME
  values stored in network buffer.
*/

/* 1 (length) + 2 (year) + 1 (month) + 1 (day) */
#define MAX_DATE_REP_LENGTH 5

/*
  1 (length) + 1 (is negative) + 4 (day count) + 1 (hour)
  + 1 (minute) + 1 (seconds) + 4 (microseconds)
*/
#define MAX_TIME_REP_LENGTH 13

/*
  1 (length) + 2 (year) + 1 (month) + 1 (day) +
  1 (hour) + 1 (minute) + 1 (second) + 4 (microseconds)
*/
#define MAX_DATETIME_REP_LENGTH 12

#define MAX_DOUBLE_STRING_REP_LENGTH 331

/* A macro to check truncation errors */

#define IS_TRUNCATED(value, is_unsigned, min, max, umax) \
        ((is_unsigned) ? (((value) &gt; (umax) || (value) &lt; 0) ? 1 : 0) : \
                         (((value) &gt; (max)  || (value) &lt; (min)) ? 1 : 0))

#define BIND_RESULT_DONE 1
/*
  We report truncations only if at least one of MYSQL_BIND::error
  pointers is set. In this case stmt-&gt;bind_result_done |-ed with
  this flag.
*/
#define REPORT_DATA_TRUNCATION 2

/**************** Misc utility functions ****************************/

/*
  Reallocate the NET package to have at least length bytes available.

  SYNPOSIS
    my_realloc_str()
    net                 The NET structure to modify.
    length              Ensure that net-&gt;buff has space for at least
                        this number of bytes.

  RETURN VALUES
    0   Success.
    1   Error, i.e. out of memory or requested packet size is bigger
        than max_allowed_packet. The error code is stored in net-&gt;last_errno.
*/

static my_bool my_realloc_str(NET *net, ulong length)
{
  ulong buf_length= (ulong) (net-&gt;write_pos - net-&gt;buff);
  my_bool res=0;
  DBUG_ENTER("my_realloc_str");
  if (buf_length + length &gt; net-&gt;max_packet)
  {
    res= net_realloc(net, buf_length + length);
    if (res)
    {
      if (net-&gt;last_errno == ER_OUT_OF_RESOURCES)
        net-&gt;last_errno= CR_OUT_OF_MEMORY;
      else if (net-&gt;last_errno == ER_NET_PACKET_TOO_LARGE)
        net-&gt;last_errno= CR_NET_PACKET_TOO_LARGE;
      strmov(net-&gt;sqlstate, unknown_sqlstate);
      strmov(net-&gt;last_error, ER(net-&gt;last_errno));
    }
    net-&gt;write_pos= net-&gt;buff+ buf_length;
  }
  DBUG_RETURN(res);
}


static void stmt_clear_error(MYSQL_STMT *stmt)
{
  if (stmt-&gt;last_errno)
  {
    stmt-&gt;last_errno= 0;
    stmt-&gt;last_error[0]= '\0';
    strmov(stmt-&gt;sqlstate, not_error_sqlstate);
  }
}

/**
  Set statement error code, sqlstate, and error message
  from given errcode and sqlstate.
*/

void set_stmt_error(MYSQL_STMT * stmt, int errcode,
                    const char *sqlstate, const char *err)
{
  DBUG_ENTER("set_stmt_error");
  DBUG_PRINT("enter", ("error: %d '%s'", errcode, ER(errcode)));
  DBUG_ASSERT(stmt != 0);

  if (err == 0)
    err= ER(errcode);

  stmt-&gt;last_errno= errcode;
  strmov(stmt-&gt;last_error, ER(errcode));
  strmov(stmt-&gt;sqlstate, sqlstate);

  DBUG_VOID_RETURN;
}


/**
  Set statement error code, sqlstate, and error message from NET.

  @param stmt  a statement handle. Copy the error here.
  @param net   mysql-&gt;net. Source of the error.
*/

void set_stmt_errmsg(MYSQL_STMT *stmt, NET *net)
{
  DBUG_ENTER("set_stmt_errmsg");
  DBUG_PRINT("enter", ("error: %d/%s '%s'",
                       net-&gt;last_errno,
                       net-&gt;sqlstate,
                       net-&gt;last_error));
  DBUG_ASSERT(stmt != 0);

  stmt-&gt;last_errno= net-&gt;last_errno;
  if (net-&gt;last_error &amp;&amp; net-&gt;last_error[0])
    strmov(stmt-&gt;last_error, net-&gt;last_error);
  strmov(stmt-&gt;sqlstate, net-&gt;sqlstate);

  DBUG_VOID_RETURN;
}

/*
  Read and unpack server reply to COM_STMT_PREPARE command (sent from
  mysql_stmt_prepare).

  SYNOPSIS
    cli_read_prepare_result()
    mysql   connection handle
    stmt    statement handle

  RETURN VALUES
    0	ok
    1	error
*/

my_bool cli_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
{
  uchar *pos;
  uint field_count, param_count;
  ulong packet_length;
  MYSQL_DATA *fields_data;
  DBUG_ENTER("cli_read_prepare_result");

  if ((packet_length= cli_safe_read(mysql)) == packet_error)
    DBUG_RETURN(1);
  mysql-&gt;warning_count= 0;

  pos= (uchar*) mysql-&gt;net.read_pos;
  stmt-&gt;stmt_id= uint4korr(pos+1); pos+= 5;
  /* Number of columns in result set */
  field_count=   uint2korr(pos);   pos+= 2;
  /* Number of placeholders in the statement */
  param_count=   uint2korr(pos);   pos+= 2;
  if (packet_length &gt;= 12)
    mysql-&gt;warning_count= uint2korr(pos+1);

  if (param_count != 0)
  {
    MYSQL_DATA *param_data;

    /* skip parameters data: we don't support it yet */
    if (!(param_data= (*mysql-&gt;methods-&gt;read_rows)(mysql, (MYSQL_FIELD*)0, 7)))
      DBUG_RETURN(1);
    free_rows(param_data);
  }

  if (field_count != 0)
  {
    if (!(mysql-&gt;server_status &amp; SERVER_STATUS_AUTOCOMMIT))
      mysql-&gt;server_status|= SERVER_STATUS_IN_TRANS;

    if (!(fields_data= (*mysql-&gt;methods-&gt;read_rows)(mysql,(MYSQL_FIELD*)0,7)))
      DBUG_RETURN(1);
    if (!(stmt-&gt;fields= unpack_fields(mysql, fields_data,&amp;stmt-&gt;mem_root,
				      field_count,0,
				      mysql-&gt;server_capabilities)))
      DBUG_RETURN(1);
  }
  stmt-&gt;field_count=  field_count;
  stmt-&gt;param_count=  (ulong) param_count;
  DBUG_PRINT("exit",("field_count: %u  param_count: %u  warning_count: %u",
                     field_count, param_count, (uint) mysql-&gt;warning_count));

  DBUG_RETURN(0);
}


/*
  Allocate memory and init prepared statement structure.

  SYNOPSIS
    mysql_stmt_init()
    mysql   connection handle

  DESCRIPTION
    This is an entry point of the new API. Returned handle stands for
    a server-side prepared statement. Memory for this structure (~700
    bytes) is allocated using 'malloc'. Once created, the handle can be
    reused many times. Created statement handle is bound to connection
    handle provided to this call: its lifetime is limited by lifetime
    of connection.
    'mysql_stmt_init()' is a pure local call, server side structure is
    created only in mysql_stmt_prepare.
    Next steps you may want to make:
    - set a statement attribute (mysql_stmt_attr_set()),
    - prepare statement handle with a query (mysql_stmt_prepare()),
    - close statement handle and free its memory (mysql_stmt_close()),
    - reset statement with mysql_stmt_reset() (a no-op which will
      just return).
    Behaviour of the rest of API calls on this statement is not defined yet
    (though we're working on making each wrong call sequence return
    error).

  RETURN VALUE
    statement structure upon success and NULL if out of
    memory
*/

MYSQL_STMT * STDCALL
mysql_stmt_init(MYSQL *mysql)
{
  MYSQL_STMT *stmt;
  DBUG_ENTER("mysql_stmt_init");

  if (!(stmt=
          (MYSQL_STMT *) my_malloc(sizeof (MYSQL_STMT),
                                   MYF(MY_WME | MY_ZEROFILL))) ||
      !(stmt-&gt;extension=
          (MYSQL_STMT_EXT *) my_malloc(sizeof (MYSQL_STMT_EXT),
                                       MYF(MY_WME | MY_ZEROFILL))))
  {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    my_free(stmt);
    DBUG_RETURN(NULL);
  }

  init_alloc_root(&amp;stmt-&gt;mem_root, 2048, 2048);
  init_alloc_root(&amp;stmt-&gt;result.alloc, 4096, 4096);
  stmt-&gt;result.alloc.min_malloc= sizeof(MYSQL_ROWS);
  mysql-&gt;stmts= list_add(mysql-&gt;stmts, &amp;stmt-&gt;list);
  stmt-&gt;list.data= stmt;
  stmt-&gt;state= MYSQL_STMT_INIT_DONE;
  stmt-&gt;mysql= mysql;
  stmt-&gt;read_row_func= stmt_read_row_no_result_set;
  stmt-&gt;prefetch_rows= DEFAULT_PREFETCH_ROWS;
  strmov(stmt-&gt;sqlstate, not_error_sqlstate);
  /* The rest of statement members was zeroed inside malloc */

  init_alloc_root(&amp;stmt-&gt;extension-&gt;fields_mem_root, 2048, 0);

  DBUG_RETURN(stmt);
}


/*
  Prepare server side statement with query.

  SYNOPSIS
    mysql_stmt_prepare()
    stmt    statement handle
    query   statement to prepare
    length  statement length

  DESCRIPTION
    Associate statement with statement handle. This is done both on
    client and server sides. At this point the server parses given query
    and creates an internal structure to represent it.
    Next steps you may want to make:
    - find out if this statement returns a result set by
      calling mysql_stmt_field_count(), and get result set metadata
      with mysql_stmt_result_metadata(),
    - if query contains placeholders, bind input parameters to placeholders
      using mysql_stmt_bind_param(),
    - otherwise proceed directly to mysql_stmt_execute().

  IMPLEMENTATION NOTES
  - if this is a re-prepare of the statement, first close previous data
    structure on the server and free old statement data
  - then send the query to server and get back number of placeholders,
    number of columns in result set (if any), and result set metadata.
    At the same time allocate memory for input and output parameters
    to have less checks in mysql_stmt_bind_{param, result}.

  RETURN VALUES
    0  success
   !0  error
*/

int STDCALL
mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, ulong length)
{
  MYSQL *mysql= stmt-&gt;mysql;
  DBUG_ENTER("mysql_stmt_prepare");

  if (!mysql)
  {
    /* mysql can be reset in mysql_close called from mysql_reconnect */
    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  /*
    Reset the last error in any case: that would clear the statement
    if the previous prepare failed.
  */
  stmt-&gt;last_errno= 0;
  stmt-&gt;last_error[0]= '\0';

  if ((int) stmt-&gt;state &gt; (int) MYSQL_STMT_INIT_DONE)
  {
    /* This is second prepare with another statement */
    uchar buff[MYSQL_STMT_HEADER];               /* 4 bytes - stmt id */

    if (reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT))
      DBUG_RETURN(1);
    /*
      These members must be reset for API to
      function in case of error or misuse.
    */
    stmt-&gt;bind_param_done= stmt-&gt;bind_result_done= FALSE;
    stmt-&gt;param_count= stmt-&gt;field_count= 0;
    free_root(&amp;stmt-&gt;mem_root, MYF(MY_KEEP_PREALLOC));
    free_root(&amp;stmt-&gt;extension-&gt;fields_mem_root, MYF(0));

    int4store(buff, stmt-&gt;stmt_id);

    /*
      Close statement in server

      If there was a 'use' result from another statement, or from
      mysql_use_result it won't be freed in mysql_stmt_free_result and
      we should get 'Commands out of sync' here.
    */
    stmt-&gt;state= MYSQL_STMT_INIT_DONE;
    if (stmt_command(mysql, COM_STMT_CLOSE, buff, 4, stmt))
    {
      set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
      DBUG_RETURN(1);
    }
  }

  if (stmt_command(mysql, COM_STMT_PREPARE, (const uchar*) query, length, stmt))
  {
    set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
    DBUG_RETURN(1);
  }

  if ((*mysql-&gt;methods-&gt;read_prepare_result)(mysql, stmt))
  {
    set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
    DBUG_RETURN(1);
  }

  /*
    alloc_root will return valid address even in case when param_count
    and field_count are zero. Thus we should never rely on stmt-&gt;bind
    or stmt-&gt;params when checking for existence of placeholders or
    result set.
  */
  if (!(stmt-&gt;params= (MYSQL_BIND *) alloc_root(&amp;stmt-&gt;mem_root,
						sizeof(MYSQL_BIND)*
                                                (stmt-&gt;param_count +
                                                 stmt-&gt;field_count))))
  {
    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }
  stmt-&gt;bind= stmt-&gt;params + stmt-&gt;param_count;
  stmt-&gt;state= MYSQL_STMT_PREPARE_DONE;
  DBUG_PRINT("info", ("Parameter count: %u", stmt-&gt;param_count));
  DBUG_RETURN(0);
}

/*
  Get result set metadata from reply to mysql_stmt_execute.
  This is used mainly for SHOW commands, as metadata for these
  commands is sent only with result set.
  To be removed when all commands will fully support prepared mode.
*/

static void alloc_stmt_fields(MYSQL_STMT *stmt)
{
  MYSQL_FIELD *fields, *field, *end;
  MEM_ROOT *fields_mem_root= &amp;stmt-&gt;extension-&gt;fields_mem_root;
  MYSQL *mysql= stmt-&gt;mysql;

  DBUG_ASSERT(stmt-&gt;field_count);

  free_root(fields_mem_root, MYF(0));

  /*
    Get the field information for non-select statements
    like SHOW and DESCRIBE commands
  */
  if (!(stmt-&gt;fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,
						 sizeof(MYSQL_FIELD) *
						 stmt-&gt;field_count)) ||
      !(stmt-&gt;bind= (MYSQL_BIND *) alloc_root(fields_mem_root,
					      sizeof(MYSQL_BIND) *
					      stmt-&gt;field_count)))
  {
    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
    return;
  }

  for (fields= mysql-&gt;fields, end= fields+stmt-&gt;field_count,
	 field= stmt-&gt;fields;
       field &amp;&amp; fields &lt; end; fields++, field++)
  {
    *field= *fields; /* To copy all numeric parts. */
    field-&gt;catalog=   strmake_root(fields_mem_root,
                                   fields-&gt;catalog,
                                   fields-&gt;catalog_length);
    field-&gt;db=        strmake_root(fields_mem_root,
                                   fields-&gt;db,
                                   fields-&gt;db_length);
    field-&gt;table=     strmake_root(fields_mem_root,
                                   fields-&gt;table,
                                   fields-&gt;table_length);
    field-&gt;org_table= strmake_root(fields_mem_root,
                                   fields-&gt;org_table,
                                   fields-&gt;org_table_length);
    field-&gt;name=      strmake_root(fields_mem_root,
                                   fields-&gt;name,
                                   fields-&gt;name_length);
    field-&gt;org_name=  strmake_root(fields_mem_root,
                                   fields-&gt;org_name,
                                   fields-&gt;org_name_length);
    if (fields-&gt;def)
    {
      field-&gt;def= strmake_root(fields_mem_root,
                               fields-&gt;def,
                               fields-&gt;def_length);
      field-&gt;def_length= fields-&gt;def_length;
    }
    else
    {
      field-&gt;def= NULL;
      field-&gt;def_length= 0;
    }
    field-&gt;extension= 0; /* Avoid dangling links. */
    field-&gt;max_length= 0; /* max_length is set in mysql_stmt_store_result() */
  }
}


/**
  Update result set columns metadata if it was sent again in
  reply to COM_STMT_EXECUTE.

  @note If the new field count is different from the original one,
        an error is set and no update is performed.
*/

static void update_stmt_fields(MYSQL_STMT *stmt)
{
  MYSQL_FIELD *field= stmt-&gt;mysql-&gt;fields;
  MYSQL_FIELD *field_end= field + stmt-&gt;field_count;
  MYSQL_FIELD *stmt_field= stmt-&gt;fields;
  MYSQL_BIND *my_bind= stmt-&gt;bind_result_done ? stmt-&gt;bind : 0;

  if (stmt-&gt;field_count != stmt-&gt;mysql-&gt;field_count)
  {
    /*
      The tables used in the statement were altered,
      and the query now returns a different number of columns.
      There is no way to continue without reallocating the bind
      array:
      - if the number of columns increased, mysql_stmt_fetch()
      will write beyond allocated memory
      - if the number of columns decreased, some user-bound
      buffers will be left unassigned without user knowing
      that.
    */
    set_stmt_error(stmt, CR_NEW_STMT_METADATA, unknown_sqlstate, NULL);
    return;
  }

  for (; field &lt; field_end; ++field, ++stmt_field)
  {
    stmt_field-&gt;charsetnr= field-&gt;charsetnr;
    stmt_field-&gt;length   = field-&gt;length;
    stmt_field-&gt;type     = field-&gt;type;
    stmt_field-&gt;flags    = field-&gt;flags;
    stmt_field-&gt;decimals = field-&gt;decimals;
    if (my_bind)
    {
      /* Ignore return value: it should be 0 if bind_result succeeded. */
      (void) setup_one_fetch_function(my_bind++, stmt_field);
    }
  }
}

/*
  Returns prepared statement metadata in the form of a result set.

  SYNOPSIS
    mysql_stmt_result_metadata()
    stmt  statement handle

  DESCRIPTION
    This function should be used after mysql_stmt_execute().
    You can safely check that prepared statement has a result set by calling
    mysql_stmt_field_count(): if number of fields is not zero, you can call
    this function to get fields metadata.
    Next steps you may want to make:
    - find out number of columns in result set by calling
      mysql_num_fields(res) (the same value is returned by
      mysql_stmt_field_count())
    - fetch metadata for any column with mysql_fetch_field,
      mysql_fetch_field_direct, mysql_fetch_fields, mysql_field_seek.
    - free returned MYSQL_RES structure with mysql_free_result.
    - proceed to binding of output parameters.

  RETURN
    NULL  statement contains no result set or out of memory.
          In the latter case you can retreive error message
          with mysql_stmt_error.
    MYSQL_RES  a result set with no rows
*/

MYSQL_RES * STDCALL
mysql_stmt_result_metadata(MYSQL_STMT *stmt)
{
  MYSQL_RES *result;
  DBUG_ENTER("mysql_stmt_result_metadata");

  /*
    stmt-&gt;fields is only defined if stmt-&gt;field_count is not null;
    stmt-&gt;field_count is initialized in prepare.
  */
  if (!stmt-&gt;field_count)
     DBUG_RETURN(0);

  if (!(result=(MYSQL_RES*) my_malloc(sizeof(*result),
                                      MYF(MY_WME | MY_ZEROFILL))))
  {
    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
    DBUG_RETURN(0);
  }

  result-&gt;methods=	stmt-&gt;mysql-&gt;methods;
  result-&gt;eof=		1;                      /* Marker for buffered */
  result-&gt;fields=	stmt-&gt;fields;
  result-&gt;field_count=	stmt-&gt;field_count;
  /* The rest of members of 'result' was zeroed inside malloc */
  DBUG_RETURN(result);
}


/*
  Returns parameter columns meta information in the form of
  result set.

  SYNOPSYS
    mysql_stmt_param_metadata()
    stmt    statement handle

  DESCRIPTION
    This function can be called after you prepared the statement handle
    with mysql_stmt_prepare().
    XXX: not implemented yet.

  RETURN
    MYSQL_RES on success, 0 if there is no metadata.
    Currently this function always returns 0.
*/

MYSQL_RES * STDCALL
mysql_stmt_param_metadata(MYSQL_STMT *stmt)
{
  DBUG_ENTER("mysql_stmt_param_metadata");

  if (!stmt-&gt;param_count)
    DBUG_RETURN(0);

  /*
    TODO: Fix this when server sends the information.
    Till then keep a dummy prototype.
  */
  DBUG_RETURN(0); 
}


/* Store type of parameter in network buffer. */

static void store_param_type(unsigned char **pos, MYSQL_BIND *param)
{
  uint typecode= param-&gt;buffer_type | (param-&gt;is_unsigned ? 32768 : 0);
  int2store(*pos, typecode);
  *pos+= 2;
}


/*
  Functions to store parameter data in network packet.

  SYNOPSIS
    store_param_xxx()
    net			MySQL NET connection
    param		MySQL bind param

  DESCRIPTION
    These funtions are invoked from mysql_stmt_execute() by
    MYSQL_BIND::store_param_func pointer. This pointer is set once per
    many executions in mysql_stmt_bind_param(). The caller must ensure
    that network buffer have enough capacity to store parameter
    (MYSQL_BIND::buffer_length contains needed number of bytes).
*/

static void store_param_tinyint(NET *net, MYSQL_BIND *param)
{
  *(net-&gt;write_pos++)= *(uchar *) param-&gt;buffer;
}

static void store_param_short(NET *net, MYSQL_BIND *param)
{
  short value= *(short*) param-&gt;buffer;
  int2store(net-&gt;write_pos,value);
  net-&gt;write_pos+=2;
}

static void store_param_int32(NET *net, MYSQL_BIND *param)
{
  int32 value= *(int32*) param-&gt;buffer;
  int4store(net-&gt;write_pos,value);
  net-&gt;write_pos+=4;
}

static void store_param_int64(NET *net, MYSQL_BIND *param)
{
  longlong value= *(longlong*) param-&gt;buffer;
  int8store(net-&gt;write_pos,value);
  net-&gt;write_pos+= 8;
}

static void store_param_float(NET *net, MYSQL_BIND *param)
{
  float value= *(float*) param-&gt;buffer;
  float4store(net-&gt;write_pos, value);
  net-&gt;write_pos+= 4;
}

static void store_param_double(NET *net, MYSQL_BIND *param)
{
  double value= *(double*) param-&gt;buffer;
  float8store(net-&gt;write_pos, value);
  net-&gt;write_pos+= 8;
}

static void store_param_time(NET *net, MYSQL_BIND *param)
{
  MYSQL_TIME *tm= (MYSQL_TIME *) param-&gt;buffer;
  char buff[MAX_TIME_REP_LENGTH], *pos;
  uint length;

  pos= buff+1;
  pos[0]= tm-&gt;neg ? 1: 0;
  int4store(pos+1, tm-&gt;day);
  pos[5]= (uchar) tm-&gt;hour;
  pos[6]= (uchar) tm-&gt;minute;
  pos[7]= (uchar) tm-&gt;second;
  int4store(pos+8, tm-&gt;second_part);
  if (tm-&gt;second_part)
    length= 12;
  else if (tm-&gt;hour || tm-&gt;minute || tm-&gt;second || tm-&gt;day)
    length= 8;
  else
    length= 0;
  buff[0]= (char) length++;
  memcpy((char *)net-&gt;write_pos, buff, length);
  net-&gt;write_pos+= length;
}

static void net_store_datetime(NET *net, MYSQL_TIME *tm)
{
  char buff[MAX_DATETIME_REP_LENGTH], *pos;
  uint length;

  pos= buff+1;

  int2store(pos, tm-&gt;year);
  pos[2]= (uchar) tm-&gt;month;
  pos[3]= (uchar) tm-&gt;day;
  pos[4]= (uchar) tm-&gt;hour;
  pos[5]= (uchar) tm-&gt;minute;
  pos[6]= (uchar) tm-&gt;second;
  int4store(pos+7, tm-&gt;second_part);
  if (tm-&gt;second_part)
    length= 11;
  else if (tm-&gt;hour || tm-&gt;minute || tm-&gt;second)
    length= 7;
  else if (tm-&gt;year || tm-&gt;month || tm-&gt;day)
    length= 4;
  else
    length= 0;
  buff[0]= (char) length++;
  memcpy((char *)net-&gt;write_pos, buff, length);
  net-&gt;write_pos+= length;
}

static void store_param_date(NET *net, MYSQL_BIND *param)
{
  MYSQL_TIME tm= *((MYSQL_TIME *) param-&gt;buffer);
  tm.hour= tm.minute= tm.second= tm.second_part= 0;
  net_store_datetime(net, &amp;tm);
}

static void store_param_datetime(NET *net, MYSQL_BIND *param)
{
  MYSQL_TIME *tm= (MYSQL_TIME *) param-&gt;buffer;
  net_store_datetime(net, tm);
}

static void store_param_str(NET *net, MYSQL_BIND *param)
{
  /* param-&gt;length is always set in mysql_stmt_bind_param */
  ulong length= *param-&gt;length;
  uchar *to= net_store_length(net-&gt;write_pos, length);
  memcpy(to, param-&gt;buffer, length);
  net-&gt;write_pos= to+length;
}


/*
  Mark if the parameter is NULL.

  SYNOPSIS
    store_param_null()
    net			MySQL NET connection
    param		MySQL bind param

  DESCRIPTION
    A data package starts with a string of bits where we set a bit
    if a parameter is NULL. Unlike bit string in result set row, here
    we don't have reserved bits for OK/error packet.
*/

static void store_param_null(NET *net, MYSQL_BIND *param)
{
  uint pos= param-&gt;param_number;
  net-&gt;buff[pos/8]|=  (uchar) (1 &lt;&lt; (pos &amp; 7));
}


/*
  Store one parameter in network packet: data is read from
  client buffer and saved in network packet by means of one
  of store_param_xxxx functions.
*/

static my_bool store_param(MYSQL_STMT *stmt, MYSQL_BIND *param)
{
  NET *net= &amp;stmt-&gt;mysql-&gt;net;
  DBUG_ENTER("store_param");
  DBUG_PRINT("enter",("type: %d  buffer: 0x%lx  length: %lu  is_null: %d",
		      param-&gt;buffer_type,
		      (long) (param-&gt;buffer ? param-&gt;buffer : NullS),
                      *param-&gt;length, *param-&gt;is_null));

  if (*param-&gt;is_null)
    store_param_null(net, param);
  else
  {
    /*
      Param-&gt;length should ALWAYS point to the correct length for the type
      Either to the length pointer given by the user or param-&gt;buffer_length
    */
    if ((my_realloc_str(net, *param-&gt;length)))
    {
      set_stmt_errmsg(stmt, net);
      DBUG_RETURN(1);
    }
    (*param-&gt;store_param_func)(net, param);
  }
  DBUG_RETURN(0);
}


/*
  Auxilary function to send COM_STMT_EXECUTE packet to server and read reply.
  Used from cli_stmt_execute, which is in turn used by mysql_stmt_execute.
*/

static my_bool execute(MYSQL_STMT *stmt, char *packet, ulong length)
{
  MYSQL *mysql= stmt-&gt;mysql;
  NET	*net= &amp;mysql-&gt;net;
  uchar buff[4 /* size of stmt id */ +
             5 /* execution flags */];
  my_bool res;
  DBUG_ENTER("execute");
  DBUG_DUMP("packet", (uchar *) packet, length);

  int4store(buff, stmt-&gt;stmt_id);		/* Send stmt id to server */
  buff[4]= (char) stmt-&gt;flags;
  int4store(buff+5, 1);                         /* iteration count */

  res= MY_TEST(cli_advanced_command(mysql, COM_STMT_EXECUTE, buff, sizeof(buff),
                                    (uchar*) packet, length, 1, stmt) ||
               (*mysql-&gt;methods-&gt;read_query_result)(mysql));
  stmt-&gt;affected_rows= mysql-&gt;affected_rows;
  stmt-&gt;server_status= mysql-&gt;server_status;
  stmt-&gt;insert_id= mysql-&gt;insert_id;
  if (res)
  {
    /* 
      Don't set stmt error if stmt-&gt;mysql is NULL, as the error in this case 
      has already been set by mysql_prune_stmt_list(). 
    */
    if (stmt-&gt;mysql)
      set_stmt_errmsg(stmt, net);
    DBUG_RETURN(1);
  }
  else if (mysql-&gt;status == MYSQL_STATUS_GET_RESULT)
    stmt-&gt;mysql-&gt;status= MYSQL_STATUS_STATEMENT_GET_RESULT;
  DBUG_RETURN(0);
}


int cli_stmt_execute(MYSQL_STMT *stmt)
{
  DBUG_ENTER("cli_stmt_execute");

  if (stmt-&gt;param_count)
  {
    MYSQL *mysql= stmt-&gt;mysql;
    NET        *net= &amp;mysql-&gt;net;
    MYSQL_BIND *param, *param_end;
    char       *param_data;
    ulong length;
    uint null_count;
    my_bool    result;

    if (!stmt-&gt;bind_param_done)
    {
      set_stmt_error(stmt, CR_PARAMS_NOT_BOUND, unknown_sqlstate, NULL);
      DBUG_RETURN(1);
    }
    if (mysql-&gt;status != MYSQL_STATUS_READY ||
        mysql-&gt;server_status &amp; SERVER_MORE_RESULTS_EXISTS)
    {
      set_stmt_error(stmt, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate, NULL);
      DBUG_RETURN(1);
    }

    if (net-&gt;vio)
      net_clear(net, 1);          /* Sets net-&gt;write_pos */
    else
    {
      set_stmt_errmsg(stmt, net);
      DBUG_RETURN(1);             
    }

    /* Reserve place for null-marker bytes */
    null_count= (stmt-&gt;param_count+7) /8;
    if (my_realloc_str(net, null_count + 1))
    {
      set_stmt_errmsg(stmt, net);
      DBUG_RETURN(1);
    }
    memset(net-&gt;write_pos, 0, null_count);
    net-&gt;write_pos+= null_count;
    param_end= stmt-&gt;params + stmt-&gt;param_count;

    /* In case if buffers (type) altered, indicate to server */
    *(net-&gt;write_pos)++= (uchar) stmt-&gt;send_types_to_server;
    if (stmt-&gt;send_types_to_server)
    {
      if (my_realloc_str(net, 2 * stmt-&gt;param_count))
      {
        set_stmt_errmsg(stmt, net);
        DBUG_RETURN(1);
      }
      /*
	Store types of parameters in first in first package
	that is sent to the server.
      */
      for (param= stmt-&gt;params;	param &lt; param_end ; param++)
        store_param_type(&amp;net-&gt;write_pos, param);
    }

    for (param= stmt-&gt;params; param &lt; param_end; param++)
    {
      /* check if mysql_stmt_send_long_data() was used */
      if (param-&gt;long_data_used)
	param-&gt;long_data_used= 0;	/* Clear for next execute call */
      else if (store_param(stmt, param))
	DBUG_RETURN(1);
    }
    length= (ulong) (net-&gt;write_pos - net-&gt;buff);
    /* TODO: Look into avoding the following memdup */
    if (!(param_data= my_memdup(net-&gt;buff, length, MYF(0))))
    {
      set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
      DBUG_RETURN(1);
    }
    result= execute(stmt, param_data, length);
    stmt-&gt;send_types_to_server=0;
    my_free(param_data);
    DBUG_RETURN(result);
  }
  DBUG_RETURN((int) execute(stmt,0,0));
}

/*
  Read one row from buffered result set.  Result set is created by prior
  call to mysql_stmt_store_result().
  SYNOPSIS
    stmt_read_row_buffered()

  RETURN VALUE
    0             - success; *row is set to valid row pointer (row data
                    is stored in result set buffer)
    MYSQL_NO_DATA - end of result set. *row is set to NULL
*/

static int stmt_read_row_buffered(MYSQL_STMT *stmt, unsigned char **row)
{
  if (stmt-&gt;data_cursor)
  {
    *row= (uchar *) stmt-&gt;data_cursor-&gt;data;
    stmt-&gt;data_cursor= stmt-&gt;data_cursor-&gt;next;
    return 0;
  }
  *row= 0;
  return MYSQL_NO_DATA;
}

/*
  Read one row from network: unbuffered non-cursor fetch.
  If last row was read, or error occured, erase this statement
  from record pointing to object unbuffered fetch is performed from.

  SYNOPSIS
    stmt_read_row_unbuffered()
    stmt  statement handle
    row   pointer to write pointer to row data;

  RETURN VALUE
    0           - success; *row contains valid address of a row;
                  row data is stored in network buffer
    1           - error; error code is written to
                  stmt-&gt;last_{errno,error}; *row is not changed
  MYSQL_NO_DATA - end of file was read from network;
                  *row is set to NULL
*/

static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row)
{
  int rc= 1;
  MYSQL *mysql= stmt-&gt;mysql;
  /*
    This function won't be called if stmt-&gt;field_count is zero
    or execution wasn't done: this is ensured by mysql_stmt_execute.
  */
  if (!mysql)
  {
    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);
    return 1;
  }
  if (mysql-&gt;status != MYSQL_STATUS_STATEMENT_GET_RESULT)
  {
    set_stmt_error(stmt, stmt-&gt;unbuffered_fetch_cancelled ?
                   CR_FETCH_CANCELED : CR_COMMANDS_OUT_OF_SYNC,
                   unknown_sqlstate, NULL);
    goto error;
  }
  if ((*mysql-&gt;methods-&gt;unbuffered_fetch)(mysql, (char**) row))
  {
    set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
    /*
      If there was an error, there are no more pending rows:
      reset statement status to not hang up in following
      mysql_stmt_close (it will try to flush result set before
      closing the statement).
    */
    mysql-&gt;status= MYSQL_STATUS_READY;
    goto error;
  }
  if (!*row)
  {
    mysql-&gt;status= MYSQL_STATUS_READY;
    rc= MYSQL_NO_DATA;
    goto error;
  }
  return 0;
error:
  if (mysql-&gt;unbuffered_fetch_owner == &amp;stmt-&gt;unbuffered_fetch_cancelled)
    mysql-&gt;unbuffered_fetch_owner= 0;
  return rc;
}


/*
  Fetch statement row using server side cursor.

  SYNOPSIS
    stmt_read_row_from_cursor()

  RETURN VALUE
    0            success
    1            error
  MYSQL_NO_DATA  end of data
*/

static int
stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row)
{
  if (stmt-&gt;data_cursor)
    return stmt_read_row_buffered(stmt, row);
  if (stmt-&gt;server_status &amp; SERVER_STATUS_LAST_ROW_SENT)
    stmt-&gt;server_status &amp;= ~SERVER_STATUS_LAST_ROW_SENT;
  else
  {
    MYSQL *mysql= stmt-&gt;mysql;
    NET *net= &amp;mysql-&gt;net;
    MYSQL_DATA *result= &amp;stmt-&gt;result;
    uchar buff[4 /* statement id */ +
               4 /* number of rows to fetch */];

    free_root(&amp;result-&gt;alloc, MYF(MY_KEEP_PREALLOC));
    result-&gt;data= NULL;
    result-&gt;rows= 0;
    /* Send row request to the server */
    int4store(buff, stmt-&gt;stmt_id);
    int4store(buff + 4, stmt-&gt;prefetch_rows); /* number of rows to fetch */
    if ((*mysql-&gt;methods-&gt;advanced_command)(mysql, COM_STMT_FETCH,
                                            buff, sizeof(buff), (uchar*) 0, 0,
                                            1, stmt))
    {
      /* 
        Don't set stmt error if stmt-&gt;mysql is NULL, as the error in this case 
        has already been set by mysql_prune_stmt_list(). 
      */
      if (stmt-&gt;mysql)
        set_stmt_errmsg(stmt, net);
      return 1;
    }
    if ((*mysql-&gt;methods-&gt;read_rows_from_cursor)(stmt))
      return 1;
    stmt-&gt;server_status= mysql-&gt;server_status;

    stmt-&gt;data_cursor= result-&gt;data;
    return stmt_read_row_buffered(stmt, row);
  }
  *row= 0;
  return MYSQL_NO_DATA;
}


/*
  Default read row function to not SIGSEGV in client in
  case of wrong sequence of API calls.
*/

static int
stmt_read_row_no_data(MYSQL_STMT *stmt  MY_ATTRIBUTE((unused)),
                      unsigned char **row  MY_ATTRIBUTE((unused)))
{
  return MYSQL_NO_DATA;
}

static int
stmt_read_row_no_result_set(MYSQL_STMT *stmt  MY_ATTRIBUTE((unused)),
                      unsigned char **row  MY_ATTRIBUTE((unused)))
{
  set_stmt_error(stmt, CR_NO_RESULT_SET, unknown_sqlstate, NULL);
  return 1;
}


/*
  Get/set statement attributes

  SYNOPSIS
    mysql_stmt_attr_get()
    mysql_stmt_attr_set()

    attr_type  statement attribute
    value      casted to const void * pointer to value.

  RETURN VALUE
    0 success
   !0 wrong attribute type
*/

my_bool STDCALL mysql_stmt_attr_set(MYSQL_STMT *stmt,
                                    enum enum_stmt_attr_type attr_type,
                                    const void *value)
{
  switch (attr_type) {
  case STMT_ATTR_UPDATE_MAX_LENGTH:
    stmt-&gt;update_max_length= value ? *(const my_bool*) value : 0;
    break;
  case STMT_ATTR_CURSOR_TYPE:
  {
    ulong cursor_type;
    cursor_type= value ? *(ulong*) value : 0UL;
    if (cursor_type &gt; (ulong) CURSOR_TYPE_READ_ONLY)
      goto err_not_implemented;
    stmt-&gt;flags= cursor_type;
    break;
  }
  case STMT_ATTR_PREFETCH_ROWS:
  {
    ulong prefetch_rows= value ? *(ulong*) value : DEFAULT_PREFETCH_ROWS;
    if (value == 0)
      return TRUE;
    stmt-&gt;prefetch_rows= prefetch_rows;
    break;
  }
  default:
    goto err_not_implemented;
  }
  return FALSE;
err_not_implemented:
  set_stmt_error(stmt, CR_NOT_IMPLEMENTED, unknown_sqlstate, NULL);
  return TRUE;
}


my_bool STDCALL mysql_stmt_attr_get(MYSQL_STMT *stmt,
                                    enum enum_stmt_attr_type attr_type,
                                    void *value)
{
  switch (attr_type) {
  case STMT_ATTR_UPDATE_MAX_LENGTH:
    *(my_bool*) value= stmt-&gt;update_max_length;
    break;
  case STMT_ATTR_CURSOR_TYPE:
    *(ulong*) value= stmt-&gt;flags;
    break;
  case STMT_ATTR_PREFETCH_ROWS:
    *(ulong*) value= stmt-&gt;prefetch_rows;
    break;
  default:
    return TRUE;
  }
  return FALSE;
}


/**
  Update statement result set metadata from with the new field
  information sent during statement execute.

  @pre mysql-&gt;field_count is not zero

  @retval TRUE   if error: out of memory or the new
                 result set has a different number of columns
  @retval FALSE  success
*/

static void reinit_result_set_metadata(MYSQL_STMT *stmt)
{
  /* Server has sent result set metadata */
  if (stmt-&gt;field_count == 0)
  {
    /*
      This is 'SHOW'/'EXPLAIN'-like query. Current implementation of
      prepared statements can't send result set metadata for these queries
      on prepare stage. Read it now.
    */

    stmt-&gt;field_count= stmt-&gt;mysql-&gt;field_count;

    alloc_stmt_fields(stmt);
  }
  else
  {
    /*
      Update result set metadata if it for some reason changed between
      prepare and execute, i.e.:
      - in case of 'SELECT ?' we don't know column type unless data was
      supplied to mysql_stmt_execute, so updated column type is sent
      now.
      - if data dictionary changed between prepare and execute, for
      example a table used in the query was altered.
      Note, that now (4.1.3) we always send metadata in reply to
      COM_STMT_EXECUTE (even if it is not necessary), so either this or
      previous branch always works.
      TODO: send metadata only when it's really necessary and add a warning
      'Metadata changed' when it's sent twice.
    */
    update_stmt_fields(stmt);
  }
}


static void prepare_to_fetch_result(MYSQL_STMT *stmt)
{
  if (stmt-&gt;server_status &amp; SERVER_STATUS_CURSOR_EXISTS)
  {
    stmt-&gt;mysql-&gt;status= MYSQL_STATUS_READY;
    stmt-&gt;read_row_func= stmt_read_row_from_cursor;
  }
  else if (stmt-&gt;flags &amp; CURSOR_TYPE_READ_ONLY)
  {
    /*
      This is a single-row result set, a result set with no rows, EXPLAIN,
      SHOW VARIABLES, or some other command which either a) bypasses the
      cursors framework in the server and writes rows directly to the
      network or b) is more efficient if all (few) result set rows are
      precached on client and server's resources are freed.
    */
    mysql_stmt_store_result(stmt);
  }
  else
  {
    stmt-&gt;mysql-&gt;unbuffered_fetch_owner= &amp;stmt-&gt;unbuffered_fetch_cancelled;
    stmt-&gt;unbuffered_fetch_cancelled= FALSE;
    stmt-&gt;read_row_func= stmt_read_row_unbuffered;
  }
}


/*
  Send placeholders data to server (if there are placeholders)
  and execute prepared statement.

  SYNOPSIS
    mysql_stmt_execute()
    stmt  statement handle. The handle must be created
          with mysql_stmt_init() and prepared with
          mysql_stmt_prepare(). If there are placeholders
          in the statement they must be bound to local
          variables with mysql_stmt_bind_param().

  DESCRIPTION
    This function will automatically flush pending result
    set (if there is one), send parameters data to the server
    and read result of statement execution.
    If previous result set was cached with mysql_stmt_store_result()
    it will also be freed in the beginning of this call.
    The server can return 3 types of responses to this command:
    - error, can be retrieved with mysql_stmt_error()
    - ok, no result set pending. In this case we just update
      stmt-&gt;insert_id and stmt-&gt;affected_rows.
    - the query returns a result set: there could be 0 .. N
    rows in it. In this case the server can also send updated
    result set metadata.

    Next steps you may want to make:
    - find out if there is result set with mysql_stmt_field_count().
    If there is one:
    - optionally, cache entire result set on client to unblock
    connection with mysql_stmt_store_result()
    - bind client variables to result set columns and start read rows
    with mysql_stmt_fetch().
    - reset statement with mysql_stmt_reset() or close it with
    mysql_stmt_close()
    Otherwise:
    - find out last insert id and number of affected rows with
    mysql_stmt_insert_id(), mysql_stmt_affected_rows()

  RETURN
    0   success
    1   error, message can be retrieved with mysql_stmt_error().
*/

int STDCALL mysql_stmt_execute(MYSQL_STMT *stmt)
{
  MYSQL *mysql= stmt-&gt;mysql;
  DBUG_ENTER("mysql_stmt_execute");

  if (!mysql)
  {
    /* Error is already set in mysql_detatch_stmt_list */
    DBUG_RETURN(1);
  }

  if (reset_stmt_handle(stmt, RESET_STORE_RESULT | RESET_CLEAR_ERROR))
    DBUG_RETURN(1);
  /*
    No need to check for stmt-&gt;state: if the statement wasn't
    prepared we'll get 'unknown statement handler' error from server.
  */
  if (mysql-&gt;methods-&gt;stmt_execute(stmt))
    DBUG_RETURN(1);
  stmt-&gt;state= MYSQL_STMT_EXECUTE_DONE;
  if (mysql-&gt;field_count)
  {
    reinit_result_set_metadata(stmt);
    prepare_to_fetch_result(stmt);
  }
  DBUG_RETURN(MY_TEST(stmt-&gt;last_errno));
}


/*
  Return total parameters count in the statement
*/

ulong STDCALL mysql_stmt_param_count(MYSQL_STMT * stmt)
{
  DBUG_ENTER("mysql_stmt_param_count");
  DBUG_RETURN(stmt-&gt;param_count);
}

/*
  Return total affected rows from the last statement
*/

my_ulonglong STDCALL mysql_stmt_affected_rows(MYSQL_STMT *stmt)
{
  return stmt-&gt;affected_rows;
}


/*
  Returns the number of result columns for the most recent query
  run on this statement.
*/

unsigned int STDCALL mysql_stmt_field_count(MYSQL_STMT *stmt)
{
  return stmt-&gt;field_count;
}

/*
  Return last inserted id for auto_increment columns.

  SYNOPSIS
    mysql_stmt_insert_id()
    stmt    statement handle

  DESCRIPTION
    Current implementation of this call has a caveat: stmt-&gt;insert_id is
    unconditionally updated from mysql-&gt;insert_id in the end of each
    mysql_stmt_execute(). This works OK if mysql-&gt;insert_id contains new
    value (sent in reply to mysql_stmt_execute()), otherwise stmt-&gt;insert_id
    value gets undefined, as it's updated from some arbitrary value saved in
    connection structure during some other call.
*/

my_ulonglong STDCALL mysql_stmt_insert_id(MYSQL_STMT *stmt)
{
  return stmt-&gt;insert_id;
}


static my_bool int_is_null_true= 1;		/* Used for MYSQL_TYPE_NULL */
static my_bool int_is_null_false= 0;


/*
  Set up input data buffers for a statement.

  SYNOPSIS
    mysql_stmt_bind_param()
    stmt    statement handle
            The statement must be prepared with mysql_stmt_prepare().
    my_bind Array of mysql_stmt_param_count() bind parameters.
            This function doesn't check that size of this argument
            is &gt;= mysql_stmt_field_count(): it's user's responsibility.

  DESCRIPTION
    Use this call after mysql_stmt_prepare() to bind user variables to
    placeholders.
    Each element of bind array stands for a placeholder. Placeholders
    are counted from 0.  For example statement
    'INSERT INTO t (a, b) VALUES (?, ?)'
    contains two placeholders, and for such statement you should supply
    bind array of two elements (MYSQL_BIND bind[2]).

    By properly initializing bind array you can bind virtually any
    C language type to statement's placeholders:
    First, it's strongly recommended to always zero-initialize entire
    bind structure before setting its members. This will both shorten
    your application code and make it robust to future extensions of
    MYSQL_BIND structure.
    Then you need to assign typecode of your application buffer to
    MYSQL_BIND::buffer_type. The following typecodes with their
    correspondence to C language types are supported:
    MYSQL_TYPE_TINY       for 8-bit integer variables. Normally it's
                          'signed char' and 'unsigned char';
    MYSQL_TYPE_SHORT      for 16-bit signed and unsigned variables. This
                          is usually 'short' and 'unsigned short';
    MYSQL_TYPE_LONG       for 32-bit signed and unsigned variables. It
                          corresponds to 'int' and 'unsigned int' on
                          vast majority of platforms. On IA-32 and some
                          other 32-bit systems you can also use 'long'
                          here;
    MYSQL_TYPE_LONGLONG   64-bit signed or unsigned integer.  Stands for
                          '[unsigned] long long' on most platforms;
    MYSQL_TYPE_FLOAT      32-bit floating point type, 'float' on most
                          systems;
    MYSQL_TYPE_DOUBLE     64-bit floating point type, 'double' on most
                          systems;
    MYSQL_TYPE_TIME       broken-down time stored in MYSQL_TIME
                          structure
    MYSQL_TYPE_DATE       date stored in MYSQL_TIME structure
    MYSQL_TYPE_DATETIME   datetime stored in MYSQL_TIME structure See
                          more on how to use these types for sending
                          dates and times below;
    MYSQL_TYPE_STRING     character string, assumed to be in
                          character-set-client. If character set of
                          client is not equal to character set of
                          column, value for this placeholder will be
                          converted to destination character set before
                          insert.
    MYSQL_TYPE_BLOB       sequence of bytes. This sequence is assumed to
                          be in binary character set (which is the same
                          as no particular character set), and is never
                          converted to any other character set. See also
                          notes about supplying string/blob length
                          below.
    MYSQL_TYPE_NULL       special typecode for binding nulls.
    These C/C++ types are not supported yet by the API: long double,
    bool.

    As you can see from the list above, it's responsibility of
    application programmer to ensure that chosen typecode properly
    corresponds to host language type. For example on all platforms
    where we build MySQL packages (as of MySQL 4.1.4) int is a 32-bit
    type. So for int you can always assume that proper typecode is
    MYSQL_TYPE_LONG (however queer it sounds, the name is legacy of the
    old MySQL API). In contrary sizeof(long) can be 4 or 8 8-bit bytes,
    depending on platform.

    TODO: provide client typedefs for each integer and floating point
    typecode, i. e. int8, uint8, float32, etc.

    Once typecode was set, it's necessary to assign MYSQL_BIND::buffer
    to point to the buffer of given type. Finally, additional actions
    may be taken for some types or use cases:

    Binding integer types.
      For integer types you might also need to set MYSQL_BIND::is_unsigned
      member. Set it to TRUE when binding unsigned char, unsigned short,
      unsigned int, unsigned long, unsigned long long.

    Binding floating point types.
      For floating point types you just need to set
      MYSQL_BIND::buffer_type and MYSQL_BIND::buffer. The rest of the
      members should be zero-initialized.

    Binding NULLs.
      You might have a column always NULL, never NULL, or sometimes
      NULL.  For an always NULL column set MYSQL_BIND::buffer_type to
      MYSQL_TYPE_NULL.  The rest of the members just need to be
      zero-initialized.  For never NULL columns set
      MYSQL_BIND::is_null to 0, or this has already been done if you
      zero-initialized the entire structure.  If you set
      MYSQL_TYPE::is_null to point to an application buffer of type
      'my_bool', then this buffer will be checked on each execution:
      this way you can set the buffer to TRUE, or any non-0 value for
      NULLs, and to FALSE or 0 for not NULL data.

    Binding text strings and sequences of bytes.
      For strings, in addition to MYSQL_BIND::buffer_type and
      MYSQL_BIND::buffer you need to set MYSQL_BIND::length or
      MYSQL_BIND::buffer_length.  If 'length' is set, 'buffer_length'
      is ignored. 'buffer_length' member should be used when size of
      string doesn't change between executions. If you want to vary
      buffer length for each value, set 'length' to point to an
      application buffer of type 'unsigned long' and set this long to
      length of the string before each mysql_stmt_execute().

    Binding dates and times.
      For binding dates and times prepared statements API provides
      clients with MYSQL_TIME structure. A pointer to instance of this
      structure should be assigned to MYSQL_BIND::buffer whenever
      MYSQL_TYPE_TIME, MYSQL_TYPE_DATE, MYSQL_TYPE_DATETIME typecodes
      are used.  When typecode is MYSQL_TYPE_TIME, only members
      'hour', 'minute', 'second' and 'neg' (is time offset negative)
      are used. These members only will be sent to the server.
      MYSQL_TYPE_DATE implies use of 'year', 'month', 'day', 'neg'.
      MYSQL_TYPE_DATETIME utilizes both parts of MYSQL_TIME structure.
      You don't have to set MYSQL_TIME::time_type member: it's not
      used when sending data to the server, typecode information is
      enough.  'second_part' member can hold microsecond precision of
      time value, but now it's only supported on protocol level: you
      can't store microsecond in a column, or use in temporal
      calculations. However, if you send a time value with microsecond
      part for 'SELECT ?', statement, you'll get it back unchanged
      from the server.

    Data conversion.
      If conversion from host language type to data representation,
      corresponding to SQL type, is required it's done on the server.
      Data truncation is possible when conversion is lossy. For
      example, if you supply MYSQL_TYPE_DATETIME value out of valid
      SQL type TIMESTAMP range, the same conversion will be applied as
      if this value would have been sent as string in the old
      protocol.  TODO: document how the server will behave in case of
      truncation/data loss.

    After variables were bound, you can repeatedly set/change their
    values and mysql_stmt_execute() the statement.

    See also: mysql_stmt_send_long_data() for sending long text/blob
    data in pieces, examples in tests/mysql_client_test.c.
    Next steps you might want to make:
    - execute statement with mysql_stmt_execute(),
    - reset statement using mysql_stmt_reset() or reprepare it with
      another query using mysql_stmt_prepare()
    - close statement with mysql_stmt_close().

  IMPLEMENTATION
    The function copies given bind array to internal storage of the
    statement, and sets up typecode-specific handlers to perform
    serialization of bound data. This means that although you don't need
    to call this routine after each assignment to bind buffers, you
    need to call it each time you change parameter typecodes, or other
    members of MYSQL_BIND array.
    This is a pure local call. Data types of client buffers are sent
    along with buffers' data at first execution of the statement.

  RETURN
    0  success
    1  error, can be retrieved with mysql_stmt_error.
*/

my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
{
  uint count=0;
  MYSQL_BIND *param, *end;
  DBUG_ENTER("mysql_stmt_bind_param");

  if (!stmt-&gt;param_count)
  {
    if ((int) stmt-&gt;state &lt; (int) MYSQL_STMT_PREPARE_DONE)
    {
      set_stmt_error(stmt, CR_NO_PREPARE_STMT, unknown_sqlstate, NULL);
      DBUG_RETURN(1);
    }
    DBUG_RETURN(0);
  }

  /* Allocated on prepare */
  memcpy((char*) stmt-&gt;params, (char*) my_bind,
	 sizeof(MYSQL_BIND) * stmt-&gt;param_count);

  for (param= stmt-&gt;params, end= param+stmt-&gt;param_count;
       param &lt; end ;
       param++)
  {
    param-&gt;param_number= count++;
    param-&gt;long_data_used= 0;

    /* If param-&gt;is_null is not set, then the value can never be NULL */
    if (!param-&gt;is_null)
      param-&gt;is_null= &amp;int_is_null_false;

    /* Setup data copy functions for the different supported types */
    switch (param-&gt;buffer_type) {
    case MYSQL_TYPE_NULL:
      param-&gt;is_null= &amp;int_is_null_true;
      break;
    case MYSQL_TYPE_TINY:
      /* Force param-&gt;length as this is fixed for this type */
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 1;
      param-&gt;store_param_func= store_param_tinyint;
      break;
    case MYSQL_TYPE_SHORT:
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 2;
      param-&gt;store_param_func= store_param_short;
      break;
    case MYSQL_TYPE_LONG:
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 4;
      param-&gt;store_param_func= store_param_int32;
      break;
    case MYSQL_TYPE_LONGLONG:
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 8;
      param-&gt;store_param_func= store_param_int64;
      break;
    case MYSQL_TYPE_FLOAT:
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 4;
      param-&gt;store_param_func= store_param_float;
      break;
    case MYSQL_TYPE_DOUBLE:
      param-&gt;length= &amp;param-&gt;buffer_length;
      param-&gt;buffer_length= 8;
      param-&gt;store_param_func= store_param_double;
      break;
    case MYSQL_TYPE_TIME:
      param-&gt;store_param_func= store_param_time;
      param-&gt;buffer_length= MAX_TIME_REP_LENGTH;
      break;
    case MYSQL_TYPE_DATE:
      param-&gt;store_param_func= store_param_date;
      param-&gt;buffer_length= MAX_DATE_REP_LENGTH;
      break;
    case MYSQL_TYPE_DATETIME:
    case MYSQL_TYPE_TIMESTAMP:
      param-&gt;store_param_func= store_param_datetime;
      param-&gt;buffer_length= MAX_DATETIME_REP_LENGTH;
      break;
    case MYSQL_TYPE_TINY_BLOB:
    case MYSQL_TYPE_MEDIUM_BLOB:
    case MYSQL_TYPE_LONG_BLOB:
    case MYSQL_TYPE_BLOB:
    case MYSQL_TYPE_VARCHAR:
    case MYSQL_TYPE_VAR_STRING:
    case MYSQL_TYPE_STRING:
    case MYSQL_TYPE_DECIMAL:
    case MYSQL_TYPE_NEWDECIMAL:
      param-&gt;store_param_func= store_param_str;
      /*
        For variable length types user must set either length or
        buffer_length.
      */
      break;
    default:
      strmov(stmt-&gt;sqlstate, unknown_sqlstate);
      sprintf(stmt-&gt;last_error,
	      ER(stmt-&gt;last_errno= CR_UNSUPPORTED_PARAM_TYPE),
	      param-&gt;buffer_type, count);
      DBUG_RETURN(1);
    }
    /*
      If param-&gt;length is not given, change it to point to buffer_length.
      This way we can always use *param-&gt;length to get the length of data
    */
    if (!param-&gt;length)
      param-&gt;length= &amp;param-&gt;buffer_length;
  }
  /* We have to send/resend type information to MySQL */
  stmt-&gt;send_types_to_server= TRUE;
  stmt-&gt;bind_param_done= TRUE;
  DBUG_RETURN(0);
}


/********************************************************************
 Long data implementation
*********************************************************************/

/*
  Send long data in pieces to the server

  SYNOPSIS
    mysql_stmt_send_long_data()
    stmt			Statement handler
    param_number		Parameter number (0 - N-1)
    data			Data to send to server
    length			Length of data to send (may be 0)

  DESCRIPTION
    This call can be used repeatedly to send long data in pieces
    for any string/binary placeholder. Data supplied for
    a placeholder is saved at server side till execute, and then
    used instead of value from MYSQL_BIND object. More precisely,
    if long data for a parameter was supplied, MYSQL_BIND object
    corresponding to this parameter is not sent to server. In the
    end of execution long data states of placeholders are reset,
    so next time values of such placeholders will be taken again
    from MYSQL_BIND array.
    The server does not reply to this call: if there was an error
    in data handling (which now only can happen if server run out
    of memory) it would be returned in reply to
    mysql_stmt_execute().
    You should choose type of long data carefully if you care
    about character set conversions performed by server when the
    statement is executed.  No conversion is performed at all for
    MYSQL_TYPE_BLOB and other binary typecodes. For
    MYSQL_TYPE_STRING and the rest of text placeholders data is
    converted from client character set to character set of
    connection. If these character sets are different, this
    conversion may require additional memory at server, equal to
    total size of supplied pieces.

  RETURN VALUES
    0	ok
    1	error
*/

my_bool STDCALL
mysql_stmt_send_long_data(MYSQL_STMT *stmt, uint param_number,
		     const char *data, ulong length)
{
  MYSQL_BIND *param;
  DBUG_ENTER("mysql_stmt_send_long_data");
  DBUG_ASSERT(stmt != 0);
  DBUG_PRINT("enter",("param no: %d  data: 0x%lx, length : %ld",
		      param_number, (long) data, length));

  /*
    We only need to check for stmt-&gt;param_count, if it's not null
    prepare was done.
  */
  if (param_number &gt;= stmt-&gt;param_count)
  {
    set_stmt_error(stmt, CR_INVALID_PARAMETER_NO, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  param= stmt-&gt;params+param_number;
  if (!IS_LONGDATA(param-&gt;buffer_type))
  {
    /* Long data handling should be used only for string/binary types */
    strmov(stmt-&gt;sqlstate, unknown_sqlstate);
    sprintf(stmt-&gt;last_error, ER(stmt-&gt;last_errno= CR_INVALID_BUFFER_USE),
	    param-&gt;param_number);
    DBUG_RETURN(1);
  }

  /*
    Send long data packet if there is data or we're sending long data
    for the first time.
  */
  if (length || param-&gt;long_data_used == 0)
  {
    MYSQL *mysql= stmt-&gt;mysql;
    /* Packet header: stmt id (4 bytes), param no (2 bytes) */
    uchar buff[MYSQL_LONG_DATA_HEADER];

    int4store(buff, stmt-&gt;stmt_id);
    int2store(buff + 4, param_number);
    param-&gt;long_data_used= 1;

    /*
      Note that we don't get any ok packet from the server in this case
      This is intentional to save bandwidth.
    */
    if ((*mysql-&gt;methods-&gt;advanced_command)(mysql, COM_STMT_SEND_LONG_DATA,
                                            buff, sizeof(buff), (uchar*) data,
                                            length, 1, stmt))
    {
      /* 
        Don't set stmt error if stmt-&gt;mysql is NULL, as the error in this case 
        has already been set by mysql_prune_stmt_list(). 
      */
      if (stmt-&gt;mysql)
        set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
      DBUG_RETURN(1);
    }
  }
  DBUG_RETURN(0);
}


/********************************************************************
 Fetch and conversion of result set rows (binary protocol).
*********************************************************************/

/*
  Read date, (time, datetime) value from network buffer and store it
  in MYSQL_TIME structure.

  SYNOPSIS
    read_binary_{date,time,datetime}()
    tm    MYSQL_TIME structure to fill
    pos   pointer to current position in network buffer.
          These functions increase pos to point to the beginning of the
          next column.

  Auxiliary functions to read time (date, datetime) values from network
  buffer and store in MYSQL_TIME structure. Jointly used by conversion
  and no-conversion fetching.
*/

static void read_binary_time(MYSQL_TIME *tm, uchar **pos)
{
  /* net_field_length will set pos to the first byte of data */
  uint length= net_field_length(pos);

  if (length)
  {
    uchar *to= *pos;
    tm-&gt;neg=    to[0];

    tm-&gt;day=    (ulong) sint4korr(to+1);
    tm-&gt;hour=   (uint) to[5];
    tm-&gt;minute= (uint) to[6];
    tm-&gt;second= (uint) to[7];
    tm-&gt;second_part= (length &gt; 8) ? (ulong) sint4korr(to+8) : 0;
    tm-&gt;year= tm-&gt;month= 0;
    if (tm-&gt;day)
    {
      /* Convert days to hours at once */
      tm-&gt;hour+= tm-&gt;day*24;
      tm-&gt;day= 0;
    }
    tm-&gt;time_type= MYSQL_TIMESTAMP_TIME;

    *pos+= length;
  }
  else
    set_zero_time(tm, MYSQL_TIMESTAMP_TIME);
}

static void read_binary_datetime(MYSQL_TIME *tm, uchar **pos)
{
  uint length= net_field_length(pos);

  if (length)
  {
    uchar *to= *pos;

    tm-&gt;neg=    0;
    tm-&gt;year=   (uint) sint2korr(to);
    tm-&gt;month=  (uint) to[2];
    tm-&gt;day=    (uint) to[3];

    if (length &gt; 4)
    {
      tm-&gt;hour=   (uint) to[4];
      tm-&gt;minute= (uint) to[5];
      tm-&gt;second= (uint) to[6];
    }
    else
      tm-&gt;hour= tm-&gt;minute= tm-&gt;second= 0;
    tm-&gt;second_part= (length &gt; 7) ? (ulong) sint4korr(to+7) : 0;
    tm-&gt;time_type= MYSQL_TIMESTAMP_DATETIME;

    *pos+= length;
  }
  else
    set_zero_time(tm, MYSQL_TIMESTAMP_DATETIME);
}

static void read_binary_date(MYSQL_TIME *tm, uchar **pos)
{
  uint length= net_field_length(pos);

  if (length)
  {
    uchar *to= *pos;
    tm-&gt;year =  (uint) sint2korr(to);
    tm-&gt;month=  (uint) to[2];
    tm-&gt;day= (uint) to[3];

    tm-&gt;hour= tm-&gt;minute= tm-&gt;second= 0;
    tm-&gt;second_part= 0;
    tm-&gt;neg= 0;
    tm-&gt;time_type= MYSQL_TIMESTAMP_DATE;

    *pos+= length;
  }
  else
    set_zero_time(tm, MYSQL_TIMESTAMP_DATE);
}


/*
  Convert string to supplied buffer of any type.

  SYNOPSIS
    fetch_string_with_conversion()
    param   output buffer descriptor
    value   column data
    length  data length
*/

static void fetch_string_with_conversion(MYSQL_BIND *param, char *value,
                                         uint length)
{
  char *buffer= (char *)param-&gt;buffer;
  char *endptr= value + length;

  /*
    This function should support all target buffer types: the rest
    of conversion functions can delegate conversion to it.
  */
  switch (param-&gt;buffer_type) {
  case MYSQL_TYPE_NULL: /* do nothing */
    break;
  case MYSQL_TYPE_TINY:
  {
    int err;
    longlong data= my_strtoll10(value, &amp;endptr, &amp;err);
    *param-&gt;error= (IS_TRUNCATED(data, param-&gt;is_unsigned,
                                 INT_MIN8, INT_MAX8, UINT_MAX8) || err &gt; 0);
    *buffer= (uchar) data;
    break;
  }
  case MYSQL_TYPE_SHORT:
  {
    int err;
    longlong data= my_strtoll10(value, &amp;endptr, &amp;err);
    *param-&gt;error= (IS_TRUNCATED(data, param-&gt;is_unsigned,
                                 INT_MIN16, INT_MAX16, UINT_MAX16) || err &gt; 0);
    shortstore(buffer, (short) data);
    break;
  }
  case MYSQL_TYPE_LONG:
  {
    int err;
    longlong data= my_strtoll10(value, &amp;endptr, &amp;err);
    *param-&gt;error= (IS_TRUNCATED(data, param-&gt;is_unsigned,
                                 INT_MIN32, INT_MAX32, UINT_MAX32) || err &gt; 0);
    longstore(buffer, (int32) data);
    break;
  }
  case MYSQL_TYPE_LONGLONG:
  {
    int err;
    longlong data= my_strtoll10(value, &amp;endptr, &amp;err);
    *param-&gt;error= param-&gt;is_unsigned ? err != 0 :
                                       (err &gt; 0 || (err == 0 &amp;&amp; data &lt; 0));
    longlongstore(buffer, data);
    break;
  }
  case MYSQL_TYPE_FLOAT:
  {
    int err;
    double data= my_strntod(&amp;my_charset_latin1, value, length, &amp;endptr, &amp;err);
    float fdata= (float) data;
    *param-&gt;error= (fdata != data) | MY_TEST(err);
    floatstore(buffer, fdata);
    break;
  }
  case MYSQL_TYPE_DOUBLE:
  {
    int err;
    double data= my_strntod(&amp;my_charset_latin1, value, length, &amp;endptr, &amp;err);
    *param-&gt;error= MY_TEST(err);
    doublestore(buffer, data);
    break;
  }
  case MYSQL_TYPE_TIME:
  {
    MYSQL_TIME_STATUS status;
    MYSQL_TIME *tm= (MYSQL_TIME *)buffer;
    str_to_time(value, length, tm, &amp;status);
    *param-&gt;error= MY_TEST(status.warnings);
    break;
  }
  case MYSQL_TYPE_DATE:
  case MYSQL_TYPE_DATETIME:
  case MYSQL_TYPE_TIMESTAMP:
  {
    MYSQL_TIME_STATUS status;
    MYSQL_TIME *tm= (MYSQL_TIME *)buffer;
    (void) str_to_datetime(value, length, tm, TIME_FUZZY_DATE, &amp;status);
    *param-&gt;error= MY_TEST(status.warnings) &amp;&amp;
                   (param-&gt;buffer_type == MYSQL_TYPE_DATE &amp;&amp;
                    tm-&gt;time_type != MYSQL_TIMESTAMP_DATE);
    break;
  }
  case MYSQL_TYPE_TINY_BLOB:
  case MYSQL_TYPE_MEDIUM_BLOB:
  case MYSQL_TYPE_LONG_BLOB:
  case MYSQL_TYPE_BLOB:
  case MYSQL_TYPE_DECIMAL:
  case MYSQL_TYPE_NEWDECIMAL:
  default:
  {
    /*
      Copy column data to the buffer taking into account offset,
      data length and buffer length.
    */
    char *start= value + param-&gt;offset;
    char *end= value + length;
    ulong copy_length;
    if (start &lt; end)
    {
      copy_length= end - start;
      /* We've got some data beyond offset: copy up to buffer_length bytes */
      if (param-&gt;buffer_length)
        memcpy(buffer, start, MY_MIN(copy_length, param-&gt;buffer_length));
    }
    else
      copy_length= 0;
    if (copy_length &lt; param-&gt;buffer_length)
      buffer[copy_length]= '\0';
    *param-&gt;error= copy_length &gt; param-&gt;buffer_length;
    /*
      param-&gt;length will always contain length of entire column;
      number of copied bytes may be way different:
    */
    *param-&gt;length= length;
    break;
  }
  }
}


/*
  Convert integer value to client buffer of any type.

  SYNOPSIS
    fetch_long_with_conversion()
    param   output buffer descriptor
    field   column metadata
    value   column data
*/

static void fetch_long_with_conversion(MYSQL_BIND *param, MYSQL_FIELD *field,
                                       longlong value, my_bool is_unsigned)
{
  char *buffer= (char *)param-&gt;buffer;

  switch (param-&gt;buffer_type) {
  case MYSQL_TYPE_NULL: /* do nothing */
    break;
  case MYSQL_TYPE_TINY:
    *param-&gt;error= IS_TRUNCATED(value, param-&gt;is_unsigned,
                                INT_MIN8, INT_MAX8, UINT_MAX8);
    *(uchar *)param-&gt;buffer= (uchar) value;
    break;
  case MYSQL_TYPE_SHORT:
    *param-&gt;error= IS_TRUNCATED(value, param-&gt;is_unsigned,
                                INT_MIN16, INT_MAX16, UINT_MAX16);
    shortstore(buffer, (short) value);
    break;
  case MYSQL_TYPE_LONG:
    *param-&gt;error= IS_TRUNCATED(value, param-&gt;is_unsigned,
                                INT_MIN32, INT_MAX32, UINT_MAX32);
    longstore(buffer, (int32) value);
    break;
  case MYSQL_TYPE_LONGLONG:
    longlongstore(buffer, value);
    *param-&gt;error= param-&gt;is_unsigned != is_unsigned &amp;&amp; value &lt; 0;
    break;
  case MYSQL_TYPE_FLOAT:
  {
    /*
      We need to mark the local variable volatile to
      workaround Intel FPU executive precision feature.
      (See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=323 for details)
    */
    volatile float data;
    if (is_unsigned)
    {
      data= (float) ulonglong2double(value);
      *param-&gt;error= ((ulonglong) value) != ((ulonglong) data);
    }
    else
    {
      data= (float)value;
      *param-&gt;error= value != ((longlong) data);
    }
    floatstore(buffer, data);
    break;
  }
  case MYSQL_TYPE_DOUBLE:
  {
    volatile double data;
    if (is_unsigned)
    {
      data= ulonglong2double(value);
      *param-&gt;error= ((ulonglong) value) != ((ulonglong) data);
    }
    else
    {
      data= (double)value;
      *param-&gt;error= value != ((longlong) data);
    }
    doublestore(buffer, data);
    break;
  }
  case MYSQL_TYPE_TIME:
  case MYSQL_TYPE_DATE:
  case MYSQL_TYPE_TIMESTAMP:
  case MYSQL_TYPE_DATETIME:
  {
    int error;
    value= number_to_datetime(value, (MYSQL_TIME *) buffer, TIME_FUZZY_DATE,
                              &amp;error);
    *param-&gt;error= MY_TEST(error);
    break;
  }
  default:
  {
    uchar buff[22];                              /* Enough for longlong */
    uchar *end= (uchar*) longlong10_to_str(value, (char*) buff,
                                           is_unsigned ? 10: -10);
    /* Resort to string conversion which supports all typecodes */
    uint length= (uint) (end-buff);

    if (field-&gt;flags &amp; ZEROFILL_FLAG &amp;&amp; length &lt; field-&gt;length &amp;&amp;
        field-&gt;length &lt; 21)
    {
      bmove_upp(buff+field-&gt;length,buff+length, length);
      memset(buff, '0', field-&gt;length - length);
      length= field-&gt;length;
    }
    fetch_string_with_conversion(param, (char*) buff, length);
    break;
  }
  }
}

/*
  Convert double/float column to supplied buffer of any type.

  SYNOPSIS
    fetch_float_with_conversion()
    param   output buffer descriptor
    field   column metadata
    value   column data
    type    either MY_GCVT_ARG_FLOAT or MY_GCVT_ARG_DOUBLE.
            Affects the maximum number of significant digits
            returned by my_gcvt().
*/

static void fetch_float_with_conversion(MYSQL_BIND *param, MYSQL_FIELD *field,
                                        double value, my_gcvt_arg_type type)
{
  char *buffer= (char *)param-&gt;buffer;
  double val64 = (value &lt; 0 ? -floor(-value) : floor(value));

  switch (param-&gt;buffer_type) {
  case MYSQL_TYPE_NULL: /* do nothing */
    break;
  case MYSQL_TYPE_TINY:
    /*
      We need to _store_ data in the buffer before the truncation check to
      workaround Intel FPU executive precision feature.
      (See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=323 for details)
      Sic: AFAIU it does not guarantee to work.
    */
    if (param-&gt;is_unsigned)
      *buffer= (uint8) value;
    else
      *buffer= (int8) value;
    *param-&gt;error= val64 != (param-&gt;is_unsigned ? (double)((uint8) *buffer) :
                                                  (double)((int8) *buffer));
    break;
  case MYSQL_TYPE_SHORT:
    if (param-&gt;is_unsigned)
    {
      ushort data= (ushort) value;
      shortstore(buffer, data);
    }
    else
    {
      short data= (short) value;
      shortstore(buffer, data);
    }
    *param-&gt;error= val64 != (param-&gt;is_unsigned ? (double) (*(ushort*) buffer):
                                                  (double) (*(short*) buffer));
    break;
  case MYSQL_TYPE_LONG:
    if (param-&gt;is_unsigned)
    {
      uint32 data= (uint32) value;
      longstore(buffer, data);
    }
    else
    {
      int32 data= (int32) value;
      longstore(buffer, data);
    }
    *param-&gt;error= val64 != (param-&gt;is_unsigned ? (double) (*(uint32*) buffer):
                                                  (double) (*(int32*) buffer));
      break;
  case MYSQL_TYPE_LONGLONG:
    if (param-&gt;is_unsigned)
    {
      ulonglong data= (ulonglong) value;
      longlongstore(buffer, data);
    }
    else
    {
      longlong data= (longlong) value;
      longlongstore(buffer, data);
    }
    *param-&gt;error= val64 != (param-&gt;is_unsigned ?
                             ulonglong2double(*(ulonglong*) buffer) :
                             (double) (*(longlong*) buffer));
    break;
  case MYSQL_TYPE_FLOAT:
  {
    float data= (float) value;
    floatstore(buffer, data);
    *param-&gt;error= (*(float*) buffer) != value;
    break;
  }
  case MYSQL_TYPE_DOUBLE:
  {
    doublestore(buffer, value);
    break;
  }
  default:
  {
    /*
      Resort to fetch_string_with_conversion: this should handle
      floating point -&gt; string conversion nicely, honor all typecodes
      and param-&gt;offset possibly set in mysql_stmt_fetch_column
    */
    char buff[FLOATING_POINT_BUFFER];
    size_t len;
    if (field-&gt;decimals &gt;= NOT_FIXED_DEC)
      len= my_gcvt(value, type,
                   (int) MY_MIN(sizeof(buff)-1, param-&gt;buffer_length),
                   buff, NULL);
    else
      len= my_fcvt(value, (int) field-&gt;decimals, buff, NULL);

    if (field-&gt;flags &amp; ZEROFILL_FLAG &amp;&amp; len &lt; field-&gt;length &amp;&amp;
        field-&gt;length &lt; MAX_DOUBLE_STRING_REP_LENGTH - 1)
    {
      bmove_upp((uchar*) buff + field-&gt;length, (uchar*) buff + len,
                len);
      memset(buff, '0', field-&gt;length - len);
      len= field-&gt;length;
    }
    fetch_string_with_conversion(param, buff, len);

    break;
  }
  }
}


/*
  Fetch time/date/datetime to supplied buffer of any type

  SYNOPSIS
    param   output buffer descriptor
    time    column data
*/

static void fetch_datetime_with_conversion(MYSQL_BIND *param,
                                           MYSQL_FIELD *field,
                                           MYSQL_TIME *my_time)
{
  switch (param-&gt;buffer_type) {
  case MYSQL_TYPE_NULL: /* do nothing */
    break;
  case MYSQL_TYPE_DATE:
    *(MYSQL_TIME *)(param-&gt;buffer)= *my_time;
    *param-&gt;error= my_time-&gt;time_type != MYSQL_TIMESTAMP_DATE;
    break;
  case MYSQL_TYPE_TIME:
    *(MYSQL_TIME *)(param-&gt;buffer)= *my_time;
    *param-&gt;error= my_time-&gt;time_type != MYSQL_TIMESTAMP_TIME;
    break;
  case MYSQL_TYPE_DATETIME:
  case MYSQL_TYPE_TIMESTAMP:
    *(MYSQL_TIME *)(param-&gt;buffer)= *my_time;
    /* No error: time and date are compatible with datetime */
    break;
  case MYSQL_TYPE_YEAR:
    shortstore(param-&gt;buffer, my_time-&gt;year);
    *param-&gt;error= 1;
    break;
  case MYSQL_TYPE_FLOAT:
  case MYSQL_TYPE_DOUBLE:
  {
    ulonglong value= TIME_to_ulonglong(my_time);
    fetch_float_with_conversion(param, field,
                                ulonglong2double(value), MY_GCVT_ARG_DOUBLE);
    break;
  }
  case MYSQL_TYPE_TINY:
  case MYSQL_TYPE_SHORT:
  case MYSQL_TYPE_INT24:
  case MYSQL_TYPE_LONG:
  case MYSQL_TYPE_LONGLONG:
  {
    longlong value= (longlong) TIME_to_ulonglong(my_time);
    fetch_long_with_conversion(param, field, value, TRUE);
    break;
  }
  default:
  {
    /*
      Convert time value  to string and delegate the rest to
      fetch_string_with_conversion:
    */
    char buff[MAX_DATE_STRING_REP_LENGTH];
    uint length= my_TIME_to_str(my_time, buff, field-&gt;decimals);
    /* Resort to string conversion */
    fetch_string_with_conversion(param, (char *)buff, length);
    break;
  }
  }
}


/*
  Fetch and convert result set column to output buffer.

  SYNOPSIS
    fetch_result_with_conversion()
    param   output buffer descriptor
    field   column metadata
    row     points to a column of result set tuple in binary format

  DESCRIPTION
    This is a fallback implementation of column fetch used
    if column and output buffer types do not match.
    Increases tuple pointer to point at the next column within the
    tuple.
*/

static void fetch_result_with_conversion(MYSQL_BIND *param, MYSQL_FIELD *field,
                                         uchar **row)
{
  enum enum_field_types field_type= field-&gt;type;
  uint field_is_unsigned= field-&gt;flags &amp; UNSIGNED_FLAG;

  switch (field_type) {
  case MYSQL_TYPE_TINY:
  {
    uchar value= **row;
    /* sic: we need to cast to 'signed char' as 'char' may be unsigned */
    longlong data= field_is_unsigned ? (longlong) value :
                                       (longlong) (signed char) value;
    fetch_long_with_conversion(param, field, data, 0);
    *row+= 1;
    break;
  }
  case MYSQL_TYPE_SHORT:
  case MYSQL_TYPE_YEAR:
  {
    short value= sint2korr(*row);
    longlong data= field_is_unsigned ? (longlong) (unsigned short) value :
                                       (longlong) value;
    fetch_long_with_conversion(param, field, data, 0);
    *row+= 2;
    break;
  }
  case MYSQL_TYPE_INT24: /* mediumint is sent as 4 bytes int */
  case MYSQL_TYPE_LONG:
  {
    int32 value= sint4korr(*row);
    longlong data= field_is_unsigned ? (longlong) (uint32) value :
                                       (longlong) value;
    fetch_long_with_conversion(param, field, data, 0);
    *row+= 4;
    break;
  }
  case MYSQL_TYPE_LONGLONG:
  {
    longlong value= (longlong)sint8korr(*row);
    fetch_long_with_conversion(param, field, value,
                               field-&gt;flags &amp; UNSIGNED_FLAG);
    *row+= 8;
    break;
  }
  case MYSQL_TYPE_FLOAT:
  {
    float value;
    float4get(value,*row);
    fetch_float_with_conversion(param, field, value, MY_GCVT_ARG_FLOAT);
    *row+= 4;
    break;
  }
  case MYSQL_TYPE_DOUBLE:
  {
    double value;
    float8get(value,*row);
    fetch_float_with_conversion(param, field, value, MY_GCVT_ARG_DOUBLE);
    *row+= 8;
    break;
  }
  case MYSQL_TYPE_DATE:
  {
    MYSQL_TIME tm;

    read_binary_date(&amp;tm, row);
    fetch_datetime_with_conversion(param, field, &amp;tm);
    break;
  }
  case MYSQL_TYPE_TIME:
  {
    MYSQL_TIME tm;

    read_binary_time(&amp;tm, row);
    fetch_datetime_with_conversion(param, field, &amp;tm);
    break;
  }
  case MYSQL_TYPE_DATETIME:
  case MYSQL_TYPE_TIMESTAMP:
  {
    MYSQL_TIME tm;

    read_binary_datetime(&amp;tm, row);
    fetch_datetime_with_conversion(param, field, &amp;tm);
    break;
  }
  default:
  {
    ulong length= net_field_length(row);
    fetch_string_with_conversion(param, (char*) *row, length);
    *row+= length;
    break;
  }
  }
}


/*
  Functions to fetch data to application buffers without conversion.

  All functions have the following characteristics:

  SYNOPSIS
    fetch_result_xxx()
    param   MySQL bind param
    pos     Row value

  DESCRIPTION
    These are no-conversion functions, used in binary protocol to store
    rows in application buffers. A function used only if type of binary data
    is compatible with type of application buffer.

  RETURN
    none
*/

static void fetch_result_tinyint(MYSQL_BIND *param, MYSQL_FIELD *field,
                                 uchar **row)
{
  my_bool field_is_unsigned= MY_TEST(field-&gt;flags &amp; UNSIGNED_FLAG);
  uchar data= **row;
  *(uchar *)param-&gt;buffer= data;
  *param-&gt;error= param-&gt;is_unsigned != field_is_unsigned &amp;&amp; data &gt; INT_MAX8;
  (*row)++;
}

static void fetch_result_short(MYSQL_BIND *param, MYSQL_FIELD *field,
                               uchar **row)
{
  my_bool field_is_unsigned= MY_TEST(field-&gt;flags &amp; UNSIGNED_FLAG);
  ushort data= (ushort) sint2korr(*row);
  shortstore(param-&gt;buffer, data);
  *param-&gt;error= param-&gt;is_unsigned != field_is_unsigned &amp;&amp; data &gt; INT_MAX16;
  *row+= 2;
}

static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= MY_TEST(field-&gt;flags &amp; UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param-&gt;buffer, data);
  *param-&gt;error= param-&gt;is_unsigned != field_is_unsigned &amp;&amp; data &gt; INT_MAX32;
  *row+= 4;
}

static void fetch_result_int64(MYSQL_BIND *param,
                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= MY_TEST(field-&gt;flags &amp; UNSIGNED_FLAG);
  ulonglong data= (ulonglong) sint8korr(*row);
  *param-&gt;error= param-&gt;is_unsigned != field_is_unsigned &amp;&amp; data &gt; LONGLONG_MAX;
  longlongstore(param-&gt;buffer, data);
  *row+= 8;
}

static void fetch_result_float(MYSQL_BIND *param,
                               MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                               uchar **row)
{
  float value;
  float4get(value,*row);
  floatstore(param-&gt;buffer, value);
  *row+= 4;
}

static void fetch_result_double(MYSQL_BIND *param,
                                MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                uchar **row)
{
  double value;
  float8get(value,*row);
  doublestore(param-&gt;buffer, value);
  *row+= 8;
}

static void fetch_result_time(MYSQL_BIND *param,
                              MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                              uchar **row)
{
  MYSQL_TIME *tm= (MYSQL_TIME *)param-&gt;buffer;
  read_binary_time(tm, row);
}

static void fetch_result_date(MYSQL_BIND *param,
                              MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                              uchar **row)
{
  MYSQL_TIME *tm= (MYSQL_TIME *)param-&gt;buffer;
  read_binary_date(tm, row);
}

static void fetch_result_datetime(MYSQL_BIND *param,
                                  MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                                  uchar **row)
{
  MYSQL_TIME *tm= (MYSQL_TIME *)param-&gt;buffer;
  read_binary_datetime(tm, row);
}

static void fetch_result_bin(MYSQL_BIND *param,
                             MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                             uchar **row)
{
  ulong length= net_field_length(row);
  ulong copy_length= MY_MIN(length, param-&gt;buffer_length);
  memcpy(param-&gt;buffer, (char *)*row, copy_length);
  *param-&gt;length= length;
  *param-&gt;error= copy_length &lt; length;
  *row+= length;
}

static void fetch_result_str(MYSQL_BIND *param,
                             MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
                             uchar **row)
{
  ulong length= net_field_length(row);
  ulong copy_length= MY_MIN(length, param-&gt;buffer_length);
  memcpy(param-&gt;buffer, (char *)*row, copy_length);
  /* Add an end null if there is room in the buffer */
  if (copy_length != param-&gt;buffer_length)
    ((uchar *)param-&gt;buffer)[copy_length]= '\0';
  *param-&gt;length= length;			/* return total length */
  *param-&gt;error= copy_length &lt; length;
  *row+= length;
}


/*
  functions to calculate max lengths for strings during
  mysql_stmt_store_result()
*/

static void skip_result_fixed(MYSQL_BIND *param,
			      MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
			      uchar **row)

{
  (*row)+= param-&gt;pack_length;
}


static void skip_result_with_length(MYSQL_BIND *param MY_ATTRIBUTE((unused)),
				    MYSQL_FIELD *field MY_ATTRIBUTE((unused)),
				    uchar **row)

{
  ulong length= net_field_length(row);
  (*row)+= length;
}


static void skip_result_string(MYSQL_BIND *param MY_ATTRIBUTE((unused)),
			       MYSQL_FIELD *field,
			       uchar **row)

{
  ulong length= net_field_length(row);
  (*row)+= length;
  if (field-&gt;max_length &lt; length)
    field-&gt;max_length= length;
}


/*
  Check that two field types are binary compatible i. e.
  have equal representation in the binary protocol and
  require client-side buffers of the same type.

  SYNOPSIS
    is_binary_compatible()
    type1   parameter type supplied by user
    type2   field type, obtained from result set metadata

  RETURN
    TRUE or FALSE
*/

static my_bool is_binary_compatible(enum enum_field_types type1,
                                    enum enum_field_types type2)
{
  static const enum enum_field_types
    range1[]= { MYSQL_TYPE_SHORT, MYSQL_TYPE_YEAR, MYSQL_TYPE_NULL },
    range2[]= { MYSQL_TYPE_INT24, MYSQL_TYPE_LONG, MYSQL_TYPE_NULL },
    range3[]= { MYSQL_TYPE_DATETIME, MYSQL_TYPE_TIMESTAMP, MYSQL_TYPE_NULL },
    range4[]= { MYSQL_TYPE_ENUM, MYSQL_TYPE_SET, MYSQL_TYPE_TINY_BLOB,
                MYSQL_TYPE_MEDIUM_BLOB, MYSQL_TYPE_LONG_BLOB, MYSQL_TYPE_BLOB,
                MYSQL_TYPE_VAR_STRING, MYSQL_TYPE_STRING, MYSQL_TYPE_GEOMETRY,
                MYSQL_TYPE_DECIMAL, MYSQL_TYPE_NULL };
  static const enum enum_field_types
   *range_list[]= { range1, range2, range3, range4 },
   **range_list_end= range_list + sizeof(range_list)/sizeof(*range_list);
   const enum enum_field_types **range, *type;

  if (type1 == type2)
    return TRUE;
  for (range= range_list; range != range_list_end; ++range)
  {
    /* check that both type1 and type2 are in the same range */
    my_bool type1_found= FALSE, type2_found= FALSE;
    for (type= *range; *type != MYSQL_TYPE_NULL; type++)
    {
      type1_found|= type1 == *type;
      type2_found|= type2 == *type;
    }
    if (type1_found || type2_found)
      return type1_found &amp;&amp; type2_found;
  }
  return FALSE;
}


/*
  Setup a fetch function for one column of a result set.

  SYNOPSIS
    setup_one_fetch_function()
    param    output buffer descriptor
    field    column descriptor

  DESCRIPTION
    When user binds result set buffers or when result set
    metadata is changed, we need to setup fetch (and possibly
    conversion) functions for all columns of the result set.
    In addition to that here we set up skip_result function, used
    to update result set metadata in case when
    STMT_ATTR_UPDATE_MAX_LENGTH attribute is set.
    Notice that while fetch_result is chosen depending on both
    field-&gt;type and param-&gt;type, skip_result depends on field-&gt;type
    only.

  RETURN
    TRUE   fetch function for this typecode was not found (typecode
          is not supported by the client library)
    FALSE  success
*/

static my_bool setup_one_fetch_function(MYSQL_BIND *param, MYSQL_FIELD *field)
{
  DBUG_ENTER("setup_one_fetch_function");

  /* Setup data copy functions for the different supported types */
  switch (param-&gt;buffer_type) {
  case MYSQL_TYPE_NULL: /* for dummy binds */
    /*
      It's not binary compatible with anything the server can return:
      no need to setup fetch_result, as it'll be reset anyway
    */
    *param-&gt;length= 0;
    break;
  case MYSQL_TYPE_TINY:
    param-&gt;fetch_result= fetch_result_tinyint;
    *param-&gt;length= 1;
    break;
  case MYSQL_TYPE_SHORT:
  case MYSQL_TYPE_YEAR:
    param-&gt;fetch_result= fetch_result_short;
    *param-&gt;length= 2;
    break;
  case MYSQL_TYPE_INT24:
  case MYSQL_TYPE_LONG:
    param-&gt;fetch_result= fetch_result_int32;
    *param-&gt;length= 4;
    break;
  case MYSQL_TYPE_LONGLONG:
    param-&gt;fetch_result= fetch_result_int64;
    *param-&gt;length= 8;
    break;
  case MYSQL_TYPE_FLOAT:
    param-&gt;fetch_result= fetch_result_float;
    *param-&gt;length= 4;
    break;
  case MYSQL_TYPE_DOUBLE:
    param-&gt;fetch_result= fetch_result_double;
    *param-&gt;length= 8;
    break;
  case MYSQL_TYPE_TIME:
    param-&gt;fetch_result= fetch_result_time;
    *param-&gt;length= sizeof(MYSQL_TIME);
    break;
  case MYSQL_TYPE_DATE:
    param-&gt;fetch_result= fetch_result_date;
    *param-&gt;length= sizeof(MYSQL_TIME);
    break;
  case MYSQL_TYPE_DATETIME:
  case MYSQL_TYPE_TIMESTAMP:
    param-&gt;fetch_result= fetch_result_datetime;
    *param-&gt;length= sizeof(MYSQL_TIME);
    break;
  case MYSQL_TYPE_TINY_BLOB:
  case MYSQL_TYPE_MEDIUM_BLOB:
  case MYSQL_TYPE_LONG_BLOB:
  case MYSQL_TYPE_BLOB:
  case MYSQL_TYPE_BIT:
    DBUG_ASSERT(param-&gt;buffer_length != 0);
    param-&gt;fetch_result= fetch_result_bin;
    break;
  case MYSQL_TYPE_VAR_STRING:
  case MYSQL_TYPE_STRING:
  case MYSQL_TYPE_DECIMAL:
  case MYSQL_TYPE_NEWDECIMAL:
  case MYSQL_TYPE_NEWDATE:
    DBUG_ASSERT(param-&gt;buffer_length != 0);
    param-&gt;fetch_result= fetch_result_str;
    break;
  default:
    DBUG_PRINT("error", ("Unknown param-&gt;buffer_type: %u",
                         (uint) param-&gt;buffer_type));
    DBUG_RETURN(TRUE);
  }
  if (! is_binary_compatible(param-&gt;buffer_type, field-&gt;type))
    param-&gt;fetch_result= fetch_result_with_conversion;

  /* Setup skip_result functions (to calculate max_length) */
  param-&gt;skip_result= skip_result_fixed;
  switch (field-&gt;type) {
  case MYSQL_TYPE_NULL: /* for dummy binds */
    param-&gt;pack_length= 0;
    field-&gt;max_length= 0;
    break;
  case MYSQL_TYPE_TINY:
    param-&gt;pack_length= 1;
    field-&gt;max_length= 4;                     /* as in '-127' */
    break;
  case MYSQL_TYPE_YEAR:
  case MYSQL_TYPE_SHORT:
    param-&gt;pack_length= 2;
    field-&gt;max_length= 6;                     /* as in '-32767' */
    break;
  case MYSQL_TYPE_INT24:
    field-&gt;max_length= 9;  /* as in '16777216' or in '-8388607' */
    param-&gt;pack_length= 4;
    break;
  case MYSQL_TYPE_LONG:
    field-&gt;max_length= 11;                    /* '-2147483647' */
    param-&gt;pack_length= 4;
    break;
  case MYSQL_TYPE_LONGLONG:
    field-&gt;max_length= 21;                    /* '18446744073709551616' */
    param-&gt;pack_length= 8;
    break;
  case MYSQL_TYPE_FLOAT:
    param-&gt;pack_length= 4;
    field-&gt;max_length= MAX_DOUBLE_STRING_REP_LENGTH;
    break;
  case MYSQL_TYPE_DOUBLE:
    param-&gt;pack_length= 8;
    field-&gt;max_length= MAX_DOUBLE_STRING_REP_LENGTH;
    break;
  case MYSQL_TYPE_TIME:
    field-&gt;max_length= 17;                    /* -819:23:48.123456 */
    param-&gt;skip_result= skip_result_with_length;
    break;
  case MYSQL_TYPE_DATE:
    field-&gt;max_length= 10;                    /* 2003-11-11 */
    param-&gt;skip_result= skip_result_with_length;
    break;
  case MYSQL_TYPE_DATETIME:
  case MYSQL_TYPE_TIMESTAMP:
    param-&gt;skip_result= skip_result_with_length;
    field-&gt;max_length= MAX_DATE_STRING_REP_LENGTH;
    break;
  case MYSQL_TYPE_DECIMAL:
  case MYSQL_TYPE_NEWDECIMAL:
  case MYSQL_TYPE_ENUM:
  case MYSQL_TYPE_SET:
  case MYSQL_TYPE_GEOMETRY:
  case MYSQL_TYPE_TINY_BLOB:
  case MYSQL_TYPE_MEDIUM_BLOB:
  case MYSQL_TYPE_LONG_BLOB:
  case MYSQL_TYPE_BLOB:
  case MYSQL_TYPE_VAR_STRING:
  case MYSQL_TYPE_STRING:
  case MYSQL_TYPE_BIT:
  case MYSQL_TYPE_NEWDATE:
    param-&gt;skip_result= skip_result_string;
    break;
  default:
    DBUG_PRINT("error", ("Unknown field-&gt;type: %u", (uint) field-&gt;type));
    DBUG_RETURN(TRUE);
  }
  DBUG_RETURN(FALSE);
}


/*
  Setup the bind buffers for resultset processing
*/

my_bool STDCALL mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
{
  MYSQL_BIND *param, *end;
  MYSQL_FIELD *field;
  ulong       bind_count= stmt-&gt;field_count;
  uint        param_count= 0;
  DBUG_ENTER("mysql_stmt_bind_result");
  DBUG_PRINT("enter",("field_count: %lu", bind_count));

  if (!bind_count)
  {
    int errorcode= (int) stmt-&gt;state &lt; (int) MYSQL_STMT_PREPARE_DONE ?
                   CR_NO_PREPARE_STMT : CR_NO_STMT_METADATA;
    set_stmt_error(stmt, errorcode, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  /*
    We only need to check that stmt-&gt;field_count - if it is not null
    stmt-&gt;bind was initialized in mysql_stmt_prepare
    stmt-&gt;bind overlaps with bind if mysql_stmt_bind_param
    is called from mysql_stmt_store_result.
    BEWARE of buffer overwrite ...
  */

  if (stmt-&gt;bind != my_bind)
    memcpy((char*) stmt-&gt;bind, (char*) my_bind,
           sizeof(MYSQL_BIND) * bind_count);

  for (param= stmt-&gt;bind, end= param + bind_count, field= stmt-&gt;fields ;
       param &lt; end ;
       param++, field++)
  {
    DBUG_PRINT("info",("buffer_type: %u  field_type: %u",
                       (uint) param-&gt;buffer_type, (uint) field-&gt;type));
    /*
      Set param-&gt;is_null to point to a dummy variable if it's not set.
      This is to make the execute code easier
    */
    if (!param-&gt;is_null)
      param-&gt;is_null= &amp;param-&gt;is_null_value;

    if (!param-&gt;length)
      param-&gt;length= &amp;param-&gt;length_value;

    if (!param-&gt;error)
      param-&gt;error= &amp;param-&gt;error_value;

    param-&gt;param_number= param_count++;
    param-&gt;offset= 0;

    if (setup_one_fetch_function(param, field))
    {
      strmov(stmt-&gt;sqlstate, unknown_sqlstate);
      sprintf(stmt-&gt;last_error,
              ER(stmt-&gt;last_errno= CR_UNSUPPORTED_PARAM_TYPE),
              field-&gt;type, param_count);
      DBUG_RETURN(1);
    }
  }
  stmt-&gt;bind_result_done= BIND_RESULT_DONE;
  if (stmt-&gt;mysql-&gt;options.report_data_truncation)
    stmt-&gt;bind_result_done|= REPORT_DATA_TRUNCATION;

  DBUG_RETURN(0);
}


/*
  Fetch row data to bind buffers
*/

static int stmt_fetch_row(MYSQL_STMT *stmt, uchar *row)
{
  MYSQL_BIND  *my_bind, *end;
  MYSQL_FIELD *field;
  uchar *null_ptr, bit;
  int truncation_count= 0;
  /*
    Precondition: if stmt-&gt;field_count is zero or row is NULL, read_row_*
    function must return no data.
  */
  DBUG_ASSERT(stmt-&gt;field_count);
  DBUG_ASSERT(row);

  if (!stmt-&gt;bind_result_done)
  {
    /* If output parameters were not bound we should just return success */
    return 0;
  }

  null_ptr= row;
  row+= (stmt-&gt;field_count+9)/8;		/* skip null bits */
  bit= 4;					/* first 2 bits are reserved */

  /* Copy complete row to application buffers */
  for (my_bind= stmt-&gt;bind, end= my_bind + stmt-&gt;field_count,
         field= stmt-&gt;fields ;
       my_bind &lt; end ;
       my_bind++, field++)
  {
    *my_bind-&gt;error= 0;
    if (*null_ptr &amp; bit)
    {
      /*
        We should set both row_ptr and is_null to be able to see
        nulls in mysql_stmt_fetch_column. This is because is_null may point
        to user data which can be overwritten between mysql_stmt_fetch and
        mysql_stmt_fetch_column, and in this case nullness of column will be
        lost. See mysql_stmt_fetch_column for details.
      */
      my_bind-&gt;row_ptr= NULL;
      *my_bind-&gt;is_null= 1;
    }
    else
    {
      *my_bind-&gt;is_null= 0;
      my_bind-&gt;row_ptr= row;
      (*my_bind-&gt;fetch_result)(my_bind, field, &amp;row);
      truncation_count+= *my_bind-&gt;error;
    }
    if (!((bit&lt;&lt;=1) &amp; 255))
    {
      bit= 1;					/* To next uchar */
      null_ptr++;
    }
  }
  if (truncation_count &amp;&amp; (stmt-&gt;bind_result_done &amp; REPORT_DATA_TRUNCATION))
    return MYSQL_DATA_TRUNCATED;
  return 0;
}


int cli_unbuffered_fetch(MYSQL *mysql, char **row)
{
  if (packet_error == cli_safe_read(mysql))
    return 1;

  *row= ((mysql-&gt;net.read_pos[0] == 254) ? NULL :
	 (char*) (mysql-&gt;net.read_pos+1));
  return 0;
}


/*
  Fetch and return row data to bound buffers, if any
*/

int STDCALL mysql_stmt_fetch(MYSQL_STMT *stmt)
{
  int rc;
  uchar *row;
  DBUG_ENTER("mysql_stmt_fetch");

  if ((rc= (*stmt-&gt;read_row_func)(stmt, &amp;row)) ||
      ((rc= stmt_fetch_row(stmt, row)) &amp;&amp; rc != MYSQL_DATA_TRUNCATED))
  {
    stmt-&gt;state= MYSQL_STMT_PREPARE_DONE;       /* XXX: this is buggy */
    stmt-&gt;read_row_func= (rc == MYSQL_NO_DATA) ? 
      stmt_read_row_no_data : stmt_read_row_no_result_set;
  }
  else
  {
    /* This is to know in mysql_stmt_fetch_column that data was fetched */
    stmt-&gt;state= MYSQL_STMT_FETCH_DONE;
  }
  DBUG_RETURN(rc);
}


/*
  Fetch data for one specified column data

  SYNOPSIS
    mysql_stmt_fetch_column()
    stmt		Prepared statement handler
    my_bind		Where data should be placed. Should be filled in as
			when calling mysql_stmt_bind_result()
    column		Column to fetch (first column is 0)
    ulong offset	Offset in result data (to fetch blob in pieces)
			This is normally 0
  RETURN
    0	ok
    1	error
*/

int STDCALL mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *my_bind,
                                    uint column, ulong offset)
{
  MYSQL_BIND *param= stmt-&gt;bind+column;
  DBUG_ENTER("mysql_stmt_fetch_column");

  if ((int) stmt-&gt;state &lt; (int) MYSQL_STMT_FETCH_DONE)
  {
    set_stmt_error(stmt, CR_NO_DATA, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }
  if (column &gt;= stmt-&gt;field_count)
  {
    set_stmt_error(stmt, CR_INVALID_PARAMETER_NO, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  if (!my_bind-&gt;error)
    my_bind-&gt;error= &amp;my_bind-&gt;error_value;
  *my_bind-&gt;error= 0;
  if (param-&gt;row_ptr)
  {
    MYSQL_FIELD *field= stmt-&gt;fields+column;
    uchar *row= param-&gt;row_ptr;
    my_bind-&gt;offset= offset;
    if (my_bind-&gt;is_null)
      *my_bind-&gt;is_null= 0;
    if (my_bind-&gt;length) /* Set the length if non char/binary types */
      *my_bind-&gt;length= *param-&gt;length;
    else
      my_bind-&gt;length= &amp;param-&gt;length_value;       /* Needed for fetch_result() */
    fetch_result_with_conversion(my_bind, field, &amp;row);
  }
  else
  {
    if (my_bind-&gt;is_null)
      *my_bind-&gt;is_null= 1;
  }
  DBUG_RETURN(0);
}


/*
  Read all rows of data from server  (binary format)
*/

int cli_read_binary_rows(MYSQL_STMT *stmt)
{
  ulong      pkt_len;
  uchar      *cp;
  MYSQL      *mysql= stmt-&gt;mysql;
  MYSQL_DATA *result= &amp;stmt-&gt;result;
  MYSQL_ROWS *cur, **prev_ptr= &amp;result-&gt;data;
  NET        *net;

  DBUG_ENTER("cli_read_binary_rows");

  if (!mysql)
  {
    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  net = &amp;mysql-&gt;net;

  while ((pkt_len= cli_safe_read(mysql)) != packet_error)
  {
    cp= net-&gt;read_pos;
    if (cp[0] != 254 || pkt_len &gt;= 8)
    {
      if (!(cur= (MYSQL_ROWS*) alloc_root(&amp;result-&gt;alloc,
                                          sizeof(MYSQL_ROWS) + pkt_len - 1)))
      {
        set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
        goto err;
      }
      cur-&gt;data= (MYSQL_ROW) (cur+1);
      *prev_ptr= cur;
      prev_ptr= &amp;cur-&gt;next;
      memcpy((char *) cur-&gt;data, (char *) cp+1, pkt_len-1);
      cur-&gt;length= pkt_len;		/* To allow us to do sanity checks */
      result-&gt;rows++;
    }
    else
    {
      /* end of data */
      *prev_ptr= 0;
      mysql-&gt;warning_count= uint2korr(cp+1);
      /*
        OUT parameters result sets has SERVER_PS_OUT_PARAMS and
        SERVER_MORE_RESULTS_EXISTS flags in first EOF_Packet only.
        Last EOF_Packet of OUT parameters result sets have no
        SERVER_MORE_RESULTS_EXISTS flag as described here:
        http://dev.mysql.com/doc/internals/en/stored-procedures.html#out-parameter-set
        Following code reads last EOF_Packet of result set and can clear
        those flags in server_status if we don't preserve them.
        Without SERVER_MORE_RESULTS_EXISTS flag mysql_stmt_next_result fails
        to read OK_Packet after OUT parameters result set.
        So we need to preserve SERVER_MORE_RESULTS_EXISTS flag for OUT
        parameters result set.
      */
      if (mysql-&gt;server_status &amp; SERVER_PS_OUT_PARAMS)
      {
        mysql-&gt;server_status= uint2korr(cp+3)
          | SERVER_PS_OUT_PARAMS
          | (mysql-&gt;server_status &amp; SERVER_MORE_RESULTS_EXISTS);
      }
      else
        mysql-&gt;server_status= uint2korr(cp+3);
      DBUG_PRINT("info",("status: %u  warning_count: %u",
                         mysql-&gt;server_status, mysql-&gt;warning_count));
      DBUG_RETURN(0);
    }
  }
  set_stmt_errmsg(stmt, net);

err:
  DBUG_RETURN(1);
}


/*
  Update meta data for statement

  SYNOPSIS
    stmt_update_metadata()
    stmt			Statement handler
    row				Binary data

  NOTES
    Only updates MYSQL_FIELD-&gt;max_length for strings
*/

static void stmt_update_metadata(MYSQL_STMT *stmt, MYSQL_ROWS *data)
{
  MYSQL_BIND  *my_bind, *end;
  MYSQL_FIELD *field;
  uchar *null_ptr, bit;
  uchar *row= (uchar*) data-&gt;data;
#ifndef DBUG_OFF
  uchar *row_end= row + data-&gt;length;
#endif

  null_ptr= row;
  row+= (stmt-&gt;field_count+9)/8;		/* skip null bits */
  bit= 4;					/* first 2 bits are reserved */

  /* Go through all fields and calculate metadata */
  for (my_bind= stmt-&gt;bind, end= my_bind + stmt-&gt;field_count, field= stmt-&gt;fields ;
       my_bind &lt; end ;
       my_bind++, field++)
  {
    if (!(*null_ptr &amp; bit))
      (*my_bind-&gt;skip_result)(my_bind, field, &amp;row);
    DBUG_ASSERT(row &lt;= row_end);
    if (!((bit&lt;&lt;=1) &amp; 255))
    {
      bit= 1;					/* To next uchar */
      null_ptr++;
    }
  }
}


/*
  Store or buffer the binary results to stmt
*/

int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
{
  MYSQL *mysql= stmt-&gt;mysql;
  MYSQL_DATA *result= &amp;stmt-&gt;result;
  DBUG_ENTER("mysql_stmt_store_result");

  if (!mysql)
  {
    /* mysql can be reset in mysql_close called from mysql_reconnect */
    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  if (!stmt-&gt;field_count)
    DBUG_RETURN(0);

  if ((int) stmt-&gt;state &lt; (int) MYSQL_STMT_EXECUTE_DONE)
  {
    set_stmt_error(stmt, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  if (stmt-&gt;last_errno)
  {
    /* An attempt to use an invalid statement handle. */
    DBUG_RETURN(1);
  }

  if (mysql-&gt;status == MYSQL_STATUS_READY &amp;&amp;
      stmt-&gt;server_status &amp; SERVER_STATUS_CURSOR_EXISTS)
  {
    /*
      Server side cursor exist, tell server to start sending the rows
    */
    NET *net= &amp;mysql-&gt;net;
    uchar buff[4 /* statement id */ +
               4 /* number of rows to fetch */];

    /* Send row request to the server */
    int4store(buff, stmt-&gt;stmt_id);
    int4store(buff + 4, (int)~0); /* number of rows to fetch */
    if (cli_advanced_command(mysql, COM_STMT_FETCH, buff, sizeof(buff),
                             (uchar*) 0, 0, 1, stmt))
    {
      /* 
        Don't set stmt error if stmt-&gt;mysql is NULL, as the error in this case 
        has already been set by mysql_prune_stmt_list(). 
      */
      if (stmt-&gt;mysql)
        set_stmt_errmsg(stmt, net);
      DBUG_RETURN(1);
    }
  }
  else if (mysql-&gt;status != MYSQL_STATUS_STATEMENT_GET_RESULT)
  {
    set_stmt_error(stmt, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }

  if (stmt-&gt;update_max_length &amp;&amp; !stmt-&gt;bind_result_done)
  {
    /*
      We must initalize the bind structure to be able to calculate
      max_length
    */
    MYSQL_BIND  *my_bind, *end;
    MYSQL_FIELD *field;
    memset(stmt-&gt;bind, 0, sizeof(*stmt-&gt;bind) * stmt-&gt;field_count);

    for (my_bind= stmt-&gt;bind, end= my_bind + stmt-&gt;field_count,
           field= stmt-&gt;fields;
	 my_bind &lt; end ;
	 my_bind++, field++)
    {
      my_bind-&gt;buffer_type= MYSQL_TYPE_NULL;
      my_bind-&gt;buffer_length=1;
    }

    if (mysql_stmt_bind_result(stmt, stmt-&gt;bind))
      DBUG_RETURN(1);
    stmt-&gt;bind_result_done= 0;			/* No normal bind done */
  }

  if ((*mysql-&gt;methods-&gt;read_binary_rows)(stmt))
  {
    free_root(&amp;result-&gt;alloc, MYF(MY_KEEP_PREALLOC));
    result-&gt;data= NULL;
    result-&gt;rows= 0;
    mysql-&gt;status= MYSQL_STATUS_READY;
    DBUG_RETURN(1);
  }

  /* Assert that if there was a cursor, all rows have been fetched */
  DBUG_ASSERT(mysql-&gt;status != MYSQL_STATUS_READY ||
              (mysql-&gt;server_status &amp; SERVER_STATUS_LAST_ROW_SENT));

  if (stmt-&gt;update_max_length)
  {
    MYSQL_ROWS *cur= result-&gt;data;
    for(; cur; cur=cur-&gt;next)
      stmt_update_metadata(stmt, cur);
  }

  stmt-&gt;data_cursor= result-&gt;data;
  mysql-&gt;affected_rows= stmt-&gt;affected_rows= result-&gt;rows;
  stmt-&gt;read_row_func= stmt_read_row_buffered;
  mysql-&gt;unbuffered_fetch_owner= 0;             /* set in stmt_execute */
  mysql-&gt;status= MYSQL_STATUS_READY;		/* server is ready */
  DBUG_RETURN(0); /* Data buffered, must be fetched with mysql_stmt_fetch() */
}


/*
  Seek to desired row in the statement result set
*/

MYSQL_ROW_OFFSET STDCALL
mysql_stmt_row_seek(MYSQL_STMT *stmt, MYSQL_ROW_OFFSET row)
{
  MYSQL_ROW_OFFSET offset= stmt-&gt;data_cursor;
  DBUG_ENTER("mysql_stmt_row_seek");

  stmt-&gt;data_cursor= row;
  DBUG_RETURN(offset);
}


/*
  Return the current statement row cursor position
*/

MYSQL_ROW_OFFSET STDCALL
mysql_stmt_row_tell(MYSQL_STMT *stmt)
{
  DBUG_ENTER("mysql_stmt_row_tell");

  DBUG_RETURN(stmt-&gt;data_cursor);
}


/*
  Move the stmt result set data cursor to specified row
*/

void STDCALL
mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong row)
{
  MYSQL_ROWS *tmp= stmt-&gt;result.data;
  DBUG_ENTER("mysql_stmt_data_seek");
  DBUG_PRINT("enter",("row id to seek: %ld",(long) row));

  for (; tmp &amp;&amp; row; --row, tmp= tmp-&gt;next)
    ;
  stmt-&gt;data_cursor= tmp;
  if (!row &amp;&amp; tmp)
  {
       /*  Rewind the counter */
    stmt-&gt;read_row_func= stmt_read_row_buffered;
    stmt-&gt;state= MYSQL_STMT_EXECUTE_DONE;
  }
  DBUG_VOID_RETURN;
}


/*
  Return total rows the current statement result set
*/

my_ulonglong STDCALL mysql_stmt_num_rows(MYSQL_STMT *stmt)
{
  DBUG_ENTER("mysql_stmt_num_rows");

  DBUG_RETURN(stmt-&gt;result.rows);
}


/*
  Free the client side memory buffers, reset long data state
  on client if necessary, and reset the server side statement if
  this has been requested.
*/

static my_bool reset_stmt_handle(MYSQL_STMT *stmt, uint flags)
{
  /* If statement hasn't been prepared there is nothing to reset */
  if ((int) stmt-&gt;state &gt; (int) MYSQL_STMT_INIT_DONE)
  {
    MYSQL *mysql= stmt-&gt;mysql;
    MYSQL_DATA *result= &amp;stmt-&gt;result;

    /*
      Reset stored result set if so was requested or it's a part
      of cursor fetch.
    */
    if (flags &amp; RESET_STORE_RESULT)
    {
      /* Result buffered */
      free_root(&amp;result-&gt;alloc, MYF(MY_KEEP_PREALLOC));
      result-&gt;data= NULL;
      result-&gt;rows= 0;
      stmt-&gt;data_cursor= NULL;
    }
    if (flags &amp; RESET_LONG_DATA)
    {
      MYSQL_BIND *param= stmt-&gt;params, *param_end= param + stmt-&gt;param_count;
      /* Clear long_data_used flags */
      for (; param &lt; param_end; param++)
        param-&gt;long_data_used= 0;
    }
    stmt-&gt;read_row_func= stmt_read_row_no_result_set;
    if (mysql)
    {
      if ((int) stmt-&gt;state &gt; (int) MYSQL_STMT_PREPARE_DONE)
      {
        if (mysql-&gt;unbuffered_fetch_owner == &amp;stmt-&gt;unbuffered_fetch_cancelled)
          mysql-&gt;unbuffered_fetch_owner= 0;
        if (stmt-&gt;field_count &amp;&amp; mysql-&gt;status != MYSQL_STATUS_READY)
        {
          /* There is a result set and it belongs to this statement */
          (*mysql-&gt;methods-&gt;flush_use_result)(mysql, FALSE);
          if (mysql-&gt;unbuffered_fetch_owner)
            *mysql-&gt;unbuffered_fetch_owner= TRUE;
          mysql-&gt;status= MYSQL_STATUS_READY;
        }
      }
      if (flags &amp; RESET_SERVER_SIDE)
      {
        /*
          Reset the server side statement and close the server side
          cursor if it exists.
        */
        uchar buff[MYSQL_STMT_HEADER]; /* packet header: 4 bytes for stmt id */
        int4store(buff, stmt-&gt;stmt_id);
        if ((*mysql-&gt;methods-&gt;advanced_command)(mysql, COM_STMT_RESET, buff,
                                                sizeof(buff), 0, 0, 0, stmt))
        {
          set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
          stmt-&gt;state= MYSQL_STMT_INIT_DONE;
          return 1;
        }
      }
    }
    if (flags &amp; RESET_CLEAR_ERROR)
      stmt_clear_error(stmt);
    stmt-&gt;state= MYSQL_STMT_PREPARE_DONE;
  }
  return 0;
}

my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)
{
  DBUG_ENTER("mysql_stmt_free_result");

  /* Free the client side and close the server side cursor if there is one */
  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |
                                RESET_CLEAR_ERROR));
}

/********************************************************************
 statement error handling and close
*********************************************************************/

/*
  Close the statement handle by freeing all alloced resources

  SYNOPSIS
    mysql_stmt_close()
    stmt	       Statement handle

  RETURN VALUES
    0	ok
    1	error
*/

my_bool STDCALL mysql_stmt_close(MYSQL_STMT *stmt)
{
  MYSQL *mysql= stmt-&gt;mysql;
  int rc= 0;
  DBUG_ENTER("mysql_stmt_close");

  free_root(&amp;stmt-&gt;result.alloc, MYF(0));
  free_root(&amp;stmt-&gt;mem_root, MYF(0));
  free_root(&amp;stmt-&gt;extension-&gt;fields_mem_root, MYF(0));

  if (mysql)
  {
    mysql-&gt;stmts= list_delete(mysql-&gt;stmts, &amp;stmt-&gt;list);
    /*
      Clear NET error state: if the following commands come through
      successfully, connection will still be usable for other commands.
    */
    net_clear_error(&amp;mysql-&gt;net);
    if ((int) stmt-&gt;state &gt; (int) MYSQL_STMT_INIT_DONE)
    {
      uchar buff[MYSQL_STMT_HEADER];             /* 4 bytes - stmt id */

      if (mysql-&gt;unbuffered_fetch_owner == &amp;stmt-&gt;unbuffered_fetch_cancelled)
        mysql-&gt;unbuffered_fetch_owner= 0;
      if (mysql-&gt;status != MYSQL_STATUS_READY)
      {
        /*
          Flush result set of the connection. If it does not belong
          to this statement, set a warning.
        */
        (*mysql-&gt;methods-&gt;flush_use_result)(mysql, TRUE);
        if (mysql-&gt;unbuffered_fetch_owner)
          *mysql-&gt;unbuffered_fetch_owner= TRUE;
        mysql-&gt;status= MYSQL_STATUS_READY;
      }
      int4store(buff, stmt-&gt;stmt_id);
      /*
        If stmt_command failed, it would have already raised
        error using set_mysql_error. Caller should use
        mysql_error() or mysql_errno() to find out details.
        Memory allocated for stmt will be released regardless
        of the error.
      */
      rc= stmt_command(mysql, COM_STMT_CLOSE, buff, 4, stmt);
    }
  }

  my_free(stmt-&gt;extension);
  my_free(stmt);

  DBUG_RETURN(MY_TEST(rc));
}

/*
  Reset the statement buffers in server
*/

my_bool STDCALL mysql_stmt_reset(MYSQL_STMT *stmt)
{
  DBUG_ENTER("mysql_stmt_reset");
  DBUG_ASSERT(stmt != 0);
  if (!stmt-&gt;mysql)
  {
    /* mysql can be reset in mysql_close called from mysql_reconnect */
    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);
    DBUG_RETURN(1);
  }
  /* Reset the client and server sides of the prepared statement */
  DBUG_RETURN(reset_stmt_handle(stmt,
                                RESET_SERVER_SIDE | RESET_LONG_DATA |
                                RESET_CLEAR_ERROR));
}

/*
  Return statement error code
*/

uint STDCALL mysql_stmt_errno(MYSQL_STMT * stmt)
{
  DBUG_ENTER("mysql_stmt_errno");
  DBUG_RETURN(stmt-&gt;last_errno);
}

const char *STDCALL mysql_stmt_sqlstate(MYSQL_STMT * stmt)
{
  DBUG_ENTER("mysql_stmt_sqlstate");
  DBUG_RETURN(stmt-&gt;sqlstate);
}

/*
  Return statement error message
*/

const char *STDCALL mysql_stmt_error(MYSQL_STMT * stmt)
{
  DBUG_ENTER("mysql_stmt_error");
  DBUG_RETURN(stmt-&gt;last_error);
}


/********************************************************************
 Transactional APIs
*********************************************************************/

/*
  Commit the current transaction
*/

my_bool STDCALL mysql_commit(MYSQL * mysql)
{
  DBUG_ENTER("mysql_commit");
  DBUG_RETURN((my_bool) mysql_real_query(mysql, "commit", 6));
}

/*
  Rollback the current transaction
*/

my_bool STDCALL mysql_rollback(MYSQL * mysql)
{
  DBUG_ENTER("mysql_rollback");
  DBUG_RETURN((my_bool) mysql_real_query(mysql, "rollback", 8));
}


/*
  Set autocommit to either true or false
*/

my_bool STDCALL mysql_autocommit(MYSQL * mysql, my_bool auto_mode)
{
  DBUG_ENTER("mysql_autocommit");
  DBUG_PRINT("enter", ("mode : %d", auto_mode));

  DBUG_RETURN((my_bool) mysql_real_query(mysql, auto_mode ?
                                         "set autocommit=1":"set autocommit=0",
                                         16));
}


/********************************************************************
 Multi query execution + SPs APIs
*********************************************************************/

/*
  Returns true/false to indicate whether any more query results exist
  to be read using mysql_next_result()
*/

my_bool STDCALL mysql_more_results(MYSQL *mysql)
{
  my_bool res;
  DBUG_ENTER("mysql_more_results");

  res= ((mysql-&gt;server_status &amp; SERVER_MORE_RESULTS_EXISTS) ? 1: 0);
  DBUG_PRINT("exit",("More results exists ? %d", res));
  DBUG_RETURN(res);
}


/*
  Reads and returns the next query results
*/
int STDCALL mysql_next_result(MYSQL *mysql)
{
  DBUG_ENTER("mysql_next_result");

  if (mysql-&gt;status != MYSQL_STATUS_READY)
  {
    set_mysql_error(mysql, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate);
    DBUG_RETURN(1);
  }

  net_clear_error(&amp;mysql-&gt;net);
  mysql-&gt;affected_rows= ~(my_ulonglong) 0;

  if (mysql-&gt;server_status &amp; SERVER_MORE_RESULTS_EXISTS)
    DBUG_RETURN((*mysql-&gt;methods-&gt;next_result)(mysql));

  DBUG_RETURN(-1);				/* No more results */
}


int STDCALL mysql_stmt_next_result(MYSQL_STMT *stmt)
{
  MYSQL *mysql= stmt-&gt;mysql;
  int rc;
  DBUG_ENTER("mysql_stmt_next_result");

  if (!mysql)
    DBUG_RETURN(1);

  if (stmt-&gt;last_errno)
    DBUG_RETURN(stmt-&gt;last_errno);

  if (mysql-&gt;server_status &amp; SERVER_MORE_RESULTS_EXISTS)
  {
    if (reset_stmt_handle(stmt, RESET_STORE_RESULT))
      DBUG_RETURN(1);
  }

  rc= mysql_next_result(mysql);

  if (rc)
  {
    set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
    DBUG_RETURN(rc);
  }

  if (mysql-&gt;status == MYSQL_STATUS_GET_RESULT)
    mysql-&gt;status= MYSQL_STATUS_STATEMENT_GET_RESULT;

  stmt-&gt;state= MYSQL_STMT_EXECUTE_DONE;
  stmt-&gt;bind_result_done= FALSE;
  stmt-&gt;field_count= mysql-&gt;field_count;

  if (mysql-&gt;field_count)
  {
    alloc_stmt_fields(stmt);
    prepare_to_fetch_result(stmt);
  }

  DBUG_RETURN(0);
}


MYSQL_RES * STDCALL mysql_use_result(MYSQL *mysql)
{
  return (*mysql-&gt;methods-&gt;use_result)(mysql);
}

my_bool STDCALL mysql_read_query_result(MYSQL *mysql)
{
  return (*mysql-&gt;methods-&gt;read_query_result)(mysql);
}

#if defined(EXPORT_SYMVER16)
#ifndef EMBEDDED_LIBRARY

// Hack to provide both libmysqlclient_16 and libmysqlclient_18 symbol versions

#define SYM_16(_exportedsym) __asm__(".symver symver16_" #_exportedsym "," #_exportedsym "@libmysqlclient_16")

void STDCALL symver16_myodbc_remove_escape(MYSQL *mysql,char *name)
{
  return myodbc_remove_escape(mysql, name);
}
SYM_16(myodbc_remove_escape);


my_ulonglong STDCALL symver16_mysql_affected_rows(MYSQL *mysql)
{
  return mysql_affected_rows(mysql);
}
SYM_16(mysql_affected_rows);


my_bool STDCALL symver16_mysql_autocommit(MYSQL * mysql, my_bool auto_mode)
{
  return mysql_autocommit(mysql, auto_mode);
}
SYM_16(mysql_autocommit);


my_bool STDCALL symver16_mysql_change_user(MYSQL *mysql, const char *user, const char *passwd, const char *db)
{
  return mysql_change_user(mysql, user, passwd, db);
}
SYM_16(mysql_change_user);


const char * STDCALL symver16_mysql_character_set_name(MYSQL *mysql)
{
  return mysql_character_set_name(mysql);
}
SYM_16(mysql_character_set_name);


my_bool STDCALL symver16_mysql_commit(MYSQL * mysql)
{
  return mysql_commit(mysql);
}
SYM_16(mysql_commit);


void STDCALL symver16_mysql_data_seek(MYSQL_RES *result, my_ulonglong row)
{
  return mysql_data_seek(result, row);
}
SYM_16(mysql_data_seek);


void STDCALL symver16_mysql_debug(const char *debug __attribute__((unused)))
{
  return mysql_debug(debug);
}
SYM_16(mysql_debug);


int STDCALL symver16_mysql_dump_debug_info(MYSQL *mysql)
{
  return mysql_dump_debug_info(mysql);
}
SYM_16(mysql_dump_debug_info);


my_bool STDCALL symver16_mysql_embedded(void)
{
  return mysql_embedded();
}
SYM_16(mysql_embedded);


my_bool STDCALL symver16_mysql_eof(MYSQL_RES *res)
{
  return mysql_eof(res);
}
SYM_16(mysql_eof);


ulong STDCALL symver16_mysql_escape_string(char *to,const char *from,ulong length)
{
  return mysql_escape_string(to, from, length);
}
SYM_16(mysql_escape_string);


MYSQL_FIELD * STDCALL symver16_mysql_fetch_field(MYSQL_RES *result)
{
  return mysql_fetch_field(result);
}
SYM_16(mysql_fetch_field);


MYSQL_FIELD * STDCALL symver16_mysql_fetch_field_direct(MYSQL_RES *res,uint fieldnr)
{
  return mysql_fetch_field_direct(res, fieldnr);
}
SYM_16(mysql_fetch_field_direct);


MYSQL_FIELD * STDCALL symver16_mysql_fetch_fields(MYSQL_RES *res)
{
  return mysql_fetch_fields(res);
}
SYM_16(mysql_fetch_fields);


unsigned int STDCALL symver16_mysql_field_count(MYSQL *mysql)
{
  return mysql_field_count(mysql);
}
SYM_16(mysql_field_count);


MYSQL_FIELD_OFFSET STDCALL symver16_mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)
{
  return mysql_field_seek(result, field_offset);
}
SYM_16(mysql_field_seek);


MYSQL_FIELD_OFFSET STDCALL symver16_mysql_field_tell(MYSQL_RES *res)
{
  return mysql_field_tell(res);
}
SYM_16(mysql_field_tell);


void STDCALL symver16_mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *csinfo)
{
  return mysql_get_character_set_info(mysql, csinfo);
}
SYM_16(mysql_get_character_set_info);


const char * STDCALL symver16_mysql_get_client_info(void)
{
  return mysql_get_client_info();
}
SYM_16(mysql_get_client_info);

ulong STDCALL symver16_mysql_get_client_version(void)
{
  return mysql_get_client_version();
}
SYM_16(mysql_get_client_version);


const char * STDCALL symver16_mysql_get_host_info(MYSQL *mysql)
{
  return mysql_get_host_info(mysql);
}
SYM_16(mysql_get_host_info);


MYSQL_PARAMETERS *STDCALL symver16_mysql_get_parameters(void)
{
  return mysql_get_parameters();
}
SYM_16(mysql_get_parameters);


uint STDCALL symver16_mysql_get_proto_info(MYSQL *mysql)
{
  return mysql_get_proto_info(mysql);
}
SYM_16(mysql_get_proto_info);


const char * STDCALL symver16_mysql_get_server_info(MYSQL *mysql)
{
  return mysql_get_server_info(mysql);
}
SYM_16(mysql_get_server_info);


ulong STDCALL symver16_mysql_hex_string(char *to, const char *from, ulong length)
{
  return mysql_hex_string(to, from, length);
}
SYM_16(mysql_hex_string);


const char *STDCALL symver16_mysql_info(MYSQL *mysql)
{
  return mysql_info(mysql);
}
SYM_16(mysql_info);


my_ulonglong STDCALL symver16_mysql_insert_id(MYSQL *mysql)
{
  return mysql_insert_id(mysql);
}
SYM_16(mysql_insert_id);


int STDCALL symver16_mysql_kill(MYSQL *mysql,ulong pid)
{
  return mysql_kill(mysql, pid);
}
SYM_16(mysql_kill);


MYSQL_RES * STDCALL symver16_mysql_list_dbs(MYSQL *mysql, const char *wild)
{
  return mysql_list_dbs(mysql, wild);
}
SYM_16(mysql_list_dbs);


MYSQL_RES * STDCALL symver16_mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)
{
  return mysql_list_fields(mysql, table, wild);
}
SYM_16(mysql_list_fields);


MYSQL_RES * STDCALL symver16_mysql_list_processes(MYSQL *mysql)
{
  return mysql_list_processes(mysql);
}
SYM_16(mysql_list_processes);


MYSQL_RES * STDCALL symver16_mysql_list_tables(MYSQL *mysql, const char *wild)
{
  return mysql_list_tables(mysql, wild);
}
SYM_16(mysql_list_tables);


my_bool STDCALL symver16_mysql_more_results(MYSQL *mysql)
{
  return mysql_more_results(mysql);
}
SYM_16(mysql_more_results);


int STDCALL symver16_mysql_next_result(MYSQL *mysql)
{
  return mysql_next_result(mysql);
}
SYM_16(mysql_next_result);


int STDCALL symver16_mysql_ping(MYSQL *mysql)
{
  return mysql_ping(mysql);
}
SYM_16(mysql_ping);


int STDCALL symver16_mysql_query(MYSQL *mysql, const char *query)
{
  return mysql_query(mysql, query);
}
SYM_16(mysql_query);


my_bool STDCALL symver16_mysql_read_query_result(MYSQL *mysql)
{
  return mysql_read_query_result(mysql);
}
SYM_16(mysql_read_query_result);


ulong STDCALL symver16_mysql_real_escape_string(MYSQL *mysql, char *to,const char *from, ulong length)
{
  return mysql_real_escape_string(mysql, to, from, length);
}
SYM_16(mysql_real_escape_string);


int STDCALL symver16_mysql_refresh(MYSQL *mysql,uint options)
{
  return mysql_refresh(mysql, options);
}
SYM_16(mysql_refresh);


my_bool STDCALL symver16_mysql_rollback(MYSQL * mysql)
{
  return mysql_rollback(mysql);
}
SYM_16(mysql_rollback);


MYSQL_ROW_OFFSET STDCALL symver16_mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET row)
{
  return mysql_row_seek(result, row);
}
SYM_16(mysql_row_seek);


MYSQL_ROW_OFFSET STDCALL symver16_mysql_row_tell(MYSQL_RES *res)
{
  return mysql_row_tell(res);
}
SYM_16(mysql_row_tell);


void STDCALL symver16_mysql_server_end()
{
  return mysql_server_end();
}
SYM_16(mysql_server_end);


int STDCALL symver16_mysql_server_init(int argc __attribute__((unused)), char **argv __attribute__((unused)), char **groups __attribute__((unused)))
{
  return mysql_server_init(argc, argv, groups);
}
SYM_16(mysql_server_init);


void symver16_mysql_set_local_infile_default(MYSQL *mysql)
{
  return mysql_set_local_infile_default(mysql);
}
SYM_16(mysql_set_local_infile_default);


void symver16_mysql_set_local_infile_handler(MYSQL *mysql, int (*local_infile_init)(void **, const char *, void *), int (*local_infile_read)(void *, char *, uint), void (*local_infile_end)(void *), int (*local_infile_error)(void *, char *, uint), void *userdata)
{
  return mysql_set_local_infile_handler(mysql, local_infile_init, local_infile_read, local_infile_end, local_infile_error, userdata);
}
SYM_16(mysql_set_local_infile_handler);


int STDCALL symver16_mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)
{
  return mysql_set_server_option(mysql, option);
}
SYM_16(mysql_set_server_option);


int STDCALL symver16_mysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)
{
  return mysql_shutdown(mysql, shutdown_level);
}
SYM_16(mysql_shutdown);


const char *STDCALL symver16_mysql_sqlstate(MYSQL *mysql)
{
  return mysql_sqlstate(mysql);
}
SYM_16(mysql_sqlstate);


const char * STDCALL symver16_mysql_stat(MYSQL *mysql)
{
  return mysql_stat(mysql);
}
SYM_16(mysql_stat);


my_ulonglong STDCALL symver16_mysql_stmt_affected_rows(MYSQL_STMT *stmt)
{
  return mysql_stmt_affected_rows(stmt);
}
SYM_16(mysql_stmt_affected_rows);


my_bool STDCALL symver16_mysql_stmt_attr_get(MYSQL_STMT *stmt, enum enum_stmt_attr_type attr_type, void *value)
{
  return mysql_stmt_attr_get(stmt, attr_type, value);
}
SYM_16(mysql_stmt_attr_get);


my_bool STDCALL symver16_mysql_stmt_attr_set(MYSQL_STMT *stmt, enum enum_stmt_attr_type attr_type, const void *value)
{
  return mysql_stmt_attr_set(stmt, attr_type, value);
}
SYM_16(mysql_stmt_attr_set);


my_bool STDCALL symver16_mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
{
  return mysql_stmt_bind_param(stmt, my_bind);
}
SYM_16(mysql_stmt_bind_param);


my_bool STDCALL symver16_mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
{
  return mysql_stmt_bind_result(stmt, my_bind);
}
SYM_16(mysql_stmt_bind_result);


my_bool STDCALL symver16_mysql_stmt_close(MYSQL_STMT *stmt)
{
  return mysql_stmt_close(stmt);
}
SYM_16(mysql_stmt_close);


void STDCALL symver16_mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong row)
{
  return mysql_stmt_data_seek(stmt, row);
}
SYM_16(mysql_stmt_data_seek);


uint STDCALL symver16_mysql_stmt_errno(MYSQL_STMT * stmt)
{
  return mysql_stmt_errno(stmt);
}
SYM_16(mysql_stmt_errno);


const char *STDCALL symver16_mysql_stmt_error(MYSQL_STMT * stmt)
{
  return mysql_stmt_error(stmt);
}
SYM_16(mysql_stmt_error);


int STDCALL symver16_mysql_stmt_execute(MYSQL_STMT *stmt)
{
  return mysql_stmt_execute(stmt);
}
SYM_16(mysql_stmt_execute);


int STDCALL symver16_mysql_stmt_fetch(MYSQL_STMT *stmt)
{
  return mysql_stmt_fetch(stmt);
}
SYM_16(mysql_stmt_fetch);


int STDCALL symver16_mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *my_bind, uint column, ulong offset)  
{
  return mysql_stmt_fetch_column(stmt, my_bind, column, offset);
}
SYM_16(mysql_stmt_fetch_column);


unsigned int STDCALL symver16_mysql_stmt_field_count(MYSQL_STMT *stmt)
{
  return mysql_stmt_field_count(stmt);
}
SYM_16(mysql_stmt_field_count);


my_bool STDCALL symver16_mysql_stmt_free_result(MYSQL_STMT *stmt)
{
  return mysql_stmt_free_result(stmt);
}
SYM_16(mysql_stmt_free_result);


MYSQL_STMT * STDCALL symver16_mysql_stmt_init(MYSQL *mysql)
{
  return mysql_stmt_init(mysql);
}
SYM_16(mysql_stmt_init);


my_ulonglong STDCALL symver16_mysql_stmt_insert_id(MYSQL_STMT *stmt)
{
  return mysql_stmt_insert_id(stmt);
}
SYM_16(mysql_stmt_insert_id);


my_ulonglong STDCALL symver16_mysql_stmt_num_rows(MYSQL_STMT *stmt)
{
  return mysql_stmt_num_rows(stmt);
}
SYM_16(mysql_stmt_num_rows);


ulong STDCALL symver16_mysql_stmt_param_count(MYSQL_STMT * stmt)
{
  return mysql_stmt_param_count(stmt);
}
SYM_16(mysql_stmt_param_count);


MYSQL_RES * STDCALL symver16_mysql_stmt_param_metadata(MYSQL_STMT *stmt)
{
  return mysql_stmt_param_metadata(stmt);
}
SYM_16(mysql_stmt_param_metadata);


int STDCALL symver16_mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, ulong length)
{
  return mysql_stmt_prepare(stmt, query, length);
}
SYM_16(mysql_stmt_prepare);


my_bool STDCALL symver16_mysql_stmt_reset(MYSQL_STMT *stmt)
{
  return mysql_stmt_reset(stmt);
}
SYM_16(mysql_stmt_reset);


MYSQL_RES * STDCALL symver16_mysql_stmt_result_metadata(MYSQL_STMT *stmt)
{
  return mysql_stmt_result_metadata(stmt);
}
SYM_16(mysql_stmt_result_metadata);


MYSQL_ROW_OFFSET STDCALL symver16_mysql_stmt_row_seek(MYSQL_STMT *stmt, MYSQL_ROW_OFFSET row)
{
  return mysql_stmt_row_seek(stmt, row);
}
SYM_16(mysql_stmt_row_seek);


MYSQL_ROW_OFFSET STDCALL symver16_mysql_stmt_row_tell(MYSQL_STMT *stmt)
{
  return mysql_stmt_row_tell(stmt);
}
SYM_16(mysql_stmt_row_tell);


my_bool STDCALL symver16_mysql_stmt_send_long_data(MYSQL_STMT *stmt, uint param_number, const char *data, ulong length)
{
  return mysql_stmt_send_long_data(stmt, param_number, data, length);
}
SYM_16(mysql_stmt_send_long_data);


const char *STDCALL symver16_mysql_stmt_sqlstate(MYSQL_STMT * stmt)
{
  return mysql_stmt_sqlstate(stmt);
}
SYM_16(mysql_stmt_sqlstate);


int STDCALL symver16_mysql_stmt_store_result(MYSQL_STMT *stmt)
{
  return mysql_stmt_store_result(stmt);
}
SYM_16(mysql_stmt_store_result);


void STDCALL symver16_mysql_thread_end()
{
  return mysql_thread_end();
}
SYM_16(mysql_thread_end);


ulong STDCALL symver16_mysql_thread_id(MYSQL *mysql)
{
  return mysql_thread_id(mysql);
}
SYM_16(mysql_thread_id);


my_bool STDCALL symver16_mysql_thread_init()
{
  return mysql_thread_init();
}
SYM_16(mysql_thread_init);


uint STDCALL symver16_mysql_thread_safe(void)
{
  return mysql_thread_safe();
}
SYM_16(mysql_thread_safe);


MYSQL_RES * STDCALL symver16_mysql_use_result(MYSQL *mysql)
{
  return mysql_use_result(mysql);
}
SYM_16(mysql_use_result);


uint STDCALL symver16_mysql_warning_count(MYSQL *mysql)
{
  return mysql_warning_count(mysql);
}
SYM_16(mysql_warning_count);

/*****/

MYSQL * STDCALL symver16_mysql_real_connect(MYSQL *mysql,const char *host, const char *user, const char *passwd, const char *db, uint port, const char *unix_socket,ulong client_flag)
{
  return mysql_real_connect(mysql, host, user, passwd, db, port, unix_socket, client_flag);
}
SYM_16(mysql_real_connect);

/*****/

my_bool symver16_my_init(void)
{
  return my_init();
}
SYM_16(my_init);


#endif
#endif  /* EXPORT_SYMVER16 */
      </pre>
    </body>
</html>
