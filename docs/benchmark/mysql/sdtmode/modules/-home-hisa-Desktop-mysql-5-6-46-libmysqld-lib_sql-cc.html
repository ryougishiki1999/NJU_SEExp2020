<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8"/>
        <title>/home/hisa/Desktop/mysql-5.6.46/libmysqld/lib_sql.cc</title>
        <link rel="stylesheet" type="text/css" href="../css/prettyprint.css"/>
        <script type="text/javascript" src="../js/prettyprint.js"></script>
    </head>
    <body onload="prettyPrint()">
		<pre class="prettyprint lang-cpp linenums">
/*
 * Copyright (c)  2000
 * SWsoft  company
 *
 * Modifications copyright (c) 2001, 2016. Oracle and/or its affiliates.
 * All rights reserved.
 *
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 *
 * Permission to use or copy this software for any purpose is hereby granted 
 * without fee, provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 *

  This code was modified by the MySQL team
*/

/*
  The following is needed to not cause conflicts when we include mysqld.cc
*/

extern "C"
{
  extern unsigned long max_allowed_packet, net_buffer_length;
}

#include "../sql/mysqld.cc"

extern "C" {

#include &lt;mysql.h&gt;
#undef ER
#include "errmsg.h"
#include "embedded_priv.h"

} // extern "C"

#include &lt;algorithm&gt;

using std::min;
using std::max;

extern "C" {

extern unsigned int mysql_server_last_errno;
extern char mysql_server_last_error[MYSQL_ERRMSG_SIZE];
static my_bool emb_read_query_result(MYSQL *mysql);


void unireg_clear(int exit_code)
{
  DBUG_ENTER("unireg_clear");
  clean_up(!opt_help &amp;&amp; (exit_code || !opt_bootstrap)); /* purecov: inspected */
  my_end(opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0);
  DBUG_VOID_RETURN;
}

/*
  Wrapper error handler for embedded server to call client/server error 
  handler based on whether thread is in client/server context
*/

static void embedded_error_handler(uint error, const char *str, myf MyFlags)
{
  DBUG_ENTER("embedded_error_handler");

  /* 
    If current_thd is NULL, it means restore_global has been called and 
    thread is in client context, then call client error handler else call 
    server error handler.
  */
  DBUG_RETURN(current_thd ? my_message_sql(error, str, MyFlags):
              my_message_stderr(error, str, MyFlags));
}


/*
  Reads error information from the MYSQL_DATA and puts
  it into proper MYSQL members

  SYNOPSIS
    embedded_get_error()
    mysql        connection handler
    data         query result

  NOTES
    after that function error information will be accessible
       with usual functions like mysql_error()
    data is my_free-d in this function
    most of the data is stored in data-&gt;embedded_info structure
*/

void embedded_get_error(MYSQL *mysql, MYSQL_DATA *data)
{
  NET *net= &amp;mysql-&gt;net;
  struct embedded_query_result *ei= data-&gt;embedded_info;
  net-&gt;last_errno= ei-&gt;last_errno;
  strmake(net-&gt;last_error, ei-&gt;info, sizeof(net-&gt;last_error)-1);
  memcpy(net-&gt;sqlstate, ei-&gt;sqlstate, sizeof(net-&gt;sqlstate));
  mysql-&gt;server_status= ei-&gt;server_status;
  my_free(data);
}

static my_bool
emb_advanced_command(MYSQL *mysql, enum enum_server_command command,
		     const uchar *header, ulong header_length,
		     const uchar *arg, ulong arg_length, my_bool skip_check,
                     MYSQL_STMT *stmt)
{
  my_bool result= 1;
  THD *thd=(THD *) mysql-&gt;thd;
  NET *net= &amp;mysql-&gt;net;
  my_bool stmt_skip= stmt ? stmt-&gt;state != MYSQL_STMT_INIT_DONE : FALSE;

  if (!thd)
  {
    /* Do "reconnect" if possible */
    if (mysql_reconnect(mysql) || stmt_skip)
      return 1;
    thd= (THD *) mysql-&gt;thd;
  }

#if defined(ENABLED_PROFILING)
  thd-&gt;profiling.start_new_query();
#endif

  thd-&gt;clear_data_list();
  /* Check that we are calling the client functions in right order */
  if (mysql-&gt;status != MYSQL_STATUS_READY)
  {
    set_mysql_error(mysql, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate);
    result= 1;
    goto end;
  }

  /* Clear result variables */
  thd-&gt;clear_error();
  thd-&gt;get_stmt_da()-&gt;reset_diagnostics_area();
  mysql-&gt;affected_rows= ~(my_ulonglong) 0;
  mysql-&gt;field_count= 0;
  net_clear_error(net);
  thd-&gt;current_stmt= stmt;

  thd-&gt;thread_stack= (char*) &amp;thd;
  thd-&gt;store_globals();				// Fix if more than one connect
  /* 
     We have to call free_old_query before we start to fill mysql-&gt;fields 
     for new query. In the case of embedded server we collect field data
     during query execution (not during data retrieval as it is in remote
     client). So we have to call free_old_query here
  */
  free_old_query(mysql);

  thd-&gt;extra_length= arg_length;
  thd-&gt;extra_data= (char *)arg;
  if (header)
  {
    arg= header;
    arg_length= header_length;
  }

  result= dispatch_command(command, thd, (char *) arg, arg_length);
  thd-&gt;cur_data= 0;
  thd-&gt;mysys_var= NULL;

  if (!skip_check)
    result= thd-&gt;is_error() ? -1 : 0;

  thd-&gt;mysys_var= 0;

#if defined(ENABLED_PROFILING)
  thd-&gt;profiling.finish_current_query();
#endif

end:
  thd-&gt;restore_globals();
  return result;
}

static void emb_flush_use_result(MYSQL *mysql, my_bool)
{
  THD *thd= (THD*) mysql-&gt;thd;
  if (thd-&gt;cur_data)
  {
    free_rows(thd-&gt;cur_data);
    thd-&gt;cur_data= 0;
  }
  else if (thd-&gt;first_data)
  {
    MYSQL_DATA *data= thd-&gt;first_data;
    thd-&gt;first_data= data-&gt;embedded_info-&gt;next;
    free_rows(data);
  }
}


/*
  reads dataset from the next query result

  SYNOPSIS
  emb_read_rows()
  mysql		connection handle
  other parameters are not used

  NOTES
    It just gets next MYSQL_DATA from the result's queue

  RETURN
    pointer to MYSQL_DATA with the coming recordset
*/

static MYSQL_DATA *
emb_read_rows(MYSQL *mysql, MYSQL_FIELD *mysql_fields MY_ATTRIBUTE((unused)),
	      unsigned int fields MY_ATTRIBUTE((unused)))
{
  MYSQL_DATA *result= ((THD*)mysql-&gt;thd)-&gt;cur_data;
  ((THD*)mysql-&gt;thd)-&gt;cur_data= 0;
  if (result-&gt;embedded_info-&gt;last_errno)
  {
    embedded_get_error(mysql, result);
    return NULL;
  }
  *result-&gt;embedded_info-&gt;prev_ptr= NULL;
  return result;
}


static MYSQL_FIELD *emb_list_fields(MYSQL *mysql)
{
  MYSQL_DATA *res;
  if (emb_read_query_result(mysql))
    return 0;
  res= ((THD*) mysql-&gt;thd)-&gt;cur_data;
  ((THD*) mysql-&gt;thd)-&gt;cur_data= 0;
  mysql-&gt;field_alloc= res-&gt;alloc;
  my_free(res);
  mysql-&gt;status= MYSQL_STATUS_READY;
  return mysql-&gt;fields;
}

static my_bool emb_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
{
  THD *thd= (THD*) mysql-&gt;thd;
  MYSQL_DATA *res;

  stmt-&gt;stmt_id= thd-&gt;client_stmt_id;
  stmt-&gt;param_count= thd-&gt;client_param_count;
  stmt-&gt;field_count= 0;
  mysql-&gt;warning_count= thd-&gt;get_stmt_da()-&gt;current_statement_warn_count();

  if (thd-&gt;first_data)
  {
    if (emb_read_query_result(mysql))
      return 1;
    stmt-&gt;field_count= mysql-&gt;field_count;
    mysql-&gt;status= MYSQL_STATUS_READY;
    res= thd-&gt;cur_data;
    thd-&gt;cur_data= NULL;
    if (!(mysql-&gt;server_status &amp; SERVER_STATUS_AUTOCOMMIT))
      mysql-&gt;server_status|= SERVER_STATUS_IN_TRANS;

    stmt-&gt;fields= mysql-&gt;fields;
    stmt-&gt;mem_root= res-&gt;alloc;
    mysql-&gt;fields= NULL;
    my_free(res);
  }

  return 0;
}

/**************************************************************************
  Get column lengths of the current row
  If one uses mysql_use_result, res-&gt;lengths contains the length information,
  else the lengths are calculated from the offset between pointers.
**************************************************************************/

static void emb_fetch_lengths(ulong *to, MYSQL_ROW column,
			      unsigned int field_count)
{ 
  MYSQL_ROW end;

  for (end=column + field_count; column != end ; column++,to++)
<span style = "background-color:#fdd">    *to= *column ? *(uint *)((*column) - sizeof(uint)) : 0;        out-of-bound array access:Access out-of-bound array element (buffer overflow)</span>
}

static my_bool emb_read_query_result(MYSQL *mysql)
{
  THD *thd= (THD*) mysql-&gt;thd;
  MYSQL_DATA *res= thd-&gt;first_data;
  DBUG_ASSERT(!thd-&gt;cur_data);
  thd-&gt;first_data= res-&gt;embedded_info-&gt;next;
  if (res-&gt;embedded_info-&gt;last_errno &amp;&amp;
      !res-&gt;embedded_info-&gt;fields_list)
  {
    embedded_get_error(mysql, res);
    return 1;
  }

  mysql-&gt;warning_count= res-&gt;embedded_info-&gt;warning_count;
  mysql-&gt;server_status= res-&gt;embedded_info-&gt;server_status;
  mysql-&gt;field_count= res-&gt;fields;
  if (!(mysql-&gt;fields= res-&gt;embedded_info-&gt;fields_list))
  {
    mysql-&gt;affected_rows= res-&gt;embedded_info-&gt;affected_rows;
    mysql-&gt;insert_id= res-&gt;embedded_info-&gt;insert_id;
  }
  net_clear_error(&amp;mysql-&gt;net);
  mysql-&gt;info= 0;

  if (res-&gt;embedded_info-&gt;info[0])
  {
    strmake(mysql-&gt;info_buffer, res-&gt;embedded_info-&gt;info, MYSQL_ERRMSG_SIZE-1);
    mysql-&gt;info= mysql-&gt;info_buffer;
  }

  if (res-&gt;embedded_info-&gt;fields_list)
  {
    mysql-&gt;status=MYSQL_STATUS_GET_RESULT;
    thd-&gt;cur_data= res;
  }
  else
    my_free(res);

  return 0;
}

#define HEADER_SIZE 9
static int emb_stmt_execute(MYSQL_STMT *stmt)
{
  DBUG_ENTER("emb_stmt_execute");
  /*
    Header size is made similar to non-embedded library.
    It should be consistent across embedded and non-embedded
    libraries.
  */
  uchar header[HEADER_SIZE];
  THD *thd;
  my_bool res;

  int4store(header, stmt-&gt;stmt_id);
  header[4]= (uchar) stmt-&gt;flags;
  /*
    Dummy value is stored in the last 4 bytes of the header
    to make it consistent with non-embedded library.
  */
  int4store(header + 5, 1);
  thd= (THD*)stmt-&gt;mysql-&gt;thd;
  thd-&gt;client_param_count= stmt-&gt;param_count;
  thd-&gt;client_params= stmt-&gt;params;

  res= MY_TEST(emb_advanced_command(stmt-&gt;mysql, COM_STMT_EXECUTE, 0, 0,
                                    header, sizeof(header), 1, stmt) ||
               emb_read_query_result(stmt-&gt;mysql));
  stmt-&gt;affected_rows= stmt-&gt;mysql-&gt;affected_rows;
  stmt-&gt;insert_id= stmt-&gt;mysql-&gt;insert_id;
  stmt-&gt;server_status= stmt-&gt;mysql-&gt;server_status;
  if (res)
  {
    NET *net= &amp;stmt-&gt;mysql-&gt;net;
    set_stmt_errmsg(stmt, net);
    DBUG_RETURN(1);
  }
  else if (stmt-&gt;mysql-&gt;status == MYSQL_STATUS_GET_RESULT)
           stmt-&gt;mysql-&gt;status= MYSQL_STATUS_STATEMENT_GET_RESULT;
  DBUG_RETURN(0);
}

int emb_read_binary_rows(MYSQL_STMT *stmt)
{
  MYSQL_DATA *data;
  if (!(data= emb_read_rows(stmt-&gt;mysql, 0, 0)))
  {
    set_stmt_errmsg(stmt, &amp;stmt-&gt;mysql-&gt;net);
    return 1;
  }
  stmt-&gt;result= *data;
  my_free(data);
  set_stmt_errmsg(stmt, &amp;stmt-&gt;mysql-&gt;net);
  return 0;
}

int emb_read_rows_from_cursor(MYSQL_STMT *stmt)
{
  MYSQL *mysql= stmt-&gt;mysql;
  THD *thd= (THD*) mysql-&gt;thd;
  MYSQL_DATA *res= thd-&gt;first_data;
  DBUG_ASSERT(!thd-&gt;first_data-&gt;embedded_info-&gt;next);
  thd-&gt;first_data= 0;
  if (res-&gt;embedded_info-&gt;last_errno)
  {
    embedded_get_error(mysql, res);
    set_stmt_errmsg(stmt, &amp;mysql-&gt;net);
    return 1;
  }

  thd-&gt;cur_data= res;
  mysql-&gt;warning_count= res-&gt;embedded_info-&gt;warning_count;
  mysql-&gt;server_status= res-&gt;embedded_info-&gt;server_status;
  net_clear_error(&amp;mysql-&gt;net);

  return emb_read_binary_rows(stmt);
}

int emb_unbuffered_fetch(MYSQL *mysql, char **row)
{
  THD *thd= (THD*) mysql-&gt;thd;
  MYSQL_DATA *data= thd-&gt;cur_data;
  if (data &amp;&amp; data-&gt;embedded_info-&gt;last_errno)
  {
    embedded_get_error(mysql, data);
    thd-&gt;cur_data= 0;
    return 1;
  }
  if (!data || !data-&gt;data)
  {
    *row= NULL;
    if (data)
    {
      thd-&gt;cur_data= thd-&gt;first_data;
      thd-&gt;first_data= data-&gt;embedded_info-&gt;next;
      free_rows(data);
    }
  }
  else
  {
    *row= (char *)data-&gt;data-&gt;data;
    data-&gt;data= data-&gt;data-&gt;next;
  }
  return 0;
}

static void emb_free_embedded_thd(MYSQL *mysql)
{
  THD *thd= (THD*)mysql-&gt;thd;
  thd-&gt;clear_data_list();
  thd-&gt;store_globals();
  thd-&gt;release_resources();
  remove_global_thread(thd);
  delete thd;
  my_pthread_setspecific_ptr(THR_THD,  0);
  mysql-&gt;thd=0;
}

static const char * emb_read_statistics(MYSQL *mysql)
{
  THD *thd= (THD*)mysql-&gt;thd;
  return thd-&gt;is_error() ? thd-&gt;get_stmt_da()-&gt;message() : "";
}


static MYSQL_RES * emb_store_result(MYSQL *mysql)
{
  return mysql_store_result(mysql);
}

int emb_read_change_user_result(MYSQL *mysql)
{
  mysql-&gt;net.read_pos= (uchar*)""; // fake an OK packet
  return mysql_errno(mysql) ? static_cast&lt;int&gt;packet_error :
                              1 /* length of the OK packet */;
}

MYSQL_METHODS embedded_methods= 
{
  emb_read_query_result,
  emb_advanced_command,
  emb_read_rows,
  emb_store_result,
  emb_fetch_lengths, 
  emb_flush_use_result,
  emb_read_change_user_result,
  emb_list_fields,
  emb_read_prepare_result,
  emb_stmt_execute,
  emb_read_binary_rows,
  emb_unbuffered_fetch,
  emb_free_embedded_thd,
  emb_read_statistics,
  emb_read_query_result,
  emb_read_rows_from_cursor
};

/*
  Make a copy of array and the strings array points to
*/

char **copy_arguments(int argc, char **argv)
{
  uint length= 0;
  char **from, **res, **end= argv+argc;

  for (from=argv ; from != end ; from++)
    length+= strlen(*from);

  if ((res= (char**) my_malloc(sizeof(argv)*(argc+1)+length+argc,
			       MYF(MY_WME))))
  {
    char **to= res, *to_str= (char*) (res+argc+1);
    for (from=argv ; from != end ;)
    {
      *to++= to_str;
      to_str= strmov(to_str, *from++)+1;
    }
    *to= 0;					// Last ptr should be null
  }
  return res;
}

char **		copy_arguments_ptr= 0;

int init_embedded_server(int argc, char **argv, char **groups)
{
  /*
    This mess is to allow people to call the init function without
    having to mess with a fake argv
   */
  int *argcp= NULL;
  char ***argvp= NULL;
  int fake_argc= 1;
  char *fake_argv[2];
  char **foo= &amp;fake_argv[0];
  char fake_server[]= "server";
  char fake_embedded[]= "embedded";
  char *fake_groups[]= { fake_server, fake_embedded, NULL };
  char fake_name[]= "fake_name";
  my_bool acl_error;

  if (my_thread_init())
    return 1;

  if (argc)
  {
    argcp= &amp;argc;
    argvp= &amp;argv;
  }
  else
  {
    fake_argv[0]= fake_name;
    fake_argv[1]= NULL;

    argcp= &amp;fake_argc;
    argvp= &amp;foo;
  }
  if (!groups)
    groups= fake_groups;

  my_progname= "mysql_embedded";

  /*
    Perform basic logger initialization logger. Should be called after
    MY_INIT, as it initializes mutexes. Log tables are inited later.
  */
  logger.init_base();

  orig_argc= *argcp;
  orig_argv= *argvp;
  if (load_defaults("my", (const char **)groups, argcp, argvp))
    return 1;
  defaults_argc= *argcp;
  defaults_argv= *argvp;
  remaining_argc= *argcp;
  remaining_argv= *argvp;

  /* Must be initialized early for comparison of options name */
  system_charset_info= &amp;my_charset_utf8_general_ci;
  sys_var_init();

  int ho_error= handle_early_options();
  if (ho_error != 0)
  {
    buffered_logs.print();
    buffered_logs.cleanup();
    return 1;
  }

  ulong requested_open_files_dummy;
  adjust_related_options(&amp;requested_open_files_dummy);

  if (init_common_variables())
  {
    mysql_server_end();
    return 1;
  }

  mysql_data_home= mysql_real_data_home;
  mysql_data_home_len= mysql_real_data_home_len;

  /* Get default temporary directory */
  opt_mysql_tmpdir=getenv("TMPDIR");	/* Use this if possible */
#if defined(__WIN__)
  if (!opt_mysql_tmpdir)
    opt_mysql_tmpdir=getenv("TEMP");
  if (!opt_mysql_tmpdir)
    opt_mysql_tmpdir=getenv("TMP");
#endif
  if (!opt_mysql_tmpdir || !opt_mysql_tmpdir[0])
    opt_mysql_tmpdir= const_cast&lt;char*&gt;(DEFAULT_TMPDIR); /* purecov: inspected*/

  init_ssl();
  umask(((~my_umask) &amp; 0666));
  if (init_server_components())
  {
    mysql_server_end();
    return 1;
  }

  /*
    Each server should have one UUID. We will create it automatically, if it
    does not exist.
   */
  if (!opt_bootstrap &amp;&amp; init_server_auto_options())
  {
    mysql_server_end();
    return 1;
  }

  /* 
    set error_handler_hook to embedded_error_handler wrapper.
  */
  error_handler_hook= embedded_error_handler;

  acl_error= 0;
#ifndef NO_EMBEDDED_ACCESS_CHECKS
  if (!(acl_error= acl_init(opt_noacl)) &amp;&amp;
      !opt_noacl)
    (void) grant_init();
#endif
  if (acl_error || my_tz_init((THD *)0, default_tz_name, opt_bootstrap))
  {
    mysql_server_end();
    return 1;
  }

  init_max_user_conn();
  init_update_queries();

  if (!opt_bootstrap)
    servers_init(0);

#ifdef HAVE_DLOPEN
#ifndef NO_EMBEDDED_ACCESS_CHECKS
  if (!opt_noacl)
#endif
    udf_init();
#endif

  (void) thr_setconcurrency(concurrency);	// 10 by default

  start_handle_manager();

  // FIXME initialize binlog_filter and rpl_filter if not already done
  //       corresponding delete is in clean_up()
  if(!binlog_filter) binlog_filter = new Rpl_filter;
  if(!rpl_filter) rpl_filter = new Rpl_filter;

  if (opt_init_file)
  {
    if (read_init_file(opt_init_file))
    {
      mysql_server_end();
      return 1;
    }
  }

  execute_ddl_log_recovery();

  /* Signal successful initialization */
  mysql_mutex_lock(&amp;LOCK_server_started);
  mysqld_server_started= 1;
  mysql_cond_broadcast(&amp;COND_server_started);
  mysql_mutex_unlock(&amp;LOCK_server_started);

#ifdef WITH_NDBCLUSTER_STORAGE_ENGINE
  /* engine specific hook, to be made generic */
  if (ndb_wait_setup_func &amp;&amp; ndb_wait_setup_func(opt_ndb_wait_setup))
  {
    sql_print_warning("NDB : Tables not available after %lu seconds."
                      "  Consider increasing --ndb-wait-setup value",
                      opt_ndb_wait_setup);
  }
#endif

  return 0;
}

void end_embedded_server()
{
  my_free(copy_arguments_ptr);
  copy_arguments_ptr=0;
  clean_up(0);
}


void init_embedded_mysql(MYSQL *mysql, int client_flag)
{
  THD *thd = (THD *)mysql-&gt;thd;
  thd-&gt;mysql= mysql;
  mysql-&gt;server_version= server_version;
  mysql-&gt;client_flag= client_flag;
  init_alloc_root(&amp;mysql-&gt;field_alloc, 8192, 0);
}

/**
  @brief Initialize a new THD for a connection in the embedded server

  @param client_flag  Client capabilities which this thread supports
  @return pointer to the created THD object

  @todo
  This function copies code from several places in the server, including
  create_new_thread(), and prepare_new_connection_state().  This should
  be refactored to avoid code duplication.
*/
void *create_embedded_thd(int client_flag)
{
  THD * thd= new THD;
  thd-&gt;thread_id= thd-&gt;variables.pseudo_thread_id= thread_id++;

  thd-&gt;thread_stack= (char*) &amp;thd;
  if (thd-&gt;store_globals())
  {
    fprintf(stderr,"store_globals failed.\n");
    goto err;
  }
<span style = "background-color:#fdd">  lex_start(thd);        Memory Leak:Potential memory leak at pointer 'thd'</span>

  /* TODO - add init_connect command execution */

  if (thd-&gt;variables.max_join_size == HA_POS_ERROR)
    thd-&gt;variables.option_bits |= OPTION_BIG_SELECTS;
  thd-&gt;proc_info=0;				// Remove 'login'
  thd-&gt;set_command(COM_SLEEP);
  thd-&gt;set_time();
  thd-&gt;init_for_queries();
  thd-&gt;client_capabilities= client_flag;
  thd-&gt;real_id= pthread_self();

  thd-&gt;db= NULL;
  thd-&gt;db_length= 0;
#ifndef NO_EMBEDDED_ACCESS_CHECKS
  thd-&gt;security_ctx-&gt;db_access= DB_ACLS;
  thd-&gt;security_ctx-&gt;master_access= ~NO_ACCESS;
#endif
  thd-&gt;cur_data= 0;
  thd-&gt;first_data= 0;
  thd-&gt;data_tail= &amp;thd-&gt;first_data;
  memset(&amp;thd-&gt;net, 0, sizeof(thd-&gt;net));

  mysql_mutex_lock(&amp;LOCK_thread_count);
  add_global_thread(thd);
  mysql_mutex_unlock(&amp;LOCK_thread_count);
  thd-&gt;mysys_var= 0;
  return thd;
err:
  delete(thd);
  return NULL;
}


static void
emb_transfer_connect_attrs(MYSQL *mysql)
{
#ifdef HAVE_PSI_THREAD_INTERFACE
  if (mysql-&gt;options.extension &amp;&amp;
      mysql-&gt;options.extension-&gt;connection_attributes_length)
  {
    uchar *buf, *ptr;
    THD *thd= (THD*)mysql-&gt;thd;
    size_t length= mysql-&gt;options.extension-&gt;connection_attributes_length;

    /* 9 = max length of the serialized length */
    ptr= buf= (uchar *) my_alloca(length + 9);
    send_client_connect_attrs(mysql, buf);
    net_field_length_ll(&amp;ptr);
    PSI_THREAD_CALL(set_thread_connect_attrs)((char *) ptr, length, thd-&gt;charset());
    my_afree(buf);
  }
#endif
}


#ifdef NO_EMBEDDED_ACCESS_CHECKS
int check_embedded_connection(MYSQL *mysql, const char *db)
{
  int result;
  LEX_STRING db_str = { (char*)db, db ? strlen(db) : 0 };
  THD *thd= (THD*)mysql-&gt;thd;

  /* the server does the same as the client */
  mysql-&gt;server_capabilities= mysql-&gt;client_flag;

  thd_init_client_charset(thd, mysql-&gt;charset-&gt;number);
  thd-&gt;update_charset();
  Security_context *sctx= thd-&gt;security_ctx;
  sctx-&gt;set_host(my_localhost);
  sctx-&gt;host_or_ip= sctx-&gt;get_host()-&gt;ptr();
  strmake(sctx-&gt;priv_host, (char*) my_localhost,  MAX_HOSTNAME-1);
  strmake(sctx-&gt;priv_user, mysql-&gt;user,  USERNAME_LENGTH-1);
  sctx-&gt;user= my_strdup(mysql-&gt;user, MYF(0));
  sctx-&gt;proxy_user[0]= 0;
  sctx-&gt;master_access= GLOBAL_ACLS;       // Full rights
  emb_transfer_connect_attrs(mysql);
  /* Change database if necessary */
  if (!(result= (db &amp;&amp; db[0] &amp;&amp; mysql_change_db(thd, &amp;db_str, FALSE))))
    my_ok(thd);
  thd-&gt;protocol-&gt;end_statement();
  emb_read_query_result(mysql);
  return result;
}

#else
int check_embedded_connection(MYSQL *mysql, const char *db)
{
  /*
    we emulate a COM_CHANGE_USER user here,
    it's easier than to emulate the complete 3-way handshake
  */
  char *buf, *end;
  NET *net= &amp;mysql-&gt;net;
  THD *thd= (THD*)mysql-&gt;thd;
  Security_context *sctx= thd-&gt;security_ctx;
  size_t connect_attrs_len=
    (mysql-&gt;server_capabilities &amp; CLIENT_CONNECT_ATTRS &amp;&amp;
     mysql-&gt;options.extension) ?
    mysql-&gt;options.extension-&gt;connection_attributes_length : 0;

  buf= my_alloca(USERNAME_LENGTH + SCRAMBLE_LENGTH + 1 + 2*NAME_LEN + 2 +
                 connect_attrs_len + 2);
  if (mysql-&gt;options.client_ip)
  {
    sctx-&gt;set_host(my_strdup(mysql-&gt;options.client_ip, MYF(0)));
    sctx-&gt;set_ip(my_strdup(sctx-&gt;get_host()-&gt;ptr(), MYF(0)));
  }
  else
    sctx-&gt;set_host((char*)my_localhost);
  sctx-&gt;host_or_ip= sctx-&gt;host-&gt;ptr();

  if (acl_check_host(sctx-&gt;get_host()-&gt;ptr(), sctx-&gt;get_ip()-&gt;ptr()))
    goto err;

  /* construct a COM_CHANGE_USER packet */
  end= strmake(buf, mysql-&gt;user, USERNAME_LENGTH) + 1;

  memset(thd-&gt;scramble, 55, SCRAMBLE_LENGTH); // dummy scramble
  thd-&gt;scramble[SCRAMBLE_LENGTH]= 0;

  if (mysql-&gt;passwd &amp;&amp; mysql-&gt;passwd[0])
  {
    *end++= SCRAMBLE_LENGTH;
    scramble(end, thd-&gt;scramble, mysql-&gt;passwd);
    end+= SCRAMBLE_LENGTH;
  }
  else
    *end++= 0;

  end= strmake(end, db ? db : "", NAME_LEN) + 1;

  int2store(end, (ushort) mysql-&gt;charset-&gt;number);
  end+= 2;

  end= strmake(end, "mysql_native_password", NAME_LEN) + 1;

  /* the server does the same as the client */
  mysql-&gt;server_capabilities= mysql-&gt;client_flag;

  end= (char *) send_client_connect_attrs(mysql, (uchar *) end);

  /* acl_authenticate() takes the data from thd-&gt;net-&gt;read_pos */
  thd-&gt;net.read_pos= (uchar*)buf;

  if (acl_authenticate(thd, 0, end - buf))
  {
    x_free(thd-&gt;security_ctx-&gt;user);
    goto err;
  }
  my_afree(buf);
  return 0;
err:
  strmake(net-&gt;last_error, thd-&gt;main_da.message(), sizeof(net-&gt;last_error)-1);
  memcpy(net-&gt;sqlstate,
         mysql_errno_to_sqlstate(thd-&gt;main_da.sql_errno()),
         sizeof(net-&gt;sqlstate)-1);
  my_afree(buf);
  return 1;
}
#endif

} // extern "C"


void THD::clear_data_list()
{
  while (first_data)
  {
    MYSQL_DATA *data= first_data;
    first_data= data-&gt;embedded_info-&gt;next;
    free_rows(data);
  }
  data_tail= &amp;first_data;
  free_rows(cur_data);
  cur_data= 0;
}


static char *dup_str_aux(MEM_ROOT *root, const char *from, uint length,
			 const CHARSET_INFO *fromcs, const CHARSET_INFO *tocs)
{
  uint32 dummy32;
  uint dummy_err;
  char *result;

  /* 'tocs' is set 0 when client issues SET character_set_results=NULL */
  if (tocs &amp;&amp; String::needs_conversion(0, fromcs, tocs, &amp;dummy32))
  {
    uint new_len= (tocs-&gt;mbmaxlen * length) / fromcs-&gt;mbminlen + 1;
    result= (char *)alloc_root(root, new_len);
    length= copy_and_convert(result, new_len,
                             tocs, from, length, fromcs, &amp;dummy_err);
  }
  else
  {
    result= (char *)alloc_root(root, length + 1);
    memcpy(result, from, length);
  }

  result[length]= 0;
  return result;
}


/*
  creates new result and hooks it to the list

  SYNOPSIS
  alloc_new_dataset()

  NOTES
    allocs the MYSQL_DATA + embedded_query_result couple
    to store the next query result,
    links these two and attach it to the THD::data_tail

  RETURN
    pointer to the newly created query result
*/

MYSQL_DATA *THD::alloc_new_dataset()
{
  MYSQL_DATA *data;
  struct embedded_query_result *emb_data;
  if (!my_multi_malloc(MYF(MY_WME | MY_ZEROFILL),
                       &amp;data, sizeof(*data),
                       &amp;emb_data, sizeof(*emb_data),
                       NULL))
    return NULL;

  emb_data-&gt;prev_ptr= &amp;data-&gt;data;
  cur_data= data;
  *data_tail= data;
  data_tail= &amp;emb_data-&gt;next;
  data-&gt;embedded_info= emb_data;
  return data;
}


/**
  Stores server_status and warning_count in the current
  query result structures.

  @param thd            current thread

  @note Should be called after we get the recordset-result.
*/

static
bool
write_eof_packet(THD *thd, uint server_status, uint statement_warn_count)
{
  if (!thd-&gt;mysql)            // bootstrap file handling
    return FALSE;
  /*
    The following test should never be true, but it's better to do it
    because if 'is_fatal_error' is set the server is not going to execute
    other queries (see the if test in dispatch_command / COM_QUERY)
  */
  if (thd-&gt;is_fatal_error)
    thd-&gt;server_status&amp;= ~SERVER_MORE_RESULTS_EXISTS;
  thd-&gt;cur_data-&gt;embedded_info-&gt;server_status= server_status;
  /*
    Don't send warn count during SP execution, as the warn_list
    is cleared between substatements, and mysqltest gets confused
  */
  thd-&gt;cur_data-&gt;embedded_info-&gt;warning_count=
    (thd-&gt;sp_runtime_ctx ? 0 : min(statement_warn_count, 65535U));
  return FALSE;
}


/*
  allocs new query result and initialises Protocol::alloc

  SYNOPSIS
  Protocol::begin_dataset()

  RETURN
    0 if success
    1 if memory allocation failed
*/

int Protocol::begin_dataset()
{
  MYSQL_DATA *data= thd-&gt;alloc_new_dataset();
  if (!data)
    return 1;
  alloc= &amp;data-&gt;alloc;
  init_alloc_root(alloc,8192,0);	/* Assume rowlength &lt; 8192 */
  alloc-&gt;min_malloc=sizeof(MYSQL_ROWS);
  return 0;
}


/*
  remove last row of current recordset

  SYNOPSIS
  Protocol_text::remove_last_row()

  NOTES
    does the loop from the beginning of the current recordset to
    the last record and cuts it off.
    Not supposed to be frequently called.
*/

void Protocol_text::remove_last_row()
{
  MYSQL_DATA *data= thd-&gt;cur_data;
  MYSQL_ROWS **last_row_hook= &amp;data-&gt;data;
  my_ulonglong count= data-&gt;rows;
  DBUG_ENTER("Protocol_text::remove_last_row");
  while (--count)
    last_row_hook= &amp;(*last_row_hook)-&gt;next;

  *last_row_hook= 0;
  data-&gt;embedded_info-&gt;prev_ptr= last_row_hook;
  data-&gt;rows--;

  DBUG_VOID_RETURN;
}


bool Protocol::send_result_set_metadata(List&lt;Item&gt; *list, uint flags)
{
  List_iterator_fast&lt;Item&gt; it(*list);
  Item                     *item;
  MYSQL_FIELD              *client_field;
  MEM_ROOT                 *field_alloc;
  const CHARSET_INFO       *thd_cs= thd-&gt;variables.character_set_results;
  const CHARSET_INFO       *cs= system_charset_info;
  MYSQL_DATA               *data;
  DBUG_ENTER("send_result_set_metadata");

  if (!thd-&gt;mysql)            // bootstrap file handling
    DBUG_RETURN(0);

  if (begin_dataset())
    goto err;

  data= thd-&gt;cur_data;
  data-&gt;fields= field_count= list-&gt;elements;
  field_alloc= &amp;data-&gt;alloc;

  if (!(client_field= data-&gt;embedded_info-&gt;fields_list= 
	(MYSQL_FIELD*)alloc_root(field_alloc, sizeof(MYSQL_FIELD)*field_count)))
    goto err;

  while ((item= it++))
  {
    Send_field server_field;
    item-&gt;make_field(&amp;server_field);

    /* Keep things compatible for old clients */
    if (server_field.type == MYSQL_TYPE_VARCHAR)
      server_field.type= MYSQL_TYPE_VAR_STRING;

    client_field-&gt;db= dup_str_aux(field_alloc, server_field.db_name,
                                  strlen(server_field.db_name), cs, thd_cs);
    client_field-&gt;table= dup_str_aux(field_alloc, server_field.table_name,
                                     strlen(server_field.table_name), cs, thd_cs);
    client_field-&gt;name= dup_str_aux(field_alloc, server_field.col_name,
                                    strlen(server_field.col_name), cs, thd_cs);
    client_field-&gt;org_table= dup_str_aux(field_alloc, server_field.org_table_name,
                                         strlen(server_field.org_table_name), cs, thd_cs);
    client_field-&gt;org_name= dup_str_aux(field_alloc, server_field.org_col_name,
                                        strlen(server_field.org_col_name), cs, thd_cs);
    if (item-&gt;charset_for_protocol() == &amp;my_charset_bin || thd_cs == NULL)
    {
      /* No conversion */
      client_field-&gt;charsetnr= item-&gt;charset_for_protocol()-&gt;number;
      client_field-&gt;length= server_field.length;
    }
    else
    {
      uint max_char_len;
      /* With conversion */
      client_field-&gt;charsetnr= thd_cs-&gt;number;
      max_char_len= (server_field.type &gt;= (int) MYSQL_TYPE_TINY_BLOB &amp;&amp;
                     server_field.type &lt;= (int) MYSQL_TYPE_BLOB) ?
                     server_field.length / item-&gt;collation.collation-&gt;mbminlen :
                     server_field.length / item-&gt;collation.collation-&gt;mbmaxlen;
      client_field-&gt;length= char_to_byte_length_safe(max_char_len,
                                                     thd_cs-&gt;mbmaxlen);
    }
    client_field-&gt;type=   server_field.type;
    client_field-&gt;flags= server_field.flags;
    client_field-&gt;decimals= server_field.decimals;
    client_field-&gt;db_length=		strlen(client_field-&gt;db);
    client_field-&gt;table_length=		strlen(client_field-&gt;table);
    client_field-&gt;name_length=		strlen(client_field-&gt;name);
    client_field-&gt;org_name_length=	strlen(client_field-&gt;org_name);
    client_field-&gt;org_table_length=	strlen(client_field-&gt;org_table);

    client_field-&gt;catalog= dup_str_aux(field_alloc, "def", 3, cs, thd_cs);
    client_field-&gt;catalog_length= 3;

    if (IS_NUM(client_field-&gt;type))
      client_field-&gt;flags|= NUM_FLAG;

    if (flags &amp; (int) Protocol::SEND_DEFAULTS)
    {
      char buff[80];
      String tmp(buff, sizeof(buff), default_charset_info), *res;

      if (!(res=item-&gt;val_str(&amp;tmp)))
      {
	client_field-&gt;def_length= 0;
	client_field-&gt;def= strmake_root(field_alloc, "",0);
      }
      else
      {
	client_field-&gt;def_length= res-&gt;length();
	client_field-&gt;def= strmake_root(field_alloc, res-&gt;ptr(),
					client_field-&gt;def_length);
      }
    }
    else
      client_field-&gt;def=0;
    client_field-&gt;max_length= 0;
    ++client_field;
  }

  if (flags &amp; SEND_EOF)
    write_eof_packet(thd, thd-&gt;server_status,
                     thd-&gt;get_stmt_da()-&gt;current_statement_warn_count());

  DBUG_RETURN(prepare_for_send(list-&gt;elements));
 err:
  my_error(ER_OUT_OF_RESOURCES, MYF(0));        /* purecov: inspected */
  DBUG_RETURN(1);				/* purecov: inspected */
}

bool Protocol::write()
{
  if (!thd-&gt;mysql)            // bootstrap file handling
    return false;

  *next_field= 0;
  return false;
}

bool Protocol_binary::write()
{
  MYSQL_ROWS *cur;
  MYSQL_DATA *data= thd-&gt;cur_data;

  data-&gt;rows++;
  if (!(cur= (MYSQL_ROWS *)alloc_root(alloc,
                                      sizeof(MYSQL_ROWS)+packet-&gt;length())))
  {
    my_error(ER_OUT_OF_RESOURCES,MYF(0));
    return true;
  }
  cur-&gt;data= (MYSQL_ROW)(((char *)cur) + sizeof(MYSQL_ROWS));
  memcpy(cur-&gt;data, packet-&gt;ptr()+1, packet-&gt;length()-1);
  cur-&gt;length= packet-&gt;length();       /* To allow us to do sanity checks */

  *data-&gt;embedded_info-&gt;prev_ptr= cur;
  data-&gt;embedded_info-&gt;prev_ptr= &amp;cur-&gt;next;
  cur-&gt;next= 0;
  
  return false;
}


/**
  Embedded library implementation of OK response.

  This function is used by the server to write 'OK' packet to
  the "network" when the server is compiled as an embedded library.
  Since there is no network in the embedded configuration,
  a different implementation is necessary.
  Instead of marshalling response parameters to a network representation
  and then writing it to the socket, here we simply copy the data to the
  corresponding client-side connection structures. 

  @sa Server implementation of net_send_ok in protocol.cc for
  description of the arguments.

  @return
    @retval TRUE An error occurred
    @retval FALSE Success
*/

bool
net_send_ok(THD *thd,
            uint server_status, uint statement_warn_count,
            ulonglong affected_rows, ulonglong id, const char *message)
{
  DBUG_ENTER("emb_net_send_ok");
  MYSQL_DATA *data;
  MYSQL *mysql= thd-&gt;mysql;

  if (!mysql)            // bootstrap file handling
    DBUG_RETURN(FALSE);
  if (!(data= thd-&gt;alloc_new_dataset()))
    DBUG_RETURN(TRUE);
  data-&gt;embedded_info-&gt;affected_rows= affected_rows;
  data-&gt;embedded_info-&gt;insert_id= id;
  if (message)
    strmake(data-&gt;embedded_info-&gt;info, message,
            sizeof(data-&gt;embedded_info-&gt;info)-1);

  bool error= write_eof_packet(thd, server_status, statement_warn_count);
  thd-&gt;cur_data= 0;
  DBUG_RETURN(error);
}


/**
  Embedded library implementation of EOF response.

  @sa net_send_ok

  @return
    @retval TRUE  An error occurred
    @retval FALSE Success
*/

bool
net_send_eof(THD *thd, uint server_status, uint statement_warn_count)
{
  bool error= write_eof_packet(thd, server_status, statement_warn_count);
  thd-&gt;cur_data= 0;
  return error;
}


bool net_send_error_packet(THD *thd, uint sql_errno, const char *err,
                           const char *sqlstate)
{
  uint error;
  char converted_err[MYSQL_ERRMSG_SIZE];
  MYSQL_DATA *data= thd-&gt;cur_data;
  struct embedded_query_result *ei;

  if (!thd-&gt;mysql)            // bootstrap file handling
  {
    fprintf(stderr, "ERROR: %d  %s\n", sql_errno, err);
    return TRUE;
  }

  if (!data)
    data= thd-&gt;alloc_new_dataset();

  ei= data-&gt;embedded_info;
  ei-&gt;last_errno= sql_errno;
  convert_error_message(converted_err, sizeof(converted_err),
                        thd-&gt;variables.character_set_results,
                        err, strlen(err),
                        system_charset_info, &amp;error);
  /* Converted error message is always null-terminated. */
  strmake(ei-&gt;info, converted_err, sizeof(ei-&gt;info)-1);
  strmov(ei-&gt;sqlstate, sqlstate);
  ei-&gt;server_status= thd-&gt;server_status;
  thd-&gt;cur_data= 0;
  return FALSE;
}

void Protocol_binary::prepare_for_resend()
{
  MYSQL_DATA *data= thd-&gt;cur_data;
  next_mysql_field= data-&gt;embedded_info-&gt;fields_list;
  packet-&gt;length(bit_fields + 1);
  memset(const_cast&lt;char*&gt;(packet-&gt;ptr()), 0, 1 + bit_fields);
  field_pos= 0;
}

void Protocol_text::prepare_for_resend()
{
  MYSQL_ROWS *cur;
  MYSQL_DATA *data= thd-&gt;cur_data;
  DBUG_ENTER("send_data");

  if (!thd-&gt;mysql)            // bootstrap file handling
    DBUG_VOID_RETURN;

  data-&gt;rows++;
  if (!(cur= (MYSQL_ROWS *)alloc_root(alloc, sizeof(MYSQL_ROWS)+(field_count + 1) * sizeof(char *))))
  {
    my_error(ER_OUT_OF_RESOURCES,MYF(0));
    DBUG_VOID_RETURN;
  }
  cur-&gt;data= (MYSQL_ROW)(((char *)cur) + sizeof(MYSQL_ROWS));

  *data-&gt;embedded_info-&gt;prev_ptr= cur;
  data-&gt;embedded_info-&gt;prev_ptr= &amp;cur-&gt;next;
  next_field=cur-&gt;data;
  next_mysql_field= data-&gt;embedded_info-&gt;fields_list;
#ifndef DBUG_OFF
  field_pos= 0;
#endif

  DBUG_VOID_RETURN;
}

bool Protocol_text::store_null()
{
  *(next_field++)= NULL;
  ++next_mysql_field;
  return false;
}

bool Protocol_binary::net_store_data(const uchar *from, size_t length)
{
  if (!thd-&gt;mysql)            // bootstrap file handling
    return 0;

  ulong packet_length= packet-&gt;length();
  /*
     The +9 comes from that strings of length longer than 16M require
     9 bytes to be stored (see net_store_length).
  */
  if (packet_length + 9 + length &gt; packet-&gt;alloced_length() &amp;&amp;
      packet-&gt;realloc(packet_length + 9 + length))
    return 1;
  uchar *to= net_store_length((uchar*)packet-&gt;ptr() + packet_length, length);
  memcpy(to, from, length);
  packet-&gt;length((uint)(to + length - (uchar*)packet-&gt;ptr()));
  if (next_mysql_field-&gt;max_length &lt; length)
    next_mysql_field-&gt;max_length= length;
  ++next_mysql_field;
  return 0;
}

bool Protocol_binary::net_store_data(const uchar *from, size_t length,
                                     const CHARSET_INFO *from_cs,
                                     const CHARSET_INFO *to_cs)
{
  uint dummy_errors;
  /* Calculate maxumum possible result length */
  uint conv_length= to_cs-&gt;mbmaxlen * length / from_cs-&gt;mbminlen;

  if (!thd-&gt;mysql)            // bootstrap file handling
    return 0;

  if (conv_length &gt; 250)
  {
    /*
      For strings with conv_length greater than 250 bytes
      we don't know how many bytes we will need to store length: one or two,
      because we don't know result length until conversion is done.
      For example, when converting from utf8 (mbmaxlen=3) to latin1,
      conv_length=300 means that the result length can vary between 100 to 300.
      length=100 needs one byte, length=300 needs to bytes.

      Thus conversion directly to "packet" is not worthy.
      Let's use "convert" as a temporary buffer.
    */
    return (convert-&gt;copy((const char*)from, length, from_cs,
                          to_cs, &amp;dummy_errors) ||
            net_store_data((const uchar*)convert-&gt;ptr(), convert-&gt;length()));
  }

  ulong packet_length= packet-&gt;length();
  ulong new_length= packet_length + conv_length + 1;

  if (new_length &gt; packet-&gt;alloced_length() &amp;&amp; packet-&gt;realloc(new_length))
    return 1;

  char *length_pos= (char*) packet-&gt;ptr() + packet_length;
  char *to= length_pos + 1;

  to+= length= copy_and_convert(to, conv_length, to_cs,
                                (const char*)from, length, from_cs,
                                &amp;dummy_errors);

  net_store_length((uchar*)length_pos, to - length_pos - 1);
  packet-&gt;length((uint)(to - packet-&gt;ptr()));
  if (next_mysql_field-&gt;max_length &lt; length)
    next_mysql_field-&gt;max_length= length;
  ++next_mysql_field;
  return 0;
}

bool Protocol::net_store_data(const uchar *from, size_t length)
{
  char *field_buf;
  if (!thd-&gt;mysql)            // bootstrap file handling
    return FALSE;

  if (!(field_buf= (char*) alloc_root(alloc, length + sizeof(uint) + 1)))
    return TRUE;
  *(uint *)field_buf= length;
  *next_field= field_buf + sizeof(uint);
  memcpy((uchar*) *next_field, from, length);
  (*next_field)[length]= 0;
  if (next_mysql_field-&gt;max_length &lt; length)
    next_mysql_field-&gt;max_length=length;
  ++next_field;
  ++next_mysql_field;
  return FALSE;
}

#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400
#define vsnprintf _vsnprintf
#endif

int vprint_msg_to_log(enum loglevel level MY_ATTRIBUTE((unused)),
                       const char *format, va_list argsi)
{
  my_vsnprintf(mysql_server_last_error, sizeof(mysql_server_last_error),
               format, argsi);
  mysql_server_last_errno= CR_UNKNOWN_ERROR;
  return 0;
}


bool Protocol::net_store_data(const uchar *from, size_t length,
                              const CHARSET_INFO *from_cs,
                              const CHARSET_INFO *to_cs)
{
  uint conv_length= to_cs-&gt;mbmaxlen * length / from_cs-&gt;mbminlen;
  uint dummy_error;
  char *field_buf;
  if (!thd-&gt;mysql)            // bootstrap file handling
    return false;

  if (!(field_buf= (char*) alloc_root(alloc, conv_length + sizeof(uint) + 1)))
    return true;
  *next_field= field_buf + sizeof(uint);
  length= copy_and_convert(*next_field, conv_length, to_cs,
                           (const char*) from, length, from_cs, &amp;dummy_error);
  *(uint *) field_buf= length;
  (*next_field)[length]= 0;
  if (next_mysql_field-&gt;max_length &lt; length)
    next_mysql_field-&gt;max_length= length;
  ++next_field;
  ++next_mysql_field;
  return false;
}
      </pre>
    </body>
</html>
