<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8"/>
        <title>Modules/sre_lib.h</title>
        <link rel="stylesheet" type="text/css" href="../css/prettyprint.css"/>
        <script type="text/javascript" src="../js/prettyprint.js"></script>
    </head>
    <body onload="prettyPrint()">
		<pre class="prettyprint lang-cpp linenums">
/*
 * Secret Labs' Regular Expression Engine
 *
 * regular expression matching engine
 *
 * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
 *
 * See the _sre.c file for information on usage and redistribution.
 */

/* String matching engine */

/* This file is included three times, with different character settings */

LOCAL(int)
SRE(at)(SRE_STATE* state, SRE_CHAR* ptr, SRE_CODE at)
{
    /* check if pointer is at given position */

    Py_ssize_t thisp, thatp;

    switch (at) {

    case SRE_AT_BEGINNING:
    case SRE_AT_BEGINNING_STRING:
        return ((void*) ptr == state-&gt;beginning);

    case SRE_AT_BEGINNING_LINE:
        return ((void*) ptr == state-&gt;beginning ||
                SRE_IS_LINEBREAK((int) ptr[-1]));

    case SRE_AT_END:
        return (((SRE_CHAR *)state-&gt;end - ptr == 1 &amp;&amp;
                 SRE_IS_LINEBREAK((int) ptr[0])) ||
                ((void*) ptr == state-&gt;end));

    case SRE_AT_END_LINE:
        return ((void*) ptr == state-&gt;end ||
                SRE_IS_LINEBREAK((int) ptr[0]));

    case SRE_AT_END_STRING:
        return ((void*) ptr == state-&gt;end);

    case SRE_AT_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_IS_WORD((int) ptr[0]) : 0;
        return thisp != thatp;

    case SRE_AT_NON_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_IS_WORD((int) ptr[0]) : 0;
        return thisp == thatp;

    case SRE_AT_LOC_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_LOC_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_LOC_IS_WORD((int) ptr[0]) : 0;
        return thisp != thatp;

    case SRE_AT_LOC_NON_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_LOC_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_LOC_IS_WORD((int) ptr[0]) : 0;
        return thisp == thatp;

    case SRE_AT_UNI_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_UNI_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_UNI_IS_WORD((int) ptr[0]) : 0;
        return thisp != thatp;

    case SRE_AT_UNI_NON_BOUNDARY:
        if (state-&gt;beginning == state-&gt;end)
            return 0;
        thatp = ((void*) ptr &gt; state-&gt;beginning) ?
            SRE_UNI_IS_WORD((int) ptr[-1]) : 0;
        thisp = ((void*) ptr &lt; state-&gt;end) ?
            SRE_UNI_IS_WORD((int) ptr[0]) : 0;
        return thisp == thatp;

    }

    return 0;
}

LOCAL(int)
SRE(charset)(SRE_STATE* state, SRE_CODE* set, SRE_CODE ch)
{
    /* check if character is a member of the given set */

    int ok = 1;

    for (;;) {
        switch (*set++) {

        case SRE_OP_FAILURE:
            return !ok;

        case SRE_OP_LITERAL:
            /* &lt;LITERAL&gt; &lt;code&gt; */
            if (ch == set[0])
                return ok;
            set++;
            break;

        case SRE_OP_CATEGORY:
            /* &lt;CATEGORY&gt; &lt;code&gt; */
            if (sre_category(set[0], (int) ch))
                return ok;
            set++;
            break;

        case SRE_OP_CHARSET:
            /* &lt;CHARSET&gt; &lt;bitmap&gt; */
            if (ch &lt; 256 &amp;&amp;
                (set[ch/SRE_CODE_BITS] &amp; (1u &lt;&lt; (ch &amp; (SRE_CODE_BITS-1)))))
                return ok;
            set += 256/SRE_CODE_BITS;
            break;

        case SRE_OP_RANGE:
            /* &lt;RANGE&gt; &lt;lower&gt; &lt;upper&gt; */
            if (set[0] &lt;= ch &amp;&amp; ch &lt;= set[1])
                return ok;
            set += 2;
            break;

        case SRE_OP_RANGE_UNI_IGNORE:
            /* &lt;RANGE_UNI_IGNORE&gt; &lt;lower&gt; &lt;upper&gt; */
        {
            SRE_CODE uch;
            /* ch is already lower cased */
            if (set[0] &lt;= ch &amp;&amp; ch &lt;= set[1])
                return ok;
            uch = sre_upper_unicode(ch);
            if (set[0] &lt;= uch &amp;&amp; uch &lt;= set[1])
                return ok;
            set += 2;
            break;
        }

        case SRE_OP_NEGATE:
            ok = !ok;
            break;

        case SRE_OP_BIGCHARSET:
            /* &lt;BIGCHARSET&gt; &lt;blockcount&gt; &lt;256 blockindices&gt; &lt;blocks&gt; */
        {
            Py_ssize_t count, block;
            count = *(set++);

            if (ch &lt; 0x10000u)
                block = ((unsigned char*)set)[ch &gt;&gt; 8];
            else
                block = -1;
            set += 256/sizeof(SRE_CODE);
            if (block &gt;=0 &amp;&amp;
                (set[(block * 256 + (ch &amp; 255))/SRE_CODE_BITS] &amp;
                    (1u &lt;&lt; (ch &amp; (SRE_CODE_BITS-1)))))
                return ok;
            set += count * (256/SRE_CODE_BITS);
            break;
        }

        default:
            /* internal error -- there's not much we can do about it
               here, so let's just pretend it didn't match... */
            return 0;
        }
    }
}

LOCAL(int)
SRE(charset_loc_ignore)(SRE_STATE* state, SRE_CODE* set, SRE_CODE ch)
{
    SRE_CODE lo, up;
    lo = sre_lower_locale(ch);
    if (SRE(charset)(state, set, lo))
       return 1;

    up = sre_upper_locale(ch);
    return up != lo &amp;&amp; SRE(charset)(state, set, up);
}

LOCAL(Py_ssize_t) SRE(match)(SRE_STATE* state, SRE_CODE* pattern, int toplevel);

LOCAL(Py_ssize_t)
SRE(count)(SRE_STATE* state, SRE_CODE* pattern, Py_ssize_t maxcount)
{
    SRE_CODE chr;
    SRE_CHAR c;
    SRE_CHAR* ptr = (SRE_CHAR *)state-&gt;ptr;
    SRE_CHAR* end = (SRE_CHAR *)state-&gt;end;
    Py_ssize_t i;

    /* adjust end */
    if (maxcount &lt; end - ptr &amp;&amp; maxcount != SRE_MAXREPEAT)
        end = ptr + maxcount;

    switch (pattern[0]) {

    case SRE_OP_IN:
        /* repeated set */
        TRACE(("|%p|%p|COUNT IN\n", pattern, ptr));
        while (ptr &lt; end &amp;&amp; SRE(charset)(state, pattern + 2, *ptr))
            ptr++;
        break;

    case SRE_OP_ANY:
        /* repeated dot wildcard. */
        TRACE(("|%p|%p|COUNT ANY\n", pattern, ptr));
        while (ptr &lt; end &amp;&amp; !SRE_IS_LINEBREAK(*ptr))
            ptr++;
        break;

    case SRE_OP_ANY_ALL:
        /* repeated dot wildcard.  skip to the end of the target
           string, and backtrack from there */
        TRACE(("|%p|%p|COUNT ANY_ALL\n", pattern, ptr));
        ptr = end;
        break;

    case SRE_OP_LITERAL:
        /* repeated literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT LITERAL %d\n", pattern, ptr, chr));
        c = (SRE_CHAR) chr;
#if SIZEOF_SRE_CHAR &lt; 4
        if ((SRE_CODE) c != chr)
            ; /* literal can't match: doesn't fit in char width */
        else
#endif
        while (ptr &lt; end &amp;&amp; *ptr == c)
            ptr++;
        break;

    case SRE_OP_LITERAL_IGNORE:
        /* repeated literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT LITERAL_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; (SRE_CODE) sre_lower_ascii(*ptr) == chr)
            ptr++;
        break;

    case SRE_OP_LITERAL_UNI_IGNORE:
        /* repeated literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT LITERAL_UNI_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; (SRE_CODE) sre_lower_unicode(*ptr) == chr)
            ptr++;
        break;

    case SRE_OP_LITERAL_LOC_IGNORE:
        /* repeated literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT LITERAL_LOC_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; char_loc_ignore(chr, *ptr))
            ptr++;
        break;

    case SRE_OP_NOT_LITERAL:
        /* repeated non-literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT NOT_LITERAL %d\n", pattern, ptr, chr));
        c = (SRE_CHAR) chr;
#if SIZEOF_SRE_CHAR &lt; 4
        if ((SRE_CODE) c != chr)
            ptr = end; /* literal can't match: doesn't fit in char width */
        else
#endif
        while (ptr &lt; end &amp;&amp; *ptr != c)
            ptr++;
        break;

    case SRE_OP_NOT_LITERAL_IGNORE:
        /* repeated non-literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT NOT_LITERAL_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; (SRE_CODE) sre_lower_ascii(*ptr) != chr)
            ptr++;
        break;

    case SRE_OP_NOT_LITERAL_UNI_IGNORE:
        /* repeated non-literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT NOT_LITERAL_UNI_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; (SRE_CODE) sre_lower_unicode(*ptr) != chr)
            ptr++;
        break;

    case SRE_OP_NOT_LITERAL_LOC_IGNORE:
        /* repeated non-literal */
        chr = pattern[1];
        TRACE(("|%p|%p|COUNT NOT_LITERAL_LOC_IGNORE %d\n", pattern, ptr, chr));
        while (ptr &lt; end &amp;&amp; !char_loc_ignore(chr, *ptr))
            ptr++;
        break;

    default:
        /* repeated single character pattern */
        TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
        while ((SRE_CHAR*) state-&gt;ptr &lt; end) {
            i = SRE(match)(state, pattern, 0);
            if (i &lt; 0)
                return i;
            if (!i)
                break;
        }
        TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
               (SRE_CHAR*) state-&gt;ptr - ptr));
        return (SRE_CHAR*) state-&gt;ptr - ptr;
    }

    TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
           ptr - (SRE_CHAR*) state-&gt;ptr));
    return ptr - (SRE_CHAR*) state-&gt;ptr;
}

#if 0 /* not used in this release */
LOCAL(int)
SRE(info)(SRE_STATE* state, SRE_CODE* pattern)
{
    /* check if an SRE_OP_INFO block matches at the current position.
       returns the number of SRE_CODE objects to skip if successful, 0
       if no match */

    SRE_CHAR* end = (SRE_CHAR*) state-&gt;end;
    SRE_CHAR* ptr = (SRE_CHAR*) state-&gt;ptr;
    Py_ssize_t i;

    /* check minimal length */
    if (pattern[3] &amp;&amp; end - ptr &lt; pattern[3])
        return 0;

    /* check known prefix */
    if (pattern[2] &amp; SRE_INFO_PREFIX &amp;&amp; pattern[5] &gt; 1) {
        /* &lt;length&gt; &lt;skip&gt; &lt;prefix data&gt; &lt;overlap data&gt; */
        for (i = 0; i &lt; pattern[5]; i++)
            if ((SRE_CODE) ptr[i] != pattern[7 + i])
                return 0;
        return pattern[0] + 2 * pattern[6];
    }
    return pattern[0];
}
#endif

/* The macros below should be used to protect recursive SRE(match)()
 * calls that *failed* and do *not* return immediately (IOW, those
 * that will backtrack). Explaining:
 *
 * - Recursive SRE(match)() returned true: that's usually a success
 *   (besides atypical cases like ASSERT_NOT), therefore there's no
 *   reason to restore lastmark;
 *
 * - Recursive SRE(match)() returned false but the current SRE(match)()
 *   is returning to the caller: If the current SRE(match)() is the
 *   top function of the recursion, returning false will be a matching
 *   failure, and it doesn't matter where lastmark is pointing to.
 *   If it's *not* the top function, it will be a recursive SRE(match)()
 *   failure by itself, and the calling SRE(match)() will have to deal
 *   with the failure by the same rules explained here (it will restore
 *   lastmark by itself if necessary);
 *
 * - Recursive SRE(match)() returned false, and will continue the
 *   outside 'for' loop: must be protected when breaking, since the next
 *   OP could potentially depend on lastmark;
 *
 * - Recursive SRE(match)() returned false, and will be called again
 *   inside a local for/while loop: must be protected between each
 *   loop iteration, since the recursive SRE(match)() could do anything,
 *   and could potentially depend on lastmark.
 *
 * For more information, check the discussion at SF patch #712900.
 */
#define LASTMARK_SAVE()     \
    do { \
        ctx-&gt;lastmark = state-&gt;lastmark; \
        ctx-&gt;lastindex = state-&gt;lastindex; \
    } while (0)
#define LASTMARK_RESTORE()  \
    do { \
        state-&gt;lastmark = ctx-&gt;lastmark; \
        state-&gt;lastindex = ctx-&gt;lastindex; \
    } while (0)

#define RETURN_ERROR(i) do { return i; } while(0)
#define RETURN_FAILURE do { ret = 0; goto exit; } while(0)
#define RETURN_SUCCESS do { ret = 1; goto exit; } while(0)

#define RETURN_ON_ERROR(i) \
    do { if (i &lt; 0) RETURN_ERROR(i); } while (0)
#define RETURN_ON_SUCCESS(i) \
    do { RETURN_ON_ERROR(i); if (i &gt; 0) RETURN_SUCCESS; } while (0)
#define RETURN_ON_FAILURE(i) \
    do { RETURN_ON_ERROR(i); if (i == 0) RETURN_FAILURE; } while (0)

#define DATA_STACK_ALLOC(state, type, ptr) \
do { \
    alloc_pos = state-&gt;data_stack_base; \
    TRACE(("allocating %s in %" PY_FORMAT_SIZE_T "d " \
           "(%" PY_FORMAT_SIZE_T "d)\n", \
           Py_STRINGIFY(type), alloc_pos, sizeof(type))); \
    if (sizeof(type) &gt; state-&gt;data_stack_size - alloc_pos) { \
        int j = data_stack_grow(state, sizeof(type)); \
        if (j &lt; 0) return j; \
        if (ctx_pos != -1) \
            DATA_STACK_LOOKUP_AT(state, SRE(match_context), ctx, ctx_pos); \
    } \
    ptr = (type*)(state-&gt;data_stack+alloc_pos); \
    state-&gt;data_stack_base += sizeof(type); \
} while (0)

#define DATA_STACK_LOOKUP_AT(state, type, ptr, pos) \
do { \
    TRACE(("looking up %s at %" PY_FORMAT_SIZE_T "d\n", Py_STRINGIFY(type), pos)); \
    ptr = (type*)(state-&gt;data_stack+pos); \
} while (0)

#define DATA_STACK_PUSH(state, data, size) \
do { \
    TRACE(("copy data in %p to %" PY_FORMAT_SIZE_T "d " \
           "(%" PY_FORMAT_SIZE_T "d)\n", \
           data, state-&gt;data_stack_base, size)); \
    if (size &gt; state-&gt;data_stack_size - state-&gt;data_stack_base) { \
        int j = data_stack_grow(state, size); \
        if (j &lt; 0) return j; \
        if (ctx_pos != -1) \
            DATA_STACK_LOOKUP_AT(state, SRE(match_context), ctx, ctx_pos); \
    } \
    memcpy(state-&gt;data_stack+state-&gt;data_stack_base, data, size); \
    state-&gt;data_stack_base += size; \
} while (0)

#define DATA_STACK_POP(state, data, size, discard) \
do { \
    TRACE(("copy data to %p from %" PY_FORMAT_SIZE_T "d " \
           "(%" PY_FORMAT_SIZE_T "d)\n", \
           data, state-&gt;data_stack_base-size, size)); \
    memcpy(data, state-&gt;data_stack+state-&gt;data_stack_base-size, size); \
    if (discard) \
        state-&gt;data_stack_base -= size; \
} while (0)

#define DATA_STACK_POP_DISCARD(state, size) \
do { \
    TRACE(("discard data from %" PY_FORMAT_SIZE_T "d " \
           "(%" PY_FORMAT_SIZE_T "d)\n", \
           state-&gt;data_stack_base-size, size)); \
    state-&gt;data_stack_base -= size; \
} while(0)

#define DATA_PUSH(x) \
    DATA_STACK_PUSH(state, (x), sizeof(*(x)))
#define DATA_POP(x) \
    DATA_STACK_POP(state, (x), sizeof(*(x)), 1)
#define DATA_POP_DISCARD(x) \
    DATA_STACK_POP_DISCARD(state, sizeof(*(x)))
#define DATA_ALLOC(t,p) \
    DATA_STACK_ALLOC(state, t, p)
#define DATA_LOOKUP_AT(t,p,pos) \
    DATA_STACK_LOOKUP_AT(state,t,p,pos)

#define MARK_PUSH(lastmark) \
    do if (lastmark &gt; 0) { \
        i = lastmark; /* ctx-&gt;lastmark may change if reallocated */ \
        DATA_STACK_PUSH(state, state-&gt;mark, (i+1)*sizeof(void*)); \
    } while (0)
#define MARK_POP(lastmark) \
    do if (lastmark &gt; 0) { \
        DATA_STACK_POP(state, state-&gt;mark, (lastmark+1)*sizeof(void*), 1); \
    } while (0)
#define MARK_POP_KEEP(lastmark) \
    do if (lastmark &gt; 0) { \
        DATA_STACK_POP(state, state-&gt;mark, (lastmark+1)*sizeof(void*), 0); \
    } while (0)
#define MARK_POP_DISCARD(lastmark) \
    do if (lastmark &gt; 0) { \
        DATA_STACK_POP_DISCARD(state, (lastmark+1)*sizeof(void*)); \
    } while (0)

#define JUMP_NONE            0
#define JUMP_MAX_UNTIL_1     1
#define JUMP_MAX_UNTIL_2     2
#define JUMP_MAX_UNTIL_3     3
#define JUMP_MIN_UNTIL_1     4
#define JUMP_MIN_UNTIL_2     5
#define JUMP_MIN_UNTIL_3     6
#define JUMP_REPEAT          7
#define JUMP_REPEAT_ONE_1    8
#define JUMP_REPEAT_ONE_2    9
#define JUMP_MIN_REPEAT_ONE  10
#define JUMP_BRANCH          11
#define JUMP_ASSERT          12
#define JUMP_ASSERT_NOT      13

#define DO_JUMPX(jumpvalue, jumplabel, nextpattern, toplevel_) \
    DATA_ALLOC(SRE(match_context), nextctx); \
    nextctx-&gt;last_ctx_pos = ctx_pos; \
    nextctx-&gt;jump = jumpvalue; \
    nextctx-&gt;pattern = nextpattern; \
    nextctx-&gt;toplevel = toplevel_; \
    ctx_pos = alloc_pos; \
    ctx = nextctx; \
    goto entrance; \
    jumplabel: \
    while (0) /* gcc doesn't like labels at end of scopes */ \

#define DO_JUMP(jumpvalue, jumplabel, nextpattern) \
    DO_JUMPX(jumpvalue, jumplabel, nextpattern, ctx-&gt;toplevel)

#define DO_JUMP0(jumpvalue, jumplabel, nextpattern) \
    DO_JUMPX(jumpvalue, jumplabel, nextpattern, 0)

typedef struct {
    Py_ssize_t last_ctx_pos;
    Py_ssize_t jump;
    SRE_CHAR* ptr;
    SRE_CODE* pattern;
    Py_ssize_t count;
    Py_ssize_t lastmark;
    Py_ssize_t lastindex;
    union {
        SRE_CODE chr;
        SRE_REPEAT* rep;
    } u;
    int toplevel;
} SRE(match_context);

/* check if string matches the given pattern.  returns &lt;0 for
   error, 0 for failure, and 1 for success */
LOCAL(Py_ssize_t)
SRE(match)(SRE_STATE* state, SRE_CODE* pattern, int toplevel)
{
    SRE_CHAR* end = (SRE_CHAR *)state-&gt;end;
    Py_ssize_t alloc_pos, ctx_pos = -1;
    Py_ssize_t i, ret = 0;
    Py_ssize_t jump;
    unsigned int sigcount=0;

    SRE(match_context)* ctx;
    SRE(match_context)* nextctx;

    TRACE(("|%p|%p|ENTER\n", pattern, state-&gt;ptr));

    DATA_ALLOC(SRE(match_context), ctx);
    ctx-&gt;last_ctx_pos = -1;
    ctx-&gt;jump = JUMP_NONE;
    ctx-&gt;pattern = pattern;
    ctx-&gt;toplevel = toplevel;
    ctx_pos = alloc_pos;

entrance:

    ctx-&gt;ptr = (SRE_CHAR *)state-&gt;ptr;

    if (ctx-&gt;pattern[0] == SRE_OP_INFO) {
        /* optimization info block */
        /* &lt;INFO&gt; &lt;1=skip&gt; &lt;2=flags&gt; &lt;3=min&gt; ... */
        if (ctx-&gt;pattern[3] &amp;&amp; (uintptr_t)(end - ctx-&gt;ptr) &lt; ctx-&gt;pattern[3]) {
            TRACE(("reject (got %" PY_FORMAT_SIZE_T "d chars, "
                   "need %" PY_FORMAT_SIZE_T "d)\n",
                   end - ctx-&gt;ptr, (Py_ssize_t) ctx-&gt;pattern[3]));
            RETURN_FAILURE;
        }
        ctx-&gt;pattern += ctx-&gt;pattern[1] + 1;
    }

    for (;;) {
        ++sigcount;
        if ((0 == (sigcount &amp; 0xfff)) &amp;&amp; PyErr_CheckSignals())
            RETURN_ERROR(SRE_ERROR_INTERRUPTED);

        switch (*ctx-&gt;pattern++) {

        case SRE_OP_MARK:
            /* set mark */
            /* &lt;MARK&gt; &lt;gid&gt; */
            TRACE(("|%p|%p|MARK %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            i = ctx-&gt;pattern[0];
            if (i &amp; 1)
                state-&gt;lastindex = i/2 + 1;
            if (i &gt; state-&gt;lastmark) {
                /* state-&gt;lastmark is the highest valid index in the
                   state-&gt;mark array.  If it is increased by more than 1,
                   the intervening marks must be set to NULL to signal
                   that these marks have not been encountered. */
                Py_ssize_t j = state-&gt;lastmark + 1;
                while (j &lt; i)
                    state-&gt;mark[j++] = NULL;
                state-&gt;lastmark = i;
            }
            state-&gt;mark[i] = ctx-&gt;ptr;
            ctx-&gt;pattern++;
            break;

        case SRE_OP_LITERAL:
            /* match literal string */
            /* &lt;LITERAL&gt; &lt;code&gt; */
            TRACE(("|%p|%p|LITERAL %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end || (SRE_CODE) ctx-&gt;ptr[0] != ctx-&gt;pattern[0])
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_NOT_LITERAL:
            /* match anything that is not literal character */
            /* &lt;NOT_LITERAL&gt; &lt;code&gt; */
            TRACE(("|%p|%p|NOT_LITERAL %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end || (SRE_CODE) ctx-&gt;ptr[0] == ctx-&gt;pattern[0])
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_SUCCESS:
            /* end of pattern */
            TRACE(("|%p|%p|SUCCESS\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;toplevel &amp;&amp;
                ((state-&gt;match_all &amp;&amp; ctx-&gt;ptr != state-&gt;end) ||
                 (state-&gt;must_advance &amp;&amp; ctx-&gt;ptr == state-&gt;start)))
            {
                RETURN_FAILURE;
            }
            state-&gt;ptr = ctx-&gt;ptr;
            RETURN_SUCCESS;

        case SRE_OP_AT:
            /* match at given position */
            /* &lt;AT&gt; &lt;code&gt; */
            TRACE(("|%p|%p|AT %d\n", ctx-&gt;pattern, ctx-&gt;ptr, *ctx-&gt;pattern));
            if (!SRE(at)(state, ctx-&gt;ptr, *ctx-&gt;pattern))
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            break;

        case SRE_OP_CATEGORY:
            /* match at given category */
            /* &lt;CATEGORY&gt; &lt;code&gt; */
            TRACE(("|%p|%p|CATEGORY %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end || !sre_category(ctx-&gt;pattern[0], ctx-&gt;ptr[0]))
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_ANY:
            /* match anything (except a newline) */
            /* &lt;ANY&gt; */
            TRACE(("|%p|%p|ANY\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end || SRE_IS_LINEBREAK(ctx-&gt;ptr[0]))
                RETURN_FAILURE;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_ANY_ALL:
            /* match anything */
            /* &lt;ANY_ALL&gt; */
            TRACE(("|%p|%p|ANY_ALL\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end)
                RETURN_FAILURE;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_IN:
            /* match set member (or non_member) */
            /* &lt;IN&gt; &lt;skip&gt; &lt;set&gt; */
            TRACE(("|%p|%p|IN\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end ||
                !SRE(charset)(state, ctx-&gt;pattern + 1, *ctx-&gt;ptr))
                RETURN_FAILURE;
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            ctx-&gt;ptr++;
            break;

        case SRE_OP_LITERAL_IGNORE:
            TRACE(("|%p|%p|LITERAL_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, ctx-&gt;pattern[0]));
            if (ctx-&gt;ptr &gt;= end ||
                sre_lower_ascii(*ctx-&gt;ptr) != *ctx-&gt;pattern)
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_LITERAL_UNI_IGNORE:
            TRACE(("|%p|%p|LITERAL_UNI_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, ctx-&gt;pattern[0]));
            if (ctx-&gt;ptr &gt;= end ||
                sre_lower_unicode(*ctx-&gt;ptr) != *ctx-&gt;pattern)
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_LITERAL_LOC_IGNORE:
            TRACE(("|%p|%p|LITERAL_LOC_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, ctx-&gt;pattern[0]));
            if (ctx-&gt;ptr &gt;= end
                || !char_loc_ignore(*ctx-&gt;pattern, *ctx-&gt;ptr))
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_NOT_LITERAL_IGNORE:
            TRACE(("|%p|%p|NOT_LITERAL_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end ||
                sre_lower_ascii(*ctx-&gt;ptr) == *ctx-&gt;pattern)
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_NOT_LITERAL_UNI_IGNORE:
            TRACE(("|%p|%p|NOT_LITERAL_UNI_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end ||
                sre_lower_unicode(*ctx-&gt;ptr) == *ctx-&gt;pattern)
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_NOT_LITERAL_LOC_IGNORE:
            TRACE(("|%p|%p|NOT_LITERAL_LOC_IGNORE %d\n",
                   ctx-&gt;pattern, ctx-&gt;ptr, *ctx-&gt;pattern));
            if (ctx-&gt;ptr &gt;= end
                || char_loc_ignore(*ctx-&gt;pattern, *ctx-&gt;ptr))
                RETURN_FAILURE;
            ctx-&gt;pattern++;
            ctx-&gt;ptr++;
            break;

        case SRE_OP_IN_IGNORE:
            TRACE(("|%p|%p|IN_IGNORE\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end
                || !SRE(charset)(state, ctx-&gt;pattern+1,
                                 (SRE_CODE)sre_lower_ascii(*ctx-&gt;ptr)))
                RETURN_FAILURE;
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            ctx-&gt;ptr++;
            break;

        case SRE_OP_IN_UNI_IGNORE:
            TRACE(("|%p|%p|IN_UNI_IGNORE\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end
                || !SRE(charset)(state, ctx-&gt;pattern+1,
                                 (SRE_CODE)sre_lower_unicode(*ctx-&gt;ptr)))
                RETURN_FAILURE;
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            ctx-&gt;ptr++;
            break;

        case SRE_OP_IN_LOC_IGNORE:
            TRACE(("|%p|%p|IN_LOC_IGNORE\n", ctx-&gt;pattern, ctx-&gt;ptr));
            if (ctx-&gt;ptr &gt;= end
                || !SRE(charset_loc_ignore)(state, ctx-&gt;pattern+1, *ctx-&gt;ptr))
                RETURN_FAILURE;
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            ctx-&gt;ptr++;
            break;

        case SRE_OP_JUMP:
        case SRE_OP_INFO:
            /* jump forward */
            /* &lt;JUMP&gt; &lt;offset&gt; */
            TRACE(("|%p|%p|JUMP %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            break;

        case SRE_OP_BRANCH:
            /* alternation */
            /* &lt;BRANCH&gt; &lt;0=skip&gt; code &lt;JUMP&gt; ... &lt;NULL&gt; */
            TRACE(("|%p|%p|BRANCH\n", ctx-&gt;pattern, ctx-&gt;ptr));
            LASTMARK_SAVE();
            ctx-&gt;u.rep = state-&gt;repeat;
            if (ctx-&gt;u.rep)
                MARK_PUSH(ctx-&gt;lastmark);
            for (; ctx-&gt;pattern[0]; ctx-&gt;pattern += ctx-&gt;pattern[0]) {
                if (ctx-&gt;pattern[1] == SRE_OP_LITERAL &amp;&amp;
                    (ctx-&gt;ptr &gt;= end ||
                     (SRE_CODE) *ctx-&gt;ptr != ctx-&gt;pattern[2]))
                    continue;
                if (ctx-&gt;pattern[1] == SRE_OP_IN &amp;&amp;
                    (ctx-&gt;ptr &gt;= end ||
                     !SRE(charset)(state, ctx-&gt;pattern + 3,
                                   (SRE_CODE) *ctx-&gt;ptr)))
                    continue;
                state-&gt;ptr = ctx-&gt;ptr;
                DO_JUMP(JUMP_BRANCH, jump_branch, ctx-&gt;pattern+1);
                if (ret) {
                    if (ctx-&gt;u.rep)
                        MARK_POP_DISCARD(ctx-&gt;lastmark);
                    RETURN_ON_ERROR(ret);
                    RETURN_SUCCESS;
                }
                if (ctx-&gt;u.rep)
                    MARK_POP_KEEP(ctx-&gt;lastmark);
                LASTMARK_RESTORE();
            }
            if (ctx-&gt;u.rep)
                MARK_POP_DISCARD(ctx-&gt;lastmark);
            RETURN_FAILURE;

        case SRE_OP_REPEAT_ONE:
            /* match repeated sequence (maximizing regexp) */

            /* this operator only works if the repeated item is
               exactly one character wide, and we're not already
               collecting backtracking points.  for other cases,
               use the MAX_REPEAT operator */

            /* &lt;REPEAT_ONE&gt; &lt;skip&gt; &lt;1=min&gt; &lt;2=max&gt; item &lt;SUCCESS&gt; tail */

            TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx-&gt;pattern, ctx-&gt;ptr,
                   ctx-&gt;pattern[1], ctx-&gt;pattern[2]));

            if ((Py_ssize_t) ctx-&gt;pattern[1] &gt; end - ctx-&gt;ptr)
                RETURN_FAILURE; /* cannot match */

            state-&gt;ptr = ctx-&gt;ptr;

            ret = SRE(count)(state, ctx-&gt;pattern+3, ctx-&gt;pattern[2]);
            RETURN_ON_ERROR(ret);
            DATA_LOOKUP_AT(SRE(match_context), ctx, ctx_pos);
            ctx-&gt;count = ret;
            ctx-&gt;ptr += ctx-&gt;count;

            /* when we arrive here, count contains the number of
               matches, and ctx-&gt;ptr points to the tail of the target
               string.  check if the rest of the pattern matches,
               and backtrack if not. */

            if (ctx-&gt;count &lt; (Py_ssize_t) ctx-&gt;pattern[1])
                RETURN_FAILURE;

            if (ctx-&gt;pattern[ctx-&gt;pattern[0]] == SRE_OP_SUCCESS &amp;&amp;
                ctx-&gt;ptr == state-&gt;end &amp;&amp;
                !(ctx-&gt;toplevel &amp;&amp; state-&gt;must_advance &amp;&amp; ctx-&gt;ptr == state-&gt;start))
            {
                /* tail is empty.  we're finished */
                state-&gt;ptr = ctx-&gt;ptr;
                RETURN_SUCCESS;
            }

            LASTMARK_SAVE();

            if (ctx-&gt;pattern[ctx-&gt;pattern[0]] == SRE_OP_LITERAL) {
                /* tail starts with a literal. skip positions where
                   the rest of the pattern cannot possibly match */
                ctx-&gt;u.chr = ctx-&gt;pattern[ctx-&gt;pattern[0]+1];
                for (;;) {
                    while (ctx-&gt;count &gt;= (Py_ssize_t) ctx-&gt;pattern[1] &amp;&amp;
                           (ctx-&gt;ptr &gt;= end || *ctx-&gt;ptr != ctx-&gt;u.chr)) {
                        ctx-&gt;ptr--;
                        ctx-&gt;count--;
                    }
                    if (ctx-&gt;count &lt; (Py_ssize_t) ctx-&gt;pattern[1])
                        break;
                    state-&gt;ptr = ctx-&gt;ptr;
                    DO_JUMP(JUMP_REPEAT_ONE_1, jump_repeat_one_1,
                            ctx-&gt;pattern+ctx-&gt;pattern[0]);
                    if (ret) {
                        RETURN_ON_ERROR(ret);
                        RETURN_SUCCESS;
                    }

                    LASTMARK_RESTORE();

                    ctx-&gt;ptr--;
                    ctx-&gt;count--;
                }

            } else {
                /* general case */
                while (ctx-&gt;count &gt;= (Py_ssize_t) ctx-&gt;pattern[1]) {
                    state-&gt;ptr = ctx-&gt;ptr;
                    DO_JUMP(JUMP_REPEAT_ONE_2, jump_repeat_one_2,
                            ctx-&gt;pattern+ctx-&gt;pattern[0]);
                    if (ret) {
                        RETURN_ON_ERROR(ret);
                        RETURN_SUCCESS;
                    }
                    ctx-&gt;ptr--;
                    ctx-&gt;count--;
                    LASTMARK_RESTORE();
                }
            }
            RETURN_FAILURE;

        case SRE_OP_MIN_REPEAT_ONE:
            /* match repeated sequence (minimizing regexp) */

            /* this operator only works if the repeated item is
               exactly one character wide, and we're not already
               collecting backtracking points.  for other cases,
               use the MIN_REPEAT operator */

            /* &lt;MIN_REPEAT_ONE&gt; &lt;skip&gt; &lt;1=min&gt; &lt;2=max&gt; item &lt;SUCCESS&gt; tail */

            TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx-&gt;pattern, ctx-&gt;ptr,
                   ctx-&gt;pattern[1], ctx-&gt;pattern[2]));

            if ((Py_ssize_t) ctx-&gt;pattern[1] &gt; end - ctx-&gt;ptr)
                RETURN_FAILURE; /* cannot match */

            state-&gt;ptr = ctx-&gt;ptr;

            if (ctx-&gt;pattern[1] == 0)
                ctx-&gt;count = 0;
            else {
                /* count using pattern min as the maximum */
                ret = SRE(count)(state, ctx-&gt;pattern+3, ctx-&gt;pattern[1]);
                RETURN_ON_ERROR(ret);
                DATA_LOOKUP_AT(SRE(match_context), ctx, ctx_pos);
                if (ret &lt; (Py_ssize_t) ctx-&gt;pattern[1])
                    /* didn't match minimum number of times */
                    RETURN_FAILURE;
                /* advance past minimum matches of repeat */
                ctx-&gt;count = ret;
                ctx-&gt;ptr += ctx-&gt;count;
            }

            if (ctx-&gt;pattern[ctx-&gt;pattern[0]] == SRE_OP_SUCCESS &amp;&amp;
                !(ctx-&gt;toplevel &amp;&amp;
                  ((state-&gt;match_all &amp;&amp; ctx-&gt;ptr != state-&gt;end) ||
                   (state-&gt;must_advance &amp;&amp; ctx-&gt;ptr == state-&gt;start))))
            {
                /* tail is empty.  we're finished */
                state-&gt;ptr = ctx-&gt;ptr;
                RETURN_SUCCESS;

            } else {
                /* general case */
                LASTMARK_SAVE();
                while ((Py_ssize_t)ctx-&gt;pattern[2] == SRE_MAXREPEAT
                       || ctx-&gt;count &lt;= (Py_ssize_t)ctx-&gt;pattern[2]) {
                    state-&gt;ptr = ctx-&gt;ptr;
                    DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
                            ctx-&gt;pattern+ctx-&gt;pattern[0]);
                    if (ret) {
                        RETURN_ON_ERROR(ret);
                        RETURN_SUCCESS;
                    }
                    state-&gt;ptr = ctx-&gt;ptr;
                    ret = SRE(count)(state, ctx-&gt;pattern+3, 1);
                    RETURN_ON_ERROR(ret);
                    DATA_LOOKUP_AT(SRE(match_context), ctx, ctx_pos);
                    if (ret == 0)
                        break;
                    assert(ret == 1);
                    ctx-&gt;ptr++;
                    ctx-&gt;count++;
                    LASTMARK_RESTORE();
                }
            }
            RETURN_FAILURE;

        case SRE_OP_REPEAT:
            /* create repeat context.  all the hard work is done
               by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
            /* &lt;REPEAT&gt; &lt;skip&gt; &lt;1=min&gt; &lt;2=max&gt; item &lt;UNTIL&gt; tail */
            TRACE(("|%p|%p|REPEAT %d %d\n", ctx-&gt;pattern, ctx-&gt;ptr,
                   ctx-&gt;pattern[1], ctx-&gt;pattern[2]));

            /* install new repeat context */
            ctx-&gt;u.rep = (SRE_REPEAT*) PyObject_MALLOC(sizeof(*ctx-&gt;u.rep));
            if (!ctx-&gt;u.rep) {
                PyErr_NoMemory();
                RETURN_FAILURE;
            }
            ctx-&gt;u.rep-&gt;count = -1;
            ctx-&gt;u.rep-&gt;pattern = ctx-&gt;pattern;
            ctx-&gt;u.rep-&gt;prev = state-&gt;repeat;
            ctx-&gt;u.rep-&gt;last_ptr = NULL;
            state-&gt;repeat = ctx-&gt;u.rep;

            state-&gt;ptr = ctx-&gt;ptr;
            DO_JUMP(JUMP_REPEAT, jump_repeat, ctx-&gt;pattern+ctx-&gt;pattern[0]);
            state-&gt;repeat = ctx-&gt;u.rep-&gt;prev;
            PyObject_FREE(ctx-&gt;u.rep);

            if (ret) {
                RETURN_ON_ERROR(ret);
                RETURN_SUCCESS;
            }
            RETURN_FAILURE;

        case SRE_OP_MAX_UNTIL:
            /* maximizing repeat */
            /* &lt;REPEAT&gt; &lt;skip&gt; &lt;1=min&gt; &lt;2=max&gt; item &lt;MAX_UNTIL&gt; tail */

            /* FIXME: we probably need to deal with zero-width
               matches in here... */

            ctx-&gt;u.rep = state-&gt;repeat;
            if (!ctx-&gt;u.rep)
                RETURN_ERROR(SRE_ERROR_STATE);

            state-&gt;ptr = ctx-&gt;ptr;

            ctx-&gt;count = ctx-&gt;u.rep-&gt;count+1;

            TRACE(("|%p|%p|MAX_UNTIL %" PY_FORMAT_SIZE_T "d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;count));

            if (ctx-&gt;count &lt; (Py_ssize_t) ctx-&gt;u.rep-&gt;pattern[1]) {
                /* not enough matches */
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count;
                DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
                        ctx-&gt;u.rep-&gt;pattern+3);
                if (ret) {
                    RETURN_ON_ERROR(ret);
                    RETURN_SUCCESS;
                }
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count-1;
                state-&gt;ptr = ctx-&gt;ptr;
                RETURN_FAILURE;
            }

            if ((ctx-&gt;count &lt; (Py_ssize_t) ctx-&gt;u.rep-&gt;pattern[2] ||
                ctx-&gt;u.rep-&gt;pattern[2] == SRE_MAXREPEAT) &amp;&amp;
                state-&gt;ptr != ctx-&gt;u.rep-&gt;last_ptr) {
                /* we may have enough matches, but if we can
                   match another item, do so */
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count;
                LASTMARK_SAVE();
                MARK_PUSH(ctx-&gt;lastmark);
                /* zero-width match protection */
                DATA_PUSH(&amp;ctx-&gt;u.rep-&gt;last_ptr);
                ctx-&gt;u.rep-&gt;last_ptr = state-&gt;ptr;
                DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
                        ctx-&gt;u.rep-&gt;pattern+3);
                DATA_POP(&amp;ctx-&gt;u.rep-&gt;last_ptr);
                if (ret) {
                    MARK_POP_DISCARD(ctx-&gt;lastmark);
                    RETURN_ON_ERROR(ret);
                    RETURN_SUCCESS;
                }
                MARK_POP(ctx-&gt;lastmark);
                LASTMARK_RESTORE();
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count-1;
                state-&gt;ptr = ctx-&gt;ptr;
            }

            /* cannot match more repeated items here.  make sure the
               tail matches */
            state-&gt;repeat = ctx-&gt;u.rep-&gt;prev;
            DO_JUMP(JUMP_MAX_UNTIL_3, jump_max_until_3, ctx-&gt;pattern);
            RETURN_ON_SUCCESS(ret);
            state-&gt;repeat = ctx-&gt;u.rep;
            state-&gt;ptr = ctx-&gt;ptr;
            RETURN_FAILURE;

        case SRE_OP_MIN_UNTIL:
            /* minimizing repeat */
            /* &lt;REPEAT&gt; &lt;skip&gt; &lt;1=min&gt; &lt;2=max&gt; item &lt;MIN_UNTIL&gt; tail */

            ctx-&gt;u.rep = state-&gt;repeat;
            if (!ctx-&gt;u.rep)
                RETURN_ERROR(SRE_ERROR_STATE);

            state-&gt;ptr = ctx-&gt;ptr;

            ctx-&gt;count = ctx-&gt;u.rep-&gt;count+1;

            TRACE(("|%p|%p|MIN_UNTIL %" PY_FORMAT_SIZE_T "d %p\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;count, ctx-&gt;u.rep-&gt;pattern));

            if (ctx-&gt;count &lt; (Py_ssize_t) ctx-&gt;u.rep-&gt;pattern[1]) {
                /* not enough matches */
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count;
                DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
                        ctx-&gt;u.rep-&gt;pattern+3);
                if (ret) {
                    RETURN_ON_ERROR(ret);
                    RETURN_SUCCESS;
                }
                ctx-&gt;u.rep-&gt;count = ctx-&gt;count-1;
                state-&gt;ptr = ctx-&gt;ptr;
                RETURN_FAILURE;
            }

            LASTMARK_SAVE();

            /* see if the tail matches */
            state-&gt;repeat = ctx-&gt;u.rep-&gt;prev;
            DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx-&gt;pattern);
            if (ret) {
                RETURN_ON_ERROR(ret);
                RETURN_SUCCESS;
            }

            state-&gt;repeat = ctx-&gt;u.rep;
            state-&gt;ptr = ctx-&gt;ptr;

            LASTMARK_RESTORE();

            if ((ctx-&gt;count &gt;= (Py_ssize_t) ctx-&gt;u.rep-&gt;pattern[2]
                &amp;&amp; ctx-&gt;u.rep-&gt;pattern[2] != SRE_MAXREPEAT) ||
                state-&gt;ptr == ctx-&gt;u.rep-&gt;last_ptr)
                RETURN_FAILURE;

            ctx-&gt;u.rep-&gt;count = ctx-&gt;count;
            /* zero-width match protection */
            DATA_PUSH(&amp;ctx-&gt;u.rep-&gt;last_ptr);
            ctx-&gt;u.rep-&gt;last_ptr = state-&gt;ptr;
            DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
                    ctx-&gt;u.rep-&gt;pattern+3);
            DATA_POP(&amp;ctx-&gt;u.rep-&gt;last_ptr);
            if (ret) {
                RETURN_ON_ERROR(ret);
                RETURN_SUCCESS;
            }
            ctx-&gt;u.rep-&gt;count = ctx-&gt;count-1;
            state-&gt;ptr = ctx-&gt;ptr;
            RETURN_FAILURE;

        case SRE_OP_GROUPREF:
            /* match backreference */
            TRACE(("|%p|%p|GROUPREF %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            i = ctx-&gt;pattern[0];
            {
                Py_ssize_t groupref = i+i;
                if (groupref &gt;= state-&gt;lastmark) {
                    RETURN_FAILURE;
                } else {
                    SRE_CHAR* p = (SRE_CHAR*) state-&gt;mark[groupref];
                    SRE_CHAR* e = (SRE_CHAR*) state-&gt;mark[groupref+1];
                    if (!p || !e || e &lt; p)
                        RETURN_FAILURE;
                    while (p &lt; e) {
                        if (ctx-&gt;ptr &gt;= end || *ctx-&gt;ptr != *p)
                            RETURN_FAILURE;
                        p++;
                        ctx-&gt;ptr++;
                    }
                }
            }
            ctx-&gt;pattern++;
            break;

        case SRE_OP_GROUPREF_IGNORE:
            /* match backreference */
            TRACE(("|%p|%p|GROUPREF_IGNORE %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            i = ctx-&gt;pattern[0];
            {
                Py_ssize_t groupref = i+i;
                if (groupref &gt;= state-&gt;lastmark) {
                    RETURN_FAILURE;
                } else {
                    SRE_CHAR* p = (SRE_CHAR*) state-&gt;mark[groupref];
                    SRE_CHAR* e = (SRE_CHAR*) state-&gt;mark[groupref+1];
                    if (!p || !e || e &lt; p)
                        RETURN_FAILURE;
                    while (p &lt; e) {
                        if (ctx-&gt;ptr &gt;= end ||
                            sre_lower_ascii(*ctx-&gt;ptr) != sre_lower_ascii(*p))
                            RETURN_FAILURE;
                        p++;
                        ctx-&gt;ptr++;
                    }
                }
            }
            ctx-&gt;pattern++;
            break;

        case SRE_OP_GROUPREF_UNI_IGNORE:
            /* match backreference */
            TRACE(("|%p|%p|GROUPREF_UNI_IGNORE %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            i = ctx-&gt;pattern[0];
            {
                Py_ssize_t groupref = i+i;
                if (groupref &gt;= state-&gt;lastmark) {
                    RETURN_FAILURE;
                } else {
                    SRE_CHAR* p = (SRE_CHAR*) state-&gt;mark[groupref];
                    SRE_CHAR* e = (SRE_CHAR*) state-&gt;mark[groupref+1];
                    if (!p || !e || e &lt; p)
                        RETURN_FAILURE;
                    while (p &lt; e) {
                        if (ctx-&gt;ptr &gt;= end ||
                            sre_lower_unicode(*ctx-&gt;ptr) != sre_lower_unicode(*p))
                            RETURN_FAILURE;
                        p++;
                        ctx-&gt;ptr++;
                    }
                }
            }
            ctx-&gt;pattern++;
            break;

        case SRE_OP_GROUPREF_LOC_IGNORE:
            /* match backreference */
            TRACE(("|%p|%p|GROUPREF_LOC_IGNORE %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            i = ctx-&gt;pattern[0];
            {
                Py_ssize_t groupref = i+i;
                if (groupref &gt;= state-&gt;lastmark) {
                    RETURN_FAILURE;
                } else {
                    SRE_CHAR* p = (SRE_CHAR*) state-&gt;mark[groupref];
                    SRE_CHAR* e = (SRE_CHAR*) state-&gt;mark[groupref+1];
                    if (!p || !e || e &lt; p)
                        RETURN_FAILURE;
                    while (p &lt; e) {
                        if (ctx-&gt;ptr &gt;= end ||
                            sre_lower_locale(*ctx-&gt;ptr) != sre_lower_locale(*p))
                            RETURN_FAILURE;
                        p++;
                        ctx-&gt;ptr++;
                    }
                }
            }
            ctx-&gt;pattern++;
            break;

        case SRE_OP_GROUPREF_EXISTS:
            TRACE(("|%p|%p|GROUPREF_EXISTS %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[0]));
            /* &lt;GROUPREF_EXISTS&gt; &lt;group&gt; &lt;skip&gt; codeyes &lt;JUMP&gt; codeno ... */
            i = ctx-&gt;pattern[0];
            {
                Py_ssize_t groupref = i+i;
                if (groupref &gt;= state-&gt;lastmark) {
                    ctx-&gt;pattern += ctx-&gt;pattern[1];
                    break;
                } else {
                    SRE_CHAR* p = (SRE_CHAR*) state-&gt;mark[groupref];
                    SRE_CHAR* e = (SRE_CHAR*) state-&gt;mark[groupref+1];
                    if (!p || !e || e &lt; p) {
                        ctx-&gt;pattern += ctx-&gt;pattern[1];
                        break;
                    }
                }
            }
            ctx-&gt;pattern += 2;
            break;

        case SRE_OP_ASSERT:
            /* assert subpattern */
            /* &lt;ASSERT&gt; &lt;skip&gt; &lt;back&gt; &lt;pattern&gt; */
            TRACE(("|%p|%p|ASSERT %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[1]));
            if (ctx-&gt;ptr - (SRE_CHAR *)state-&gt;beginning &lt; (Py_ssize_t)ctx-&gt;pattern[1])
                RETURN_FAILURE;
            state-&gt;ptr = ctx-&gt;ptr - ctx-&gt;pattern[1];
            DO_JUMP0(JUMP_ASSERT, jump_assert, ctx-&gt;pattern+2);
            RETURN_ON_FAILURE(ret);
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            break;

        case SRE_OP_ASSERT_NOT:
            /* assert not subpattern */
            /* &lt;ASSERT_NOT&gt; &lt;skip&gt; &lt;back&gt; &lt;pattern&gt; */
            TRACE(("|%p|%p|ASSERT_NOT %d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ctx-&gt;pattern[1]));
            if (ctx-&gt;ptr - (SRE_CHAR *)state-&gt;beginning &gt;= (Py_ssize_t)ctx-&gt;pattern[1]) {
                state-&gt;ptr = ctx-&gt;ptr - ctx-&gt;pattern[1];
                DO_JUMP0(JUMP_ASSERT_NOT, jump_assert_not, ctx-&gt;pattern+2);
                if (ret) {
                    RETURN_ON_ERROR(ret);
                    RETURN_FAILURE;
                }
            }
            ctx-&gt;pattern += ctx-&gt;pattern[0];
            break;

        case SRE_OP_FAILURE:
            /* immediate failure */
            TRACE(("|%p|%p|FAILURE\n", ctx-&gt;pattern, ctx-&gt;ptr));
            RETURN_FAILURE;

        default:
            TRACE(("|%p|%p|UNKNOWN %d\n", ctx-&gt;pattern, ctx-&gt;ptr,
                   ctx-&gt;pattern[-1]));
            RETURN_ERROR(SRE_ERROR_ILLEGAL);
        }
    }

exit:
    ctx_pos = ctx-&gt;last_ctx_pos;
    jump = ctx-&gt;jump;
    DATA_POP_DISCARD(ctx);
    if (ctx_pos == -1)
        return ret;
    DATA_LOOKUP_AT(SRE(match_context), ctx, ctx_pos);

    switch (jump) {
        case JUMP_MAX_UNTIL_2:
            TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_max_until_2;
        case JUMP_MAX_UNTIL_3:
            TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_max_until_3;
        case JUMP_MIN_UNTIL_2:
            TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_min_until_2;
        case JUMP_MIN_UNTIL_3:
            TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_min_until_3;
        case JUMP_BRANCH:
            TRACE(("|%p|%p|JUMP_BRANCH\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_branch;
        case JUMP_MAX_UNTIL_1:
            TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_max_until_1;
        case JUMP_MIN_UNTIL_1:
            TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_min_until_1;
        case JUMP_REPEAT:
            TRACE(("|%p|%p|JUMP_REPEAT\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_repeat;
        case JUMP_REPEAT_ONE_1:
            TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_repeat_one_1;
        case JUMP_REPEAT_ONE_2:
            TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_repeat_one_2;
        case JUMP_MIN_REPEAT_ONE:
            TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_min_repeat_one;
        case JUMP_ASSERT:
            TRACE(("|%p|%p|JUMP_ASSERT\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_assert;
        case JUMP_ASSERT_NOT:
            TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx-&gt;pattern, ctx-&gt;ptr));
            goto jump_assert_not;
        case JUMP_NONE:
            TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx-&gt;pattern,
                   ctx-&gt;ptr, ret));
            break;
    }

    return ret; /* should never get here */
}

/* need to reset capturing groups between two SRE(match) callings in loops */
#define RESET_CAPTURE_GROUP() \
    do { state-&gt;lastmark = state-&gt;lastindex = -1; } while (0)

LOCAL(Py_ssize_t)
SRE(search)(SRE_STATE* state, SRE_CODE* pattern)
{
    SRE_CHAR* ptr = (SRE_CHAR *)state-&gt;start;
    SRE_CHAR* end = (SRE_CHAR *)state-&gt;end;
    Py_ssize_t status = 0;
    Py_ssize_t prefix_len = 0;
    Py_ssize_t prefix_skip = 0;
    SRE_CODE* prefix = NULL;
    SRE_CODE* charset = NULL;
    SRE_CODE* overlap = NULL;
    int flags = 0;

    if (ptr &gt; end)
        return 0;

    if (pattern[0] == SRE_OP_INFO) {
        /* optimization info block */
        /* &lt;INFO&gt; &lt;1=skip&gt; &lt;2=flags&gt; &lt;3=min&gt; &lt;4=max&gt; &lt;5=prefix info&gt;  */

<span style = "background-color:#fdd">        flags = pattern[2];        Out-of-bound array access:Access out-of-bound array element (buffer overflow)</span>

        if (pattern[3] &amp;&amp; end - ptr &lt; (Py_ssize_t)pattern[3]) {
            TRACE(("reject (got %u chars, need %u)\n",
                   (unsigned int)(end - ptr), pattern[3]));
            return 0;
        }
        if (pattern[3] &gt; 1) {
            /* adjust end point (but make sure we leave at least one
               character in there, so literal search will work) */
            end -= pattern[3] - 1;
            if (end &lt;= ptr)
                end = ptr;
        }

        if (flags &amp; SRE_INFO_PREFIX) {
            /* pattern starts with a known prefix */
            /* &lt;length&gt; &lt;skip&gt; &lt;prefix data&gt; &lt;overlap data&gt; */
            prefix_len = pattern[5];
            prefix_skip = pattern[6];
            prefix = pattern + 7;
            overlap = prefix + prefix_len - 1;
        } else if (flags &amp; SRE_INFO_CHARSET)
            /* pattern starts with a character from a known set */
            /* &lt;charset&gt; */
            charset = pattern + 5;

        pattern += 1 + pattern[1];
    }

    TRACE(("prefix = %p %" PY_FORMAT_SIZE_T "d %" PY_FORMAT_SIZE_T "d\n",
           prefix, prefix_len, prefix_skip));
    TRACE(("charset = %p\n", charset));

    if (prefix_len == 1) {
        /* pattern starts with a literal character */
        SRE_CHAR c = (SRE_CHAR) prefix[0];
#if SIZEOF_SRE_CHAR &lt; 4
        if ((SRE_CODE) c != prefix[0])
            return 0; /* literal can't match: doesn't fit in char width */
#endif
        end = (SRE_CHAR *)state-&gt;end;
        state-&gt;must_advance = 0;
        while (ptr &lt; end) {
            while (*ptr != c) {
                if (++ptr &gt;= end)
                    return 0;
            }
            TRACE(("|%p|%p|SEARCH LITERAL\n", pattern, ptr));
            state-&gt;start = ptr;
            state-&gt;ptr = ptr + prefix_skip;
            if (flags &amp; SRE_INFO_LITERAL)
                return 1; /* we got all of it */
            status = SRE(match)(state, pattern + 2*prefix_skip, 0);
            if (status != 0)
                return status;
            ++ptr;
            RESET_CAPTURE_GROUP();
        }
        return 0;
    }

    if (prefix_len &gt; 1) {
        /* pattern starts with a known prefix.  use the overlap
           table to skip forward as fast as we possibly can */
        Py_ssize_t i = 0;

        end = (SRE_CHAR *)state-&gt;end;
        if (prefix_len &gt; end - ptr)
            return 0;
#if SIZEOF_SRE_CHAR &lt; 4
        for (i = 0; i &lt; prefix_len; i++)
            if ((SRE_CODE)(SRE_CHAR) prefix[i] != prefix[i])
                return 0; /* literal can't match: doesn't fit in char width */
#endif
        while (ptr &lt; end) {
            SRE_CHAR c = (SRE_CHAR) prefix[0];
            while (*ptr++ != c) {
                if (ptr &gt;= end)
                    return 0;
            }
            if (ptr &gt;= end)
                return 0;

            i = 1;
            state-&gt;must_advance = 0;
            do {
                if (*ptr == (SRE_CHAR) prefix[i]) {
                    if (++i != prefix_len) {
                        if (++ptr &gt;= end)
                            return 0;
                        continue;
                    }
                    /* found a potential match */
                    TRACE(("|%p|%p|SEARCH SCAN\n", pattern, ptr));
                    state-&gt;start = ptr - (prefix_len - 1);
                    state-&gt;ptr = ptr - (prefix_len - prefix_skip - 1);
                    if (flags &amp; SRE_INFO_LITERAL)
                        return 1; /* we got all of it */
                    status = SRE(match)(state, pattern + 2*prefix_skip, 0);
                    if (status != 0)
                        return status;
                    /* close but no cigar -- try again */
                    if (++ptr &gt;= end)
                        return 0;
                    RESET_CAPTURE_GROUP();
                }
                i = overlap[i];
            } while (i != 0);
        }
        return 0;
    }

    if (charset) {
        /* pattern starts with a character from a known set */
        end = (SRE_CHAR *)state-&gt;end;
        state-&gt;must_advance = 0;
        for (;;) {
            while (ptr &lt; end &amp;&amp; !SRE(charset)(state, charset, *ptr))
                ptr++;
            if (ptr &gt;= end)
                return 0;
            TRACE(("|%p|%p|SEARCH CHARSET\n", pattern, ptr));
            state-&gt;start = ptr;
            state-&gt;ptr = ptr;
            status = SRE(match)(state, pattern, 0);
            if (status != 0)
                break;
            ptr++;
            RESET_CAPTURE_GROUP();
        }
    } else {
        /* general case */
        assert(ptr &lt;= end);
        TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
        state-&gt;start = state-&gt;ptr = ptr;
        status = SRE(match)(state, pattern, 1);
        state-&gt;must_advance = 0;
        while (status == 0 &amp;&amp; ptr &lt; end) {
            ptr++;
            RESET_CAPTURE_GROUP();
            TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
            state-&gt;start = state-&gt;ptr = ptr;
            status = SRE(match)(state, pattern, 0);
        }
    }

    return status;
}

#undef SRE_CHAR
#undef SIZEOF_SRE_CHAR
#undef SRE

/* vim:ts=4:sw=4:et
*/
      </pre>
    </body>
</html>
